; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\theclashingfritz\source\repos\INIFileParser\zlib\gzwrite.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@ ; `string'
PUBLIC	??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@ ; `string'
EXTRN	_vsnprintf:PROC
EXTRN	_write:PROC
;	COMDAT ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
CONST	SEGMENT
??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@ DB 'requested l'
	DB	'ength does not fit in int', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@
CONST	SEGMENT
??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@ DB 'internal er'
	DB	'ror: deflate stream corrupt', 00H		; `string'
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\gzwrite.c
;	COMDAT _gz_init
_TEXT	SEGMENT
_gz_init PROC						; COMDAT
; _state$ = esi

; 20   :     int ret;
; 21   :     z_streamp strm = &(state->strm);
; 22   : 
; 23   :     /* allocate input buffer (double size for gzprintf) */
; 24   :     state->in = (unsigned char *)malloc(state->want << 1);

  00000	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00003	53		 push	 ebx
  00004	57		 push	 edi
  00005	03 c0		 add	 eax, eax
  00007	50		 push	 eax
  00008	8d 7e 64	 lea	 edi, DWORD PTR [esi+100]
  0000b	e8 00 00 00 00	 call	 _malloc
  00010	8b d8		 mov	 ebx, eax
  00012	83 c4 04	 add	 esp, 4
  00015	89 5e 24	 mov	 DWORD PTR [esi+36], ebx

; 25   :     if (state->in == NULL) {

  00018	85 db		 test	 ebx, ebx

; 26   :         gz_error(state, Z_MEM_ERROR, "out of memory");
; 27   :         return -1;

  0001a	74 28		 je	 SHORT $LN8@gz_init

; 28   :     }
; 29   : 
; 30   :     /* only need output buffer and deflate state if compressing */
; 31   :     if (!state->direct) {

  0001c	83 7e 2c 00	 cmp	 DWORD PTR [esi+44], 0
  00020	0f 85 92 00 00
	00		 jne	 $LN4@gz_init

; 32   :         /* allocate output buffer */
; 33   :         state->out = (unsigned char *)malloc(state->want);

  00026	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 _malloc

; 34   :         if (state->out == NULL) {

  0002f	33 c9		 xor	 ecx, ecx
  00031	83 c4 04	 add	 esp, 4
  00034	89 46 28	 mov	 DWORD PTR [esi+40], eax
  00037	3b c1		 cmp	 eax, ecx
  00039	75 20		 jne	 SHORT $LN3@gz_init

; 35   :             free(state->in);

  0003b	53		 push	 ebx
  0003c	e8 00 00 00 00	 call	 _free
  00041	83 c4 04	 add	 esp, 4
$LN8@gz_init:

; 36   :             gz_error(state, Z_MEM_ERROR, "out of memory");

  00044	bb 00 00 00 00	 mov	 ebx, OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  00049	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0004e	8b ce		 mov	 ecx, esi
  00050	e8 00 00 00 00	 call	 _gz_error
  00055	5f		 pop	 edi

; 37   :             return -1;

  00056	83 c8 ff	 or	 eax, -1
  00059	5b		 pop	 ebx

; 65   : }

  0005a	c3		 ret	 0
$LN3@gz_init:

; 38   :         }
; 39   : 
; 40   :         /* allocate deflate memory, set up for gzip compression */
; 41   :         strm->zalloc = Z_NULL;
; 42   :         strm->zfree = Z_NULL;
; 43   :         strm->opaque = Z_NULL;
; 44   :         ret = deflateInit2(strm, state->level, Z_DEFLATED,
; 45   :                            MAX_WBITS + 16, DEF_MEM_LEVEL, state->strategy);

  0005b	6a 38		 push	 56			; 00000038H
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_06CJNJFBNP@1?42?411?$AA@
  00062	89 4f 20	 mov	 DWORD PTR [edi+32], ecx
  00065	89 4f 24	 mov	 DWORD PTR [edi+36], ecx
  00068	89 4f 28	 mov	 DWORD PTR [edi+40], ecx
  0006b	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  0006e	8b 56 48	 mov	 edx, DWORD PTR [esi+72]
  00071	51		 push	 ecx
  00072	6a 08		 push	 8
  00074	6a 1f		 push	 31			; 0000001fH
  00076	6a 08		 push	 8
  00078	52		 push	 edx
  00079	57		 push	 edi
  0007a	e8 00 00 00 00	 call	 _deflateInit2_
  0007f	83 c4 20	 add	 esp, 32			; 00000020H

; 46   :         if (ret != Z_OK) {

  00082	85 c0		 test	 eax, eax
  00084	74 2c		 je	 SHORT $LN2@gz_init

; 47   :             free(state->out);

  00086	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 _free

; 48   :             free(state->in);

  0008f	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00092	51		 push	 ecx
  00093	e8 00 00 00 00	 call	 _free
  00098	83 c4 08	 add	 esp, 8

; 49   :             gz_error(state, Z_MEM_ERROR, "out of memory");

  0009b	bb 00 00 00 00	 mov	 ebx, OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  000a0	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  000a5	8b ce		 mov	 ecx, esi
  000a7	e8 00 00 00 00	 call	 _gz_error
  000ac	5f		 pop	 edi

; 50   :             return -1;

  000ad	83 c8 ff	 or	 eax, -1
  000b0	5b		 pop	 ebx

; 65   : }

  000b1	c3		 ret	 0
$LN2@gz_init:

; 51   :         }
; 52   :         strm->next_in = NULL;

  000b2	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN4@gz_init:

; 53   :     }
; 54   : 
; 55   :     /* mark state as initialized */
; 56   :     state->size = state->want;
; 57   : 
; 58   :     /* initialize write buffer if compressing */
; 59   :     if (!state->direct) {

  000b8	83 7e 2c 00	 cmp	 DWORD PTR [esi+44], 0
  000bc	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  000bf	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  000c2	75 0c		 jne	 SHORT $LN1@gz_init

; 60   :         strm->avail_out = state->size;

  000c4	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 61   :         strm->next_out = state->out;

  000c7	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  000ca	89 47 0c	 mov	 DWORD PTR [edi+12], eax

; 62   :         state->x.next = strm->next_out;

  000cd	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN1@gz_init:

; 63   :     }
; 64   :     return 0;

  000d0	5f		 pop	 edi
  000d1	33 c0		 xor	 eax, eax
  000d3	5b		 pop	 ebx

; 65   : }

  000d4	c3		 ret	 0
_gz_init ENDP
; Function compile flags: /Ogtp
;	COMDAT _gz_comp
_TEXT	SEGMENT
_flush$ = 8						; size = 4
_gz_comp PROC						; COMDAT
; _state$ = eax

; 76   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f0		 mov	 esi, eax

; 77   :     int ret, writ;
; 78   :     unsigned have, put, max = ((unsigned)-1 >> 2) + 1;
; 79   :     z_streamp strm = &(state->strm);
; 80   : 
; 81   :     /* allocate memory if this is the first time through */
; 82   :     if (state->size == 0 && gz_init(state) == -1)

  00006	83 7e 1c 00	 cmp	 DWORD PTR [esi+28], 0
  0000a	57		 push	 edi
  0000b	8d 7e 64	 lea	 edi, DWORD PTR [esi+100]
  0000e	75 10		 jne	 SHORT $LN33@gz_comp
  00010	e8 00 00 00 00	 call	 _gz_init
  00015	83 f8 ff	 cmp	 eax, -1
  00018	75 06		 jne	 SHORT $LN33@gz_comp

; 83   :         return -1;

  0001a	5f		 pop	 edi
  0001b	0b c0		 or	 eax, eax
  0001d	5e		 pop	 esi

; 141  : }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
$LN33@gz_comp:

; 84   : 
; 85   :     /* write directly if requested */
; 86   :     if (state->direct) {

  00020	83 7e 2c 00	 cmp	 DWORD PTR [esi+44], 0
  00024	53		 push	 ebx
  00025	74 63		 je	 SHORT $LN16@gz_comp

; 87   :         while (strm->avail_in) {

  00027	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  0002b	0f 84 f5 00 00
	00		 je	 $LN1@gz_comp
$LL15@gz_comp:

; 88   :             put = strm->avail_in > max ? max : strm->avail_in;

  00031	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00034	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  00039	76 05		 jbe	 SHORT $LN20@gz_comp
  0003b	b8 00 00 00 40	 mov	 eax, 1073741824		; 40000000H
$LN20@gz_comp:

; 89   :             writ = write(state->fd, strm->next_in, put);

  00040	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00043	50		 push	 eax
  00044	8b 07		 mov	 eax, DWORD PTR [edi]
  00046	50		 push	 eax
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 _write
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 90   :             if (writ < 0) {

  00050	85 c0		 test	 eax, eax
  00052	78 12		 js	 SHORT $LN27@gz_comp

; 93   :             }
; 94   :             strm->avail_in -= (unsigned)writ;

  00054	29 47 04	 sub	 DWORD PTR [edi+4], eax

; 95   :             strm->next_in += writ;

  00057	01 07		 add	 DWORD PTR [edi], eax
  00059	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  0005d	75 d2		 jne	 SHORT $LL15@gz_comp

; 138  : 
; 139  :     /* all done, no errors */
; 140  :     return 0;

  0005f	5b		 pop	 ebx
  00060	5f		 pop	 edi
  00061	33 c0		 xor	 eax, eax
  00063	5e		 pop	 esi

; 141  : }

  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
$LN27@gz_comp:

; 91   :                 gz_error(state, Z_ERRNO, zstrerror());

  00066	e8 00 00 00 00	 call	 __errno
  0006b	8b 10		 mov	 edx, DWORD PTR [eax]
  0006d	52		 push	 edx
  0006e	e8 00 00 00 00	 call	 _strerror
  00073	8b d8		 mov	 ebx, eax
  00075	83 c4 04	 add	 esp, 4
  00078	83 c8 ff	 or	 eax, -1
  0007b	8b ce		 mov	 ecx, esi
  0007d	e8 00 00 00 00	 call	 _gz_error
  00082	5b		 pop	 ebx
  00083	5f		 pop	 edi

; 92   :                 return -1;

  00084	83 c8 ff	 or	 eax, -1
  00087	5e		 pop	 esi

; 141  : }

  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
$LN16@gz_comp:

; 96   :         }
; 97   :         return 0;
; 98   :     }
; 99   : 
; 100  :     /* run deflate() on provided input until it produces no more output */
; 101  :     ret = Z_OK;

  0008a	33 c0		 xor	 eax, eax
  0008c	8d 64 24 00	 npad	 4
$LL12@gz_comp:

; 102  :     do {
; 103  :         /* write out current buffer contents if full, or if flushing, but if
; 104  :            doing Z_FINISH then don't write until we get to Z_STREAM_END */
; 105  :         if (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&
; 106  :             (flush != Z_FINISH || ret == Z_STREAM_END))) {

  00090	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  00094	74 11		 je	 SHORT $LN34@gz_comp
  00096	8b 4d 08	 mov	 ecx, DWORD PTR _flush$[ebp]
  00099	85 c9		 test	 ecx, ecx
  0009b	74 5c		 je	 SHORT $LN35@gz_comp
  0009d	83 f9 04	 cmp	 ecx, 4
  000a0	75 05		 jne	 SHORT $LN34@gz_comp
  000a2	83 f8 01	 cmp	 eax, 1
  000a5	75 52		 jne	 SHORT $LN35@gz_comp
$LN34@gz_comp:

; 107  :             while (strm->next_out > state->x.next) {

  000a7	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000aa	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  000ad	76 32		 jbe	 SHORT $LN5@gz_comp
  000af	90		 npad	 1
$LL6@gz_comp:

; 108  :                 put = strm->next_out - state->x.next > (int)max ? max :
; 109  :                       (unsigned)(strm->next_out - state->x.next);

  000b0	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000b3	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000b6	2b c1		 sub	 eax, ecx
  000b8	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  000bd	7e 05		 jle	 SHORT $LN22@gz_comp
  000bf	b8 00 00 00 40	 mov	 eax, 1073741824		; 40000000H
$LN22@gz_comp:

; 110  :                 writ = write(state->fd, state->x.next, put);

  000c4	50		 push	 eax
  000c5	51		 push	 ecx
  000c6	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  000c9	51		 push	 ecx
  000ca	e8 00 00 00 00	 call	 _write
  000cf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 111  :                 if (writ < 0) {

  000d2	85 c0		 test	 eax, eax
  000d4	78 57		 js	 SHORT $LN28@gz_comp

; 114  :                 }
; 115  :                 state->x.next += writ;

  000d6	01 46 04	 add	 DWORD PTR [esi+4], eax
  000d9	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  000dc	3b 56 04	 cmp	 edx, DWORD PTR [esi+4]
  000df	77 cf		 ja	 SHORT $LL6@gz_comp
$LN5@gz_comp:

; 116  :             }
; 117  :             if (strm->avail_out == 0) {

  000e1	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  000e5	75 12		 jne	 SHORT $LN35@gz_comp

; 118  :                 strm->avail_out = state->size;

  000e7	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  000ea	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 119  :                 strm->next_out = state->out;

  000ed	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  000f0	89 4f 0c	 mov	 DWORD PTR [edi+12], ecx

; 120  :                 state->x.next = state->out;

  000f3	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  000f6	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN35@gz_comp:

; 121  :             }
; 122  :         }
; 123  : 
; 124  :         /* compress */
; 125  :         have = strm->avail_out;
; 126  :         ret = deflate(strm, flush);

  000f9	8b 45 08	 mov	 eax, DWORD PTR _flush$[ebp]
  000fc	8b 5f 10	 mov	 ebx, DWORD PTR [edi+16]
  000ff	50		 push	 eax
  00100	57		 push	 edi
  00101	e8 00 00 00 00	 call	 _deflate
  00106	83 c4 08	 add	 esp, 8

; 127  :         if (ret == Z_STREAM_ERROR) {

  00109	83 f8 fe	 cmp	 eax, -2			; fffffffeH
  0010c	74 43		 je	 SHORT $LN30@gz_comp

; 131  :         }
; 132  :         have -= strm->avail_out;

  0010e	2b 5f 10	 sub	 ebx, DWORD PTR [edi+16]

; 133  :     } while (have);

  00111	0f 85 79 ff ff
	ff		 jne	 $LL12@gz_comp

; 134  : 
; 135  :     /* if that completed a deflate stream, allow another to start */
; 136  :     if (flush == Z_FINISH)

  00117	83 7d 08 04	 cmp	 DWORD PTR _flush$[ebp], 4
  0011b	75 09		 jne	 SHORT $LN1@gz_comp

; 137  :         deflateReset(strm);

  0011d	57		 push	 edi
  0011e	e8 00 00 00 00	 call	 _deflateReset
  00123	83 c4 04	 add	 esp, 4
$LN1@gz_comp:

; 138  : 
; 139  :     /* all done, no errors */
; 140  :     return 0;

  00126	5b		 pop	 ebx
  00127	5f		 pop	 edi
  00128	33 c0		 xor	 eax, eax
  0012a	5e		 pop	 esi

; 141  : }

  0012b	5d		 pop	 ebp
  0012c	c3		 ret	 0
$LN28@gz_comp:

; 112  :                     gz_error(state, Z_ERRNO, zstrerror());

  0012d	e8 00 00 00 00	 call	 __errno
  00132	8b 08		 mov	 ecx, DWORD PTR [eax]
  00134	51		 push	 ecx
  00135	e8 00 00 00 00	 call	 _strerror
  0013a	8b d8		 mov	 ebx, eax
  0013c	83 c4 04	 add	 esp, 4
  0013f	83 c8 ff	 or	 eax, -1
  00142	8b ce		 mov	 ecx, esi
  00144	e8 00 00 00 00	 call	 _gz_error
  00149	5b		 pop	 ebx
  0014a	5f		 pop	 edi

; 113  :                     return -1;

  0014b	83 c8 ff	 or	 eax, -1
  0014e	5e		 pop	 esi

; 141  : }

  0014f	5d		 pop	 ebp
  00150	c3		 ret	 0
$LN30@gz_comp:

; 128  :             gz_error(state, Z_STREAM_ERROR,
; 129  :                       "internal error: deflate stream corrupt");

  00151	bb 00 00 00 00	 mov	 ebx, OFFSET ??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@
  00156	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0015b	8b ce		 mov	 ecx, esi
  0015d	e8 00 00 00 00	 call	 _gz_error
  00162	5b		 pop	 ebx
  00163	5f		 pop	 edi

; 130  :             return -1;

  00164	83 c8 ff	 or	 eax, -1
  00167	5e		 pop	 esi

; 141  : }

  00168	5d		 pop	 ebp
  00169	c3		 ret	 0
_gz_comp ENDP
; Function compile flags: /Ogtp
;	COMDAT _gz_zero
_TEXT	SEGMENT
_first$ = -4						; size = 4
_len$ = 8						; size = 8
_gz_zero PROC						; COMDAT
; _state$ = esi

; 148  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 149  :     int first;
; 150  :     unsigned n;
; 151  :     z_streamp strm = &(state->strm);
; 152  : 
; 153  :     /* consume whatever's left in the input buffer */
; 154  :     if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  00004	83 7e 68 00	 cmp	 DWORD PTR [esi+104], 0
  00008	74 17		 je	 SHORT $LN5@gz_zero
  0000a	6a 00		 push	 0
  0000c	8b c6		 mov	 eax, esi
  0000e	e8 00 00 00 00	 call	 _gz_comp
  00013	83 c4 04	 add	 esp, 4
  00016	83 f8 ff	 cmp	 eax, -1
  00019	75 06		 jne	 SHORT $LN5@gz_zero

; 155  :         return -1;

  0001b	0b c0		 or	 eax, eax

; 172  :     }
; 173  :     return 0;
; 174  : }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
$LN5@gz_zero:
  00021	53		 push	 ebx
  00022	57		 push	 edi

; 156  : 
; 157  :     /* compress len zeros (len guaranteed > 0) */
; 158  :     first = 1;
; 159  :     while (len) {

  00023	8b 7d 08	 mov	 edi, DWORD PTR _len$[ebp]
  00026	8b c7		 mov	 eax, edi
  00028	0b 45 0c	 or	 eax, DWORD PTR _len$[ebp+4]
  0002b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _first$[ebp], 1
  00032	75 0f		 jne	 SHORT $LN4@gz_zero
  00034	5f		 pop	 edi
  00035	5b		 pop	 ebx

; 172  :     }
; 173  :     return 0;
; 174  : }

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
  0003a	8d 9b 00 00 00
	00		 npad	 6
$LL14@gz_zero:

; 156  : 
; 157  :     /* compress len zeros (len guaranteed > 0) */
; 158  :     first = 1;
; 159  :     while (len) {

  00040	8b 7d 08	 mov	 edi, DWORD PTR _len$[ebp]
$LN4@gz_zero:

; 160  :         n = GT_OFF(state->size) || (z_off64_t)state->size > len ?
; 161  :             (unsigned)len : state->size;

  00043	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00046	33 c0		 xor	 eax, eax
  00048	33 db		 xor	 ebx, ebx
  0004a	3b 45 0c	 cmp	 eax, DWORD PTR _len$[ebp+4]
  0004d	7f 08		 jg	 SHORT $LN8@gz_zero
  0004f	7c 04		 jl	 SHORT $LN13@gz_zero
  00051	3b cf		 cmp	 ecx, edi
  00053	77 02		 ja	 SHORT $LN8@gz_zero
$LN13@gz_zero:
  00055	8b f9		 mov	 edi, ecx
$LN8@gz_zero:

; 162  :         if (first) {

  00057	39 5d fc	 cmp	 DWORD PTR _first$[ebp], ebx
  0005a	74 11		 je	 SHORT $LN2@gz_zero

; 163  :             memset(state->in, 0, n);

  0005c	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  0005f	57		 push	 edi
  00060	53		 push	 ebx
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 _memset
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH

; 164  :             first = 0;

  0006a	89 5d fc	 mov	 DWORD PTR _first$[ebp], ebx
$LN2@gz_zero:

; 165  :         }
; 166  :         strm->avail_in = n;

  0006d	89 7e 68	 mov	 DWORD PTR [esi+104], edi

; 167  :         strm->next_in = state->in;

  00070	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  00073	89 56 64	 mov	 DWORD PTR [esi+100], edx

; 168  :         state->x.pos += n;

  00076	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 169  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  00079	53		 push	 ebx
  0007a	8b c6		 mov	 eax, esi
  0007c	11 5e 0c	 adc	 DWORD PTR [esi+12], ebx
  0007f	e8 00 00 00 00	 call	 _gz_comp
  00084	83 c4 04	 add	 esp, 4
  00087	83 f8 ff	 cmp	 eax, -1
  0008a	74 1a		 je	 SHORT $LN11@gz_zero

; 171  :         len -= n;

  0008c	8b 45 08	 mov	 eax, DWORD PTR _len$[ebp]
  0008f	8b 4d 0c	 mov	 ecx, DWORD PTR _len$[ebp+4]
  00092	2b c7		 sub	 eax, edi
  00094	1b cb		 sbb	 ecx, ebx
  00096	89 45 08	 mov	 DWORD PTR _len$[ebp], eax
  00099	0b c1		 or	 eax, ecx
  0009b	89 4d 0c	 mov	 DWORD PTR _len$[ebp+4], ecx
  0009e	75 a0		 jne	 SHORT $LL14@gz_zero
  000a0	5f		 pop	 edi
  000a1	5b		 pop	 ebx

; 172  :     }
; 173  :     return 0;
; 174  : }

  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
$LN11@gz_zero:
  000a6	5f		 pop	 edi

; 170  :             return -1;

  000a7	83 c8 ff	 or	 eax, -1
  000aa	5b		 pop	 ebx

; 172  :     }
; 173  :     return 0;
; 174  : }

  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
_gz_zero ENDP
PUBLIC	_gzclose_w
; Function compile flags: /Ogtp
;	COMDAT _gzclose_w
_TEXT	SEGMENT
_file$ = 8						; size = 4
_gzclose_w PROC						; COMDAT

; 629  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 630  :     int ret = Z_OK;
; 631  :     gz_statep state;
; 632  : 
; 633  :     /* get internal structure */
; 634  :     if (file == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00007	57		 push	 edi
  00008	33 ff		 xor	 edi, edi
  0000a	85 f6		 test	 esi, esi
  0000c	75 09		 jne	 SHORT $LN8@gzclose_w
$LN12@gzclose_w:
  0000e	5f		 pop	 edi

; 635  :         return Z_STREAM_ERROR;

  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00014	5e		 pop	 esi

; 665  : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
$LN8@gzclose_w:

; 636  :     state = (gz_statep)file;
; 637  : 
; 638  :     /* check that we're writing */
; 639  :     if (state->mode != GZ_WRITE)

  00017	81 7e 10 b1 79
	00 00		 cmp	 DWORD PTR [esi+16], 31153 ; 000079b1H

; 640  :         return Z_STREAM_ERROR;

  0001e	75 ee		 jne	 SHORT $LN12@gzclose_w

; 641  : 
; 642  :     /* check for seek request */
; 643  :     if (state->seek) {

  00020	39 7e 58	 cmp	 DWORD PTR [esi+88], edi
  00023	74 1b		 je	 SHORT $LN11@gzclose_w

; 644  :         state->seek = 0;
; 645  :         if (gz_zero(state, state->skip) == -1)

  00025	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  00028	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  0002b	50		 push	 eax
  0002c	51		 push	 ecx
  0002d	89 7e 58	 mov	 DWORD PTR [esi+88], edi
  00030	e8 00 00 00 00	 call	 _gz_zero
  00035	83 c4 08	 add	 esp, 8
  00038	83 f8 ff	 cmp	 eax, -1
  0003b	75 03		 jne	 SHORT $LN11@gzclose_w

; 646  :             ret = state->err;

  0003d	8b 7e 5c	 mov	 edi, DWORD PTR [esi+92]
$LN11@gzclose_w:

; 647  :     }
; 648  : 
; 649  :     /* flush, free memory, and close file */
; 650  :     if (gz_comp(state, Z_FINISH) == -1)

  00040	6a 04		 push	 4
  00042	8b c6		 mov	 eax, esi
  00044	e8 00 00 00 00	 call	 _gz_comp
  00049	83 c4 04	 add	 esp, 4
  0004c	83 f8 ff	 cmp	 eax, -1
  0004f	75 03		 jne	 SHORT $LN4@gzclose_w

; 651  :         ret = state->err;

  00051	8b 7e 5c	 mov	 edi, DWORD PTR [esi+92]
$LN4@gzclose_w:

; 652  :     if (state->size) {

  00054	83 7e 1c 00	 cmp	 DWORD PTR [esi+28], 0
  00058	74 27		 je	 SHORT $LN3@gzclose_w

; 653  :         if (!state->direct) {

  0005a	83 7e 2c 00	 cmp	 DWORD PTR [esi+44], 0
  0005e	75 15		 jne	 SHORT $LN2@gzclose_w

; 654  :             (void)deflateEnd(&(state->strm));

  00060	8d 56 64	 lea	 edx, DWORD PTR [esi+100]
  00063	52		 push	 edx
  00064	e8 00 00 00 00	 call	 _deflateEnd

; 655  :             free(state->out);

  00069	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 _free
  00072	83 c4 08	 add	 esp, 8
$LN2@gzclose_w:

; 656  :         }
; 657  :         free(state->in);

  00075	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00078	51		 push	 ecx
  00079	e8 00 00 00 00	 call	 _free
  0007e	83 c4 04	 add	 esp, 4
$LN3@gzclose_w:

; 658  :     }
; 659  :     gz_error(state, Z_OK, NULL);

  00081	53		 push	 ebx
  00082	33 db		 xor	 ebx, ebx
  00084	33 c0		 xor	 eax, eax
  00086	8b ce		 mov	 ecx, esi
  00088	e8 00 00 00 00	 call	 _gz_error

; 660  :     free(state->path);

  0008d	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  00090	52		 push	 edx
  00091	e8 00 00 00 00	 call	 _free

; 661  :     if (close(state->fd) == -1)

  00096	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 _close
  0009f	83 c4 08	 add	 esp, 8
  000a2	5b		 pop	 ebx
  000a3	83 f8 ff	 cmp	 eax, -1
  000a6	75 02		 jne	 SHORT $LN1@gzclose_w

; 662  :         ret = Z_ERRNO;

  000a8	0b f8		 or	 edi, eax
$LN1@gzclose_w:

; 663  :     free(state);

  000aa	56		 push	 esi
  000ab	e8 00 00 00 00	 call	 _free
  000b0	83 c4 04	 add	 esp, 4

; 664  :     return ret;

  000b3	8b c7		 mov	 eax, edi
  000b5	5f		 pop	 edi
  000b6	5e		 pop	 esi

; 665  : }

  000b7	5d		 pop	 ebp
  000b8	c3		 ret	 0
_gzclose_w ENDP
_TEXT	ENDS
PUBLIC	_gzsetparams
; Function compile flags: /Ogtp
;	COMDAT _gzsetparams
_TEXT	SEGMENT
_file$ = 8						; size = 4
_level$ = 12						; size = 4
_strategy$ = 16						; size = 4
_gzsetparams PROC					; COMDAT

; 589  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 590  :     gz_statep state;
; 591  :     z_streamp strm;
; 592  : 
; 593  :     /* get internal structure */
; 594  :     if (file == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 08		 jne	 SHORT $LN8@gzsetparam
$LN6@gzsetparam:

; 595  :         return Z_STREAM_ERROR;

  0000b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00010	5e		 pop	 esi

; 624  : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
$LN8@gzsetparam:

; 596  :     state = (gz_statep)file;
; 597  :     strm = &(state->strm);
; 598  : 
; 599  :     /* check that we're writing and that there's no error */
; 600  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00013	81 7e 10 b1 79
	00 00		 cmp	 DWORD PTR [esi+16], 31153 ; 000079b1H
  0001a	75 ef		 jne	 SHORT $LN6@gzsetparam
  0001c	83 7e 5c 00	 cmp	 DWORD PTR [esi+92], 0
  00020	75 e9		 jne	 SHORT $LN6@gzsetparam

; 601  :         return Z_STREAM_ERROR;
; 602  : 
; 603  :     /* if no change is requested, then do nothing */
; 604  :     if (level == state->level && strategy == state->strategy)

  00022	53		 push	 ebx
  00023	8b 5d 10	 mov	 ebx, DWORD PTR _strategy$[ebp]
  00026	57		 push	 edi
  00027	8b 7d 0c	 mov	 edi, DWORD PTR _level$[ebp]
  0002a	3b 7e 48	 cmp	 edi, DWORD PTR [esi+72]
  0002d	75 05		 jne	 SHORT $LN5@gzsetparam
  0002f	3b 5e 4c	 cmp	 ebx, DWORD PTR [esi+76]

; 605  :         return Z_OK;

  00032	74 5b		 je	 SHORT $LN14@gzsetparam
$LN5@gzsetparam:

; 606  : 
; 607  :     /* check for seek request */
; 608  :     if (state->seek) {

  00034	83 7e 58 00	 cmp	 DWORD PTR [esi+88], 0
  00038	74 1c		 je	 SHORT $LN11@gzsetparam

; 609  :         state->seek = 0;
; 610  :         if (gz_zero(state, state->skip) == -1)

  0003a	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  0003d	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  00040	50		 push	 eax
  00041	51		 push	 ecx
  00042	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
  00049	e8 00 00 00 00	 call	 _gz_zero
  0004e	83 c4 08	 add	 esp, 8
  00051	83 f8 ff	 cmp	 eax, -1

; 611  :             return state->err;

  00054	74 1d		 je	 SHORT $LN15@gzsetparam
$LN11@gzsetparam:

; 612  :     }
; 613  : 
; 614  :     /* change compression parameters for subsequent input */
; 615  :     if (state->size) {

  00056	83 7e 1c 00	 cmp	 DWORD PTR [esi+28], 0
  0005a	74 2d		 je	 SHORT $LN2@gzsetparam

; 616  :         /* flush previous input with previous parameters before changing */
; 617  :         if (strm->avail_in && gz_comp(state, Z_BLOCK) == -1)

  0005c	83 7e 68 00	 cmp	 DWORD PTR [esi+104], 0
  00060	74 19		 je	 SHORT $LN1@gzsetparam
  00062	6a 05		 push	 5
  00064	8b c6		 mov	 eax, esi
  00066	e8 00 00 00 00	 call	 _gz_comp
  0006b	83 c4 04	 add	 esp, 4
  0006e	83 f8 ff	 cmp	 eax, -1
  00071	75 08		 jne	 SHORT $LN1@gzsetparam
$LN15@gzsetparam:

; 618  :             return state->err;

  00073	8b 46 5c	 mov	 eax, DWORD PTR [esi+92]
  00076	5f		 pop	 edi
  00077	5b		 pop	 ebx
  00078	5e		 pop	 esi

; 624  : }

  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
$LN1@gzsetparam:

; 619  :         deflateParams(strm, level, strategy);

  0007b	53		 push	 ebx
  0007c	8d 46 64	 lea	 eax, DWORD PTR [esi+100]
  0007f	57		 push	 edi
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 _deflateParams
  00086	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@gzsetparam:

; 620  :     }
; 621  :     state->level = level;

  00089	89 7e 48	 mov	 DWORD PTR [esi+72], edi

; 622  :     state->strategy = strategy;

  0008c	89 5e 4c	 mov	 DWORD PTR [esi+76], ebx
$LN14@gzsetparam:

; 623  :     return Z_OK;

  0008f	5f		 pop	 edi
  00090	5b		 pop	 ebx
  00091	33 c0		 xor	 eax, eax
  00093	5e		 pop	 esi

; 624  : }

  00094	5d		 pop	 ebp
  00095	c3		 ret	 0
_gzsetparams ENDP
_TEXT	ENDS
PUBLIC	_gzflush
; Function compile flags: /Ogtp
;	COMDAT _gzflush
_TEXT	SEGMENT
_file$ = 8						; size = 4
_flush$ = 12						; size = 4
_gzflush PROC						; COMDAT

; 556  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 557  :     gz_statep state;
; 558  : 
; 559  :     /* get internal structure */
; 560  :     if (file == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 08		 jne	 SHORT $LN7@gzflush
$LN5@gzflush:

; 561  :         return Z_STREAM_ERROR;

  0000b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00010	5e		 pop	 esi

; 582  : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
$LN7@gzflush:

; 562  :     state = (gz_statep)file;
; 563  : 
; 564  :     /* check that we're writing and that there's no error */
; 565  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00013	81 7e 10 b1 79
	00 00		 cmp	 DWORD PTR [esi+16], 31153 ; 000079b1H
  0001a	75 ef		 jne	 SHORT $LN5@gzflush
  0001c	83 7e 5c 00	 cmp	 DWORD PTR [esi+92], 0
  00020	75 e9		 jne	 SHORT $LN5@gzflush

; 566  :         return Z_STREAM_ERROR;
; 567  : 
; 568  :     /* check flush parameter */
; 569  :     if (flush < 0 || flush > Z_FINISH)

  00022	57		 push	 edi
  00023	8b 7d 0c	 mov	 edi, DWORD PTR _flush$[ebp]
  00026	83 ff 04	 cmp	 edi, 4
  00029	77 34		 ja	 SHORT $LN3@gzflush

; 571  : 
; 572  :     /* check for seek request */
; 573  :     if (state->seek) {

  0002b	83 7e 58 00	 cmp	 DWORD PTR [esi+88], 0
  0002f	74 1c		 je	 SHORT $LN1@gzflush

; 574  :         state->seek = 0;
; 575  :         if (gz_zero(state, state->skip) == -1)

  00031	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  00034	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  00037	50		 push	 eax
  00038	51		 push	 ecx
  00039	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
  00040	e8 00 00 00 00	 call	 _gz_zero
  00045	83 c4 08	 add	 esp, 8
  00048	83 f8 ff	 cmp	 eax, -1

; 576  :             return state->err;

  0004b	74 0b		 je	 SHORT $LN11@gzflush
$LN1@gzflush:

; 577  :     }
; 578  : 
; 579  :     /* compress remaining data with requested flush */
; 580  :     (void)gz_comp(state, flush);

  0004d	57		 push	 edi
  0004e	8b c6		 mov	 eax, esi
  00050	e8 00 00 00 00	 call	 _gz_comp
  00055	83 c4 04	 add	 esp, 4
$LN11@gzflush:

; 581  :     return state->err;

  00058	8b 46 5c	 mov	 eax, DWORD PTR [esi+92]
  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi

; 582  : }

  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
$LN3@gzflush:
  0005f	5f		 pop	 edi

; 570  :         return Z_STREAM_ERROR;

  00060	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00065	5e		 pop	 esi

; 582  : }

  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
_gzflush ENDP
_TEXT	ENDS
PUBLIC	_gzvprintf
; Function compile flags: /Ogtp
;	COMDAT _gzvprintf
_TEXT	SEGMENT
_file$ = 8						; size = 4
_format$ = 12						; size = 4
_va$ = 16						; size = 4
_gzvprintf PROC						; COMDAT

; 380  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 381  :     int len;
; 382  :     unsigned left;
; 383  :     char *next;
; 384  :     gz_statep state;
; 385  :     z_streamp strm;
; 386  : 
; 387  :     /* get internal structure */
; 388  :     if (file == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 08		 jne	 SHORT $LN11@gzvprintf
$LN9@gzvprintf:

; 389  :         return Z_STREAM_ERROR;

  0000b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00010	5e		 pop	 esi

; 449  : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
$LN11@gzvprintf:

; 390  :     state = (gz_statep)file;
; 391  :     strm = &(state->strm);
; 392  : 
; 393  :     /* check that we're writing and that there's no error */
; 394  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00013	81 7e 10 b1 79
	00 00		 cmp	 DWORD PTR [esi+16], 31153 ; 000079b1H
  0001a	75 ef		 jne	 SHORT $LN9@gzvprintf
  0001c	83 7e 5c 00	 cmp	 DWORD PTR [esi+92], 0
  00020	75 e9		 jne	 SHORT $LN9@gzvprintf

; 395  :         return Z_STREAM_ERROR;
; 396  : 
; 397  :     /* make sure we have some buffer space */
; 398  :     if (state->size == 0 && gz_init(state) == -1)

  00022	83 7e 1c 00	 cmp	 DWORD PTR [esi+28], 0
  00026	75 10		 jne	 SHORT $LN14@gzvprintf
  00028	e8 00 00 00 00	 call	 _gz_init
  0002d	83 f8 ff	 cmp	 eax, -1
  00030	75 06		 jne	 SHORT $LN14@gzvprintf
$LN17@gzvprintf:

; 399  :         return state->err;

  00032	8b 46 5c	 mov	 eax, DWORD PTR [esi+92]
  00035	5e		 pop	 esi

; 449  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
$LN14@gzvprintf:

; 400  : 
; 401  :     /* check for seek request */
; 402  :     if (state->seek) {

  00038	83 7e 58 00	 cmp	 DWORD PTR [esi+88], 0
  0003c	74 1c		 je	 SHORT $LN6@gzvprintf

; 403  :         state->seek = 0;
; 404  :         if (gz_zero(state, state->skip) == -1)

  0003e	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  00041	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  00044	50		 push	 eax
  00045	51		 push	 ecx
  00046	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
  0004d	e8 00 00 00 00	 call	 _gz_zero
  00052	83 c4 08	 add	 esp, 8
  00055	83 f8 ff	 cmp	 eax, -1

; 405  :             return state->err;

  00058	74 d8		 je	 SHORT $LN17@gzvprintf
$LN6@gzvprintf:

; 406  :     }
; 407  : 
; 408  :     /* do the printf() into the input buffer, put length in len -- the input
; 409  :        buffer is double-sized just for this function, so there is guaranteed to
; 410  :        be state->size bytes available after the current contents */
; 411  :     if (strm->avail_in == 0)

  0005a	8b 46 68	 mov	 eax, DWORD PTR [esi+104]
  0005d	85 c0		 test	 eax, eax
  0005f	75 06		 jne	 SHORT $LN5@gzvprintf

; 412  :         strm->next_in = state->in;

  00061	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  00064	89 56 64	 mov	 DWORD PTR [esi+100], edx
$LN5@gzvprintf:

; 413  :     next = (char *)(state->in + (strm->next_in - state->in) + strm->avail_in);
; 414  :     next[state->size - 1] = 0;
; 415  : #ifdef NO_vsnprintf
; 416  : #  ifdef HAS_vsprintf_void
; 417  :     (void)vsprintf(next, format, va);
; 418  :     for (len = 0; len < state->size; len++)
; 419  :         if (next[len] == 0) break;
; 420  : #  else
; 421  :     len = vsprintf(next, format, va);
; 422  : #  endif
; 423  : #else
; 424  : #  ifdef HAS_vsnprintf_void
; 425  :     (void)vsnprintf(next, state->size, format, va);
; 426  :     len = strlen(next);
; 427  : #  else
; 428  :     len = vsnprintf(next, state->size, format, va);

  00067	8b 4d 10	 mov	 ecx, DWORD PTR _va$[ebp]
  0006a	8b 55 0c	 mov	 edx, DWORD PTR _format$[ebp]
  0006d	53		 push	 ebx
  0006e	57		 push	 edi
  0006f	8b 7e 64	 mov	 edi, DWORD PTR [esi+100]
  00072	03 f8		 add	 edi, eax
  00074	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00077	51		 push	 ecx
  00078	c6 44 07 ff 00	 mov	 BYTE PTR [edi+eax-1], 0
  0007d	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00080	52		 push	 edx
  00081	50		 push	 eax
  00082	57		 push	 edi
  00083	e8 00 00 00 00	 call	 _vsnprintf
  00088	8b d8		 mov	 ebx, eax
  0008a	83 c4 10	 add	 esp, 16			; 00000010H

; 429  : #  endif
; 430  : #endif
; 431  : 
; 432  :     /* check that printf() results fit in buffer */
; 433  :     if (len == 0 || (unsigned)len >= state->size || next[state->size - 1] != 0)

  0008d	85 db		 test	 ebx, ebx
  0008f	74 67		 je	 SHORT $LN3@gzvprintf
  00091	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00094	3b d8		 cmp	 ebx, eax
  00096	73 60		 jae	 SHORT $LN3@gzvprintf
  00098	80 7c 38 ff 00	 cmp	 BYTE PTR [eax+edi-1], 0
  0009d	75 59		 jne	 SHORT $LN3@gzvprintf

; 435  : 
; 436  :     /* update buffer and position, compress first half if past that */
; 437  :     strm->avail_in += (unsigned)len;

  0009f	01 5e 68	 add	 DWORD PTR [esi+104], ebx

; 438  :     state->x.pos += len;
; 439  :     if (strm->avail_in >= state->size) {

  000a2	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  000a5	8b c3		 mov	 eax, ebx
  000a7	99		 cdq
  000a8	01 46 08	 add	 DWORD PTR [esi+8], eax
  000ab	11 56 0c	 adc	 DWORD PTR [esi+12], edx
  000ae	8b 46 68	 mov	 eax, DWORD PTR [esi+104]
  000b1	3b c1		 cmp	 eax, ecx
  000b3	72 3c		 jb	 SHORT $LN2@gzvprintf

; 440  :         left = strm->avail_in - state->size;

  000b5	2b c1		 sub	 eax, ecx
  000b7	8b f8		 mov	 edi, eax

; 441  :         strm->avail_in = state->size;
; 442  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  000b9	6a 00		 push	 0
  000bb	8b c6		 mov	 eax, esi
  000bd	89 4e 68	 mov	 DWORD PTR [esi+104], ecx
  000c0	e8 00 00 00 00	 call	 _gz_comp
  000c5	83 c4 04	 add	 esp, 4
  000c8	83 f8 ff	 cmp	 eax, -1
  000cb	75 08		 jne	 SHORT $LN1@gzvprintf

; 443  :             return state->err;

  000cd	8b 46 5c	 mov	 eax, DWORD PTR [esi+92]
  000d0	5f		 pop	 edi
  000d1	5b		 pop	 ebx
  000d2	5e		 pop	 esi

; 449  : }

  000d3	5d		 pop	 ebp
  000d4	c3		 ret	 0
$LN1@gzvprintf:

; 444  :         memcpy(state->in, state->in + state->size, left);

  000d5	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  000d8	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  000db	57		 push	 edi
  000dc	03 c8		 add	 ecx, eax
  000de	51		 push	 ecx
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 _memcpy

; 445  :         strm->next_in = state->in;

  000e5	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  000e8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000eb	89 56 64	 mov	 DWORD PTR [esi+100], edx

; 446  :         strm->avail_in = left;

  000ee	89 7e 68	 mov	 DWORD PTR [esi+104], edi
$LN2@gzvprintf:

; 447  :     }
; 448  :     return len;

  000f1	5f		 pop	 edi
  000f2	8b c3		 mov	 eax, ebx
  000f4	5b		 pop	 ebx
  000f5	5e		 pop	 esi

; 449  : }

  000f6	5d		 pop	 ebp
  000f7	c3		 ret	 0
$LN3@gzvprintf:
  000f8	5f		 pop	 edi
  000f9	5b		 pop	 ebx

; 434  :         return 0;

  000fa	33 c0		 xor	 eax, eax
  000fc	5e		 pop	 esi

; 449  : }

  000fd	5d		 pop	 ebp
  000fe	c3		 ret	 0
_gzvprintf ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _gz_write
_TEXT	SEGMENT
_put$ = -4						; size = 4
_buf$ = 8						; size = 4
_gz_write PROC						; COMDAT
; _state$ = ecx
; _len$ = eax

; 182  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b d8		 mov	 ebx, eax
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 183  :     z_size_t put = len;

  0000a	89 5d fc	 mov	 DWORD PTR _put$[ebp], ebx

; 184  : 
; 185  :     /* if len is zero, avoid unnecessary operations */
; 186  :     if (len == 0)

  0000d	85 db		 test	 ebx, ebx
  0000f	75 08		 jne	 SHORT $LN18@gz_write
$LN31@gz_write:
  00011	5e		 pop	 esi

; 187  :         return 0;

  00012	33 c0		 xor	 eax, eax
  00014	5b		 pop	 ebx

; 243  : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
$LN18@gz_write:

; 188  : 
; 189  :     /* allocate memory if this is the first time through */
; 190  :     if (state->size == 0 && gz_init(state) == -1)

  00019	83 7e 1c 00	 cmp	 DWORD PTR [esi+28], 0
  0001d	75 0a		 jne	 SHORT $LN26@gz_write
  0001f	e8 00 00 00 00	 call	 _gz_init
  00024	83 f8 ff	 cmp	 eax, -1

; 191  :         return 0;

  00027	74 e8		 je	 SHORT $LN31@gz_write
$LN26@gz_write:

; 192  : 
; 193  :     /* check for seek request */
; 194  :     if (state->seek) {

  00029	83 7e 58 00	 cmp	 DWORD PTR [esi+88], 0
  0002d	74 1c		 je	 SHORT $LN29@gz_write

; 195  :         state->seek = 0;
; 196  :         if (gz_zero(state, state->skip) == -1)

  0002f	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  00032	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  00035	50		 push	 eax
  00036	51		 push	 ecx
  00037	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
  0003e	e8 00 00 00 00	 call	 _gz_zero
  00043	83 c4 08	 add	 esp, 8
  00046	83 f8 ff	 cmp	 eax, -1

; 197  :             return 0;

  00049	74 c6		 je	 SHORT $LN31@gz_write
$LN29@gz_write:
  0004b	57		 push	 edi

; 198  :     }
; 199  : 
; 200  :     /* for small len, copy to input buffer, otherwise compress directly */
; 201  :     if (len < state->size) {

  0004c	3b 5e 1c	 cmp	 ebx, DWORD PTR [esi+28]
  0004f	73 5b		 jae	 SHORT $LN14@gz_write
$LL13@gz_write:

; 202  :         /* copy to input buffer, compress when full */
; 203  :         do {
; 204  :             unsigned have, copy;
; 205  : 
; 206  :             if (state->strm.avail_in == 0)

  00051	8b 46 68	 mov	 eax, DWORD PTR [esi+104]
  00054	85 c0		 test	 eax, eax
  00056	75 06		 jne	 SHORT $LN10@gz_write

; 207  :                 state->strm.next_in = state->in;

  00058	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  0005b	89 56 64	 mov	 DWORD PTR [esi+100], edx
$LN10@gz_write:

; 208  :             have = (unsigned)((state->strm.next_in + state->strm.avail_in) -
; 209  :                               state->in);

  0005e	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]

; 210  :             copy = state->size - have;

  00061	8b 7e 1c	 mov	 edi, DWORD PTR [esi+28]
  00064	2b c1		 sub	 eax, ecx
  00066	03 46 64	 add	 eax, DWORD PTR [esi+100]
  00069	2b f8		 sub	 edi, eax

; 211  :             if (copy > len)

  0006b	3b fb		 cmp	 edi, ebx
  0006d	76 02		 jbe	 SHORT $LN9@gz_write

; 212  :                 copy = len;

  0006f	8b fb		 mov	 edi, ebx
$LN9@gz_write:

; 213  :             memcpy(state->in + have, buf, copy);

  00071	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00074	57		 push	 edi
  00075	52		 push	 edx
  00076	03 c8		 add	 ecx, eax
  00078	51		 push	 ecx
  00079	e8 00 00 00 00	 call	 _memcpy

; 214  :             state->strm.avail_in += copy;

  0007e	01 7e 68	 add	 DWORD PTR [esi+104], edi
  00081	83 c4 0c	 add	 esp, 12			; 0000000cH

; 215  :             state->x.pos += copy;

  00084	01 7e 08	 add	 DWORD PTR [esi+8], edi
  00087	83 56 0c 00	 adc	 DWORD PTR [esi+12], 0

; 216  :             buf = (const char *)buf + copy;

  0008b	01 7d 08	 add	 DWORD PTR _buf$[ebp], edi

; 217  :             len -= copy;

  0008e	2b df		 sub	 ebx, edi

; 218  :             if (len && gz_comp(state, Z_NO_FLUSH) == -1)

  00090	74 67		 je	 SHORT $LN3@gz_write
  00092	6a 00		 push	 0
  00094	8b c6		 mov	 eax, esi
  00096	e8 00 00 00 00	 call	 _gz_comp
  0009b	83 c4 04	 add	 esp, 4
  0009e	83 f8 ff	 cmp	 eax, -1
  000a1	75 ae		 jne	 SHORT $LL13@gz_write
$LN25@gz_write:
  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi

; 219  :                 return 0;

  000a5	33 c0		 xor	 eax, eax
  000a7	5b		 pop	 ebx

; 243  : }

  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c3		 ret	 0
$LN14@gz_write:

; 220  :         } while (len);
; 221  :     }
; 222  :     else {
; 223  :         /* consume whatever's left in the input buffer */
; 224  :         if (state->strm.avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  000ac	83 7e 68 00	 cmp	 DWORD PTR [esi+104], 0
  000b0	74 11		 je	 SHORT $LN6@gz_write
  000b2	6a 00		 push	 0
  000b4	8b c6		 mov	 eax, esi
  000b6	e8 00 00 00 00	 call	 _gz_comp
  000bb	83 c4 04	 add	 esp, 4
  000be	83 f8 ff	 cmp	 eax, -1

; 225  :             return 0;

  000c1	74 e0		 je	 SHORT $LN25@gz_write
$LN6@gz_write:

; 226  : 
; 227  :         /* directly compress user buffer to file */
; 228  :         state->strm.next_in = (z_const Bytef *)buf;

  000c3	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  000c6	89 46 64	 mov	 DWORD PTR [esi+100], eax
  000c9	8d a4 24 00 00
	00 00		 npad	 7
$LL5@gz_write:

; 229  :         do {
; 230  :             unsigned n = (unsigned)-1;

  000d0	83 cf ff	 or	 edi, -1

; 231  :             if (n > len)

  000d3	83 fb ff	 cmp	 ebx, -1
  000d6	73 02		 jae	 SHORT $LN2@gz_write

; 232  :                 n = len;

  000d8	8b fb		 mov	 edi, ebx
$LN2@gz_write:

; 233  :             state->strm.avail_in = n;
; 234  :             state->x.pos += n;

  000da	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 235  :             if (gz_comp(state, Z_NO_FLUSH) == -1)

  000dd	6a 00		 push	 0
  000df	8b c6		 mov	 eax, esi
  000e1	83 56 0c 00	 adc	 DWORD PTR [esi+12], 0
  000e5	89 7e 68	 mov	 DWORD PTR [esi+104], edi
  000e8	e8 00 00 00 00	 call	 _gz_comp
  000ed	83 c4 04	 add	 esp, 4
  000f0	83 f8 ff	 cmp	 eax, -1
  000f3	74 ae		 je	 SHORT $LN25@gz_write

; 236  :                 return 0;
; 237  :             len -= n;

  000f5	2b df		 sub	 ebx, edi

; 238  :         } while (len);

  000f7	75 d7		 jne	 SHORT $LL5@gz_write
$LN3@gz_write:

; 239  :     }
; 240  : 
; 241  :     /* input was all buffered or compressed */
; 242  :     return put;

  000f9	8b 45 fc	 mov	 eax, DWORD PTR _put$[ebp]
  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	5b		 pop	 ebx

; 243  : }

  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c3		 ret	 0
_gz_write ENDP
PUBLIC	_gzprintf
; Function compile flags: /Ogtp
;	COMDAT _gzprintf
_TEXT	SEGMENT
_file$ = 8						; size = 4
_format$ = 12						; size = 4
_gzprintf PROC						; COMDAT

; 452  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 453  :     va_list va;
; 454  :     int ret;
; 455  : 
; 456  :     va_start(va, format);
; 457  :     ret = gzvprintf(file, format, va);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _format$[ebp]
  00006	8b 55 08	 mov	 edx, DWORD PTR _file$[ebp]
  00009	8d 45 10	 lea	 eax, DWORD PTR _format$[ebp+4]
  0000c	50		 push	 eax
  0000d	51		 push	 ecx
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 _gzvprintf
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 458  :     va_end(va);
; 459  :     return ret;
; 460  : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
_gzprintf ENDP
_TEXT	ENDS
PUBLIC	_gzputs
; Function compile flags: /Ogtp
;	COMDAT _gzputs
_TEXT	SEGMENT
_file$ = 8						; size = 4
_str$ = 12						; size = 4
_gzputs	PROC						; COMDAT

; 355  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 356  :     int ret;
; 357  :     z_size_t len;
; 358  :     gz_statep state;
; 359  : 
; 360  :     /* get internal structure */
; 361  :     if (file == NULL)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00006	85 c9		 test	 ecx, ecx

; 362  :         return -1;

  00008	74 3c		 je	 SHORT $LN1@gzputs

; 363  :     state = (gz_statep)file;
; 364  : 
; 365  :     /* check that we're writing and that there's no error */
; 366  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  0000a	81 79 10 b1 79
	00 00		 cmp	 DWORD PTR [ecx+16], 31153 ; 000079b1H
  00011	75 33		 jne	 SHORT $LN1@gzputs
  00013	83 79 5c 00	 cmp	 DWORD PTR [ecx+92], 0
  00017	75 2d		 jne	 SHORT $LN1@gzputs

; 368  : 
; 369  :     /* write string */
; 370  :     len = strlen(str);

  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	8b 7d 0c	 mov	 edi, DWORD PTR _str$[ebp]
  0001e	8b c7		 mov	 eax, edi
  00020	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$LL8@gzputs:
  00023	8a 10		 mov	 dl, BYTE PTR [eax]
  00025	40		 inc	 eax
  00026	84 d2		 test	 dl, dl
  00028	75 f9		 jne	 SHORT $LL8@gzputs
  0002a	2b c6		 sub	 eax, esi

; 371  :     ret = gz_write(state, str, len);

  0002c	57		 push	 edi
  0002d	8b f0		 mov	 esi, eax
  0002f	e8 00 00 00 00	 call	 _gz_write
  00034	83 c4 04	 add	 esp, 4

; 372  :     return ret == 0 && len != 0 ? -1 : ret;

  00037	85 c0		 test	 eax, eax
  00039	75 07		 jne	 SHORT $LN6@gzputs
  0003b	85 f6		 test	 esi, esi
  0003d	74 03		 je	 SHORT $LN6@gzputs
  0003f	83 c8 ff	 or	 eax, -1
$LN6@gzputs:
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi

; 373  : }

  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
$LN1@gzputs:

; 367  :         return -1;

  00046	83 c8 ff	 or	 eax, -1

; 373  : }

  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_gzputs	ENDP
_TEXT	ENDS
PUBLIC	_gzputc
; Function compile flags: /Ogtp
;	COMDAT _gzputc
_TEXT	SEGMENT
_file$ = 8						; size = 4
_buf$ = 11						; size = 1
_c$ = 12						; size = 4
_gzputc	PROC						; COMDAT

; 307  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 308  :     unsigned have;
; 309  :     unsigned char buf[1];
; 310  :     gz_statep state;
; 311  :     z_streamp strm;
; 312  : 
; 313  :     /* get internal structure */
; 314  :     if (file == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 06		 jne	 SHORT $LN9@gzputc
$LN13@gzputc:

; 315  :         return -1;

  0000b	83 c8 ff	 or	 eax, -1
  0000e	5e		 pop	 esi

; 349  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
$LN9@gzputc:

; 316  :     state = (gz_statep)file;
; 317  :     strm = &(state->strm);
; 318  : 
; 319  :     /* check that we're writing and that there's no error */
; 320  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00011	81 7e 10 b1 79
	00 00		 cmp	 DWORD PTR [esi+16], 31153 ; 000079b1H
  00018	75 f1		 jne	 SHORT $LN13@gzputc
  0001a	83 7e 5c 00	 cmp	 DWORD PTR [esi+92], 0
  0001e	75 eb		 jne	 SHORT $LN13@gzputc

; 321  :         return -1;
; 322  : 
; 323  :     /* check for seek request */
; 324  :     if (state->seek) {

  00020	83 7e 58 00	 cmp	 DWORD PTR [esi+88], 0
  00024	74 1c		 je	 SHORT $LN5@gzputc

; 325  :         state->seek = 0;
; 326  :         if (gz_zero(state, state->skip) == -1)

  00026	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  00029	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  0002c	50		 push	 eax
  0002d	51		 push	 ecx
  0002e	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
  00035	e8 00 00 00 00	 call	 _gz_zero
  0003a	83 c4 08	 add	 esp, 8
  0003d	83 f8 ff	 cmp	 eax, -1

; 327  :             return -1;

  00040	74 c9		 je	 SHORT $LN13@gzputc
$LN5@gzputc:

; 328  :     }
; 329  : 
; 330  :     /* try writing to input buffer for speed (state->size == 0 if buffer not
; 331  :        initialized) */
; 332  :     if (state->size) {

  00042	83 7e 1c 00	 cmp	 DWORD PTR [esi+28], 0
  00046	74 39		 je	 SHORT $LN2@gzputc

; 333  :         if (strm->avail_in == 0)

  00048	8b 46 68	 mov	 eax, DWORD PTR [esi+104]
  0004b	85 c0		 test	 eax, eax
  0004d	75 06		 jne	 SHORT $LN3@gzputc

; 334  :             strm->next_in = state->in;

  0004f	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  00052	89 56 64	 mov	 DWORD PTR [esi+100], edx
$LN3@gzputc:

; 335  :         have = (unsigned)((strm->next_in + strm->avail_in) - state->in);

  00055	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  00058	8b 4e 64	 mov	 ecx, DWORD PTR [esi+100]
  0005b	2b ca		 sub	 ecx, edx
  0005d	03 c8		 add	 ecx, eax

; 336  :         if (have < state->size) {

  0005f	3b 4e 1c	 cmp	 ecx, DWORD PTR [esi+28]
  00062	73 1d		 jae	 SHORT $LN2@gzputc

; 337  :             state->in[have] = (unsigned char)c;

  00064	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
  00067	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 338  :             strm->avail_in++;

  0006a	b9 01 00 00 00	 mov	 ecx, 1
  0006f	01 4e 68	 add	 DWORD PTR [esi+104], ecx

; 339  :             state->x.pos++;

  00072	01 4e 08	 add	 DWORD PTR [esi+8], ecx
  00075	83 56 0c 00	 adc	 DWORD PTR [esi+12], 0

; 340  :             return c & 0xff;

  00079	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0007e	5e		 pop	 esi

; 349  : }

  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
$LN2@gzputc:
  00081	53		 push	 ebx

; 341  :         }
; 342  :     }
; 343  : 
; 344  :     /* no room in buffer or not initialized, use gz_write() */
; 345  :     buf[0] = (unsigned char)c;

  00082	8b 5d 0c	 mov	 ebx, DWORD PTR _c$[ebp]

; 346  :     if (gz_write(state, buf, 1) != 1)

  00085	8d 45 0b	 lea	 eax, DWORD PTR _buf$[ebp]
  00088	50		 push	 eax
  00089	b8 01 00 00 00	 mov	 eax, 1
  0008e	8b ce		 mov	 ecx, esi
  00090	88 5d 0b	 mov	 BYTE PTR _buf$[ebp], bl
  00093	e8 00 00 00 00	 call	 _gz_write
  00098	83 c4 04	 add	 esp, 4
  0009b	83 f8 01	 cmp	 eax, 1
  0009e	74 07		 je	 SHORT $LN1@gzputc

; 347  :         return -1;

  000a0	5b		 pop	 ebx
  000a1	83 c8 ff	 or	 eax, -1
  000a4	5e		 pop	 esi

; 349  : }

  000a5	5d		 pop	 ebp
  000a6	c3		 ret	 0
$LN1@gzputc:

; 348  :     return c & 0xff;

  000a7	8b c3		 mov	 eax, ebx
  000a9	5b		 pop	 ebx
  000aa	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000af	5e		 pop	 esi

; 349  : }

  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
_gzputc	ENDP
_TEXT	ENDS
PUBLIC	_gzfwrite
; Function compile flags: /Ogtp
;	COMDAT _gzfwrite
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_size$ = 12						; size = 4
_nitems$ = 16						; size = 4
_file$ = 20						; size = 4
_gzfwrite PROC						; COMDAT

; 279  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  :     z_size_t len;
; 281  :     gz_statep state;
; 282  : 
; 283  :     /* get internal structure */
; 284  :     if (file == NULL)

  00003	8b 4d 14	 mov	 ecx, DWORD PTR _file$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	75 04		 jne	 SHORT $LN4@gzfwrite
$LN2@gzfwrite:

; 285  :         return 0;

  0000a	33 c0		 xor	 eax, eax

; 301  : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
$LN4@gzfwrite:

; 286  :     state = (gz_statep)file;
; 287  : 
; 288  :     /* check that we're writing and that there's no error */
; 289  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  0000e	81 79 10 b1 79
	00 00		 cmp	 DWORD PTR [ecx+16], 31153 ; 000079b1H
  00015	75 f3		 jne	 SHORT $LN2@gzfwrite
  00017	83 79 5c 00	 cmp	 DWORD PTR [ecx+92], 0
  0001b	75 ed		 jne	 SHORT $LN2@gzfwrite

; 290  :         return 0;
; 291  : 
; 292  :     /* compute bytes to read -- error on overflow */
; 293  :     len = nitems * size;

  0001d	53		 push	 ebx
  0001e	8b 5d 10	 mov	 ebx, DWORD PTR _nitems$[ebp]
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	8b 7d 0c	 mov	 edi, DWORD PTR _size$[ebp]
  00026	8b f7		 mov	 esi, edi
  00028	0f af f3	 imul	 esi, ebx

; 294  :     if (size && len / size != nitems) {

  0002b	85 ff		 test	 edi, edi
  0002d	74 20		 je	 SHORT $LN9@gzfwrite
  0002f	33 d2		 xor	 edx, edx
  00031	8b c6		 mov	 eax, esi
  00033	f7 f7		 div	 edi
  00035	3b c3		 cmp	 eax, ebx
  00037	74 16		 je	 SHORT $LN9@gzfwrite

; 295  :         gz_error(state, Z_STREAM_ERROR, "request does not fit in a size_t");

  00039	bb 00 00 00 00	 mov	 ebx, OFFSET ??_C@_0CB@EGGJDMIK@request?5does?5not?5fit?5in?5a?5size_t@
  0003e	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00043	e8 00 00 00 00	 call	 _gz_error
$LN7@gzfwrite:

; 296  :         return 0;

  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	33 c0		 xor	 eax, eax
  0004c	5b		 pop	 ebx

; 301  : }

  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
$LN9@gzfwrite:

; 297  :     }
; 298  : 
; 299  :     /* write len bytes to buf, return the number of full items written */
; 300  :     return len ? gz_write(state, buf, len) / size : 0;

  0004f	85 f6		 test	 esi, esi
  00051	74 f5		 je	 SHORT $LN7@gzfwrite
  00053	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00056	50		 push	 eax
  00057	8b c6		 mov	 eax, esi
  00059	e8 00 00 00 00	 call	 _gz_write
  0005e	83 c4 04	 add	 esp, 4
  00061	33 d2		 xor	 edx, edx
  00063	f7 f7		 div	 edi
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx

; 301  : }

  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
_gzfwrite ENDP
_TEXT	ENDS
PUBLIC	_gzwrite
; Function compile flags: /Ogtp
;	COMDAT _gzwrite
_TEXT	SEGMENT
_file$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_gzwrite PROC						; COMDAT

; 250  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 251  :     gz_statep state;
; 252  : 
; 253  :     /* get internal structure */
; 254  :     if (file == NULL)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00006	85 c9		 test	 ecx, ecx

; 255  :         return 0;

  00008	74 27		 je	 SHORT $LN2@gzwrite

; 256  :     state = (gz_statep)file;
; 257  : 
; 258  :     /* check that we're writing and that there's no error */
; 259  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  0000a	81 79 10 b1 79
	00 00		 cmp	 DWORD PTR [ecx+16], 31153 ; 000079b1H
  00011	75 1e		 jne	 SHORT $LN2@gzwrite
  00013	83 79 5c 00	 cmp	 DWORD PTR [ecx+92], 0
  00017	75 18		 jne	 SHORT $LN2@gzwrite

; 261  : 
; 262  :     /* since an int is returned, make sure len fits in one, otherwise return
; 263  :        with an error (this avoids a flaw in the interface) */
; 264  :     if ((int)len < 0) {

  00019	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  0001c	85 c0		 test	 eax, eax
  0001e	79 15		 jns	 SHORT $LN1@gzwrite

; 265  :         gz_error(state, Z_DATA_ERROR, "requested length does not fit in int");

  00020	53		 push	 ebx
  00021	bb 00 00 00 00	 mov	 ebx, OFFSET ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
  00026	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  0002b	e8 00 00 00 00	 call	 _gz_error
  00030	5b		 pop	 ebx
$LN2@gzwrite:

; 260  :         return 0;

  00031	33 c0		 xor	 eax, eax

; 271  : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
$LN1@gzwrite:

; 266  :         return 0;
; 267  :     }
; 268  : 
; 269  :     /* write len bytes from buf (the return value will fit in an int) */
; 270  :     return (int)gz_write(state, buf, len);

  00035	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 _gz_write
  0003e	83 c4 04	 add	 esp, 4

; 271  : }

  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
_gzwrite ENDP
END
