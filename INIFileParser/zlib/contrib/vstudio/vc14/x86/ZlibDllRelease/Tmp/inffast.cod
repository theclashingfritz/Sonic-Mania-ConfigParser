; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\theclashingfritz\source\repos\INIFileParser\zlib\inffast.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_inflate_fast
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\inffast.c
;	COMDAT _inflate_fast
_TEXT	SEGMENT
_lmask$ = -60						; size = 4
_whave$ = -56						; size = 4
_beg$ = -52						; size = 4
tv606 = -48						; size = 4
tv604 = -48						; size = 4
_op$ = -48						; size = 4
_dmask$ = -44						; size = 4
_end$ = -40						; size = 4
_wsize$ = -36						; size = 4
_dcode$ = -32						; size = 4
_lcode$ = -28						; size = 4
_wnext$ = -24						; size = 4
_window$ = -20						; size = 4
_state$ = -16						; size = 4
_last$ = -12						; size = 4
_dist$ = -8						; size = 4
_here$ = -8						; size = 4
_in$ = -4						; size = 4
_strm$ = 8						; size = 4
tv909 = 12						; size = 4
tv608 = 12						; size = 4
_len$ = 12						; size = 4
_start$ = 12						; size = 4
_inflate_fast PROC					; COMDAT

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 82   :     in = strm->next_in;

  00006	53		 push	 ebx

; 83   :     last = in + (strm->avail_in - 5);
; 84   :     out = strm->next_out;
; 85   :     beg = out - (start - strm->avail_out);
; 86   :     end = out + (strm->avail_out - 257);
; 87   : #ifdef INFLATE_STRICT
; 88   :     dmax = state->dmax;
; 89   : #endif
; 90   :     wsize = state->wsize;
; 91   :     whave = state->whave;
; 92   :     wnext = state->wnext;
; 93   :     window = state->window;
; 94   :     hold = state->hold;

  00007	56		 push	 esi

; 99   :     dmask = (1U << state->distbits) - 1;

  00008	57		 push	 edi

; 54   :     struct inflate_state FAR *state;
; 55   :     z_const unsigned char FAR *in;      /* local strm->next_in */
; 56   :     z_const unsigned char FAR *last;    /* have enough input while in < last */
; 57   :     unsigned char FAR *out;     /* local strm->next_out */
; 58   :     unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
; 59   :     unsigned char FAR *end;     /* while out < end, enough space available */
; 60   : #ifdef INFLATE_STRICT
; 61   :     unsigned dmax;              /* maximum distance from zlib header */
; 62   : #endif
; 63   :     unsigned wsize;             /* window size or zero if not using window */
; 64   :     unsigned whave;             /* valid bytes in the window */
; 65   :     unsigned wnext;             /* window write index */
; 66   :     unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
; 67   :     unsigned long hold;         /* local strm->hold */
; 68   :     unsigned bits;              /* local strm->bits */
; 69   :     code const FAR *lcode;      /* local strm->lencode */
; 70   :     code const FAR *dcode;      /* local strm->distcode */
; 71   :     unsigned lmask;             /* mask for first level of length codes */
; 72   :     unsigned dmask;             /* mask for first level of distance codes */
; 73   :     code here;                  /* retrieved table entry */
; 74   :     unsigned op;                /* code bits, operation, extra bits, or */
; 75   :                                 /*  window position, window bytes to copy */
; 76   :     unsigned len;               /* match length, unused bytes */
; 77   :     unsigned dist;              /* match distance */
; 78   :     unsigned char FAR *from;    /* where to copy match from */
; 79   : 
; 80   :     /* copy state to local variables */
; 81   :     state = (struct inflate_state FAR *)strm->state;

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0000c	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 82   :     in = strm->next_in;

  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	89 55 fc	 mov	 DWORD PTR _in$[ebp], edx

; 83   :     last = in + (strm->avail_in - 5);
; 84   :     out = strm->next_out;
; 85   :     beg = out - (start - strm->avail_out);
; 86   :     end = out + (strm->avail_out - 257);
; 87   : #ifdef INFLATE_STRICT
; 88   :     dmax = state->dmax;
; 89   : #endif
; 90   :     wsize = state->wsize;
; 91   :     whave = state->whave;
; 92   :     wnext = state->wnext;
; 93   :     window = state->window;
; 94   :     hold = state->hold;

  00014	8b 58 3c	 mov	 ebx, DWORD PTR [eax+60]
  00017	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0001a	8d 54 16 fb	 lea	 edx, DWORD PTR [esi+edx-5]
  0001e	8b 71 0c	 mov	 esi, DWORD PTR [ecx+12]
  00021	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00024	89 55 f4	 mov	 DWORD PTR _last$[ebp], edx
  00027	8b d1		 mov	 edx, ecx
  00029	2b 55 0c	 sub	 edx, DWORD PTR _start$[ebp]
  0002c	8d 8c 31 ff fe
	ff ff		 lea	 ecx, DWORD PTR [ecx+esi-257]
  00033	03 d6		 add	 edx, esi
  00035	89 55 cc	 mov	 DWORD PTR _beg$[ebp], edx
  00038	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  0003b	89 4d d8	 mov	 DWORD PTR _end$[ebp], ecx
  0003e	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00041	89 55 dc	 mov	 DWORD PTR _wsize$[ebp], edx
  00044	8b 50 34	 mov	 edx, DWORD PTR [eax+52]
  00047	89 4d c8	 mov	 DWORD PTR _whave$[ebp], ecx
  0004a	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0004d	89 55 e8	 mov	 DWORD PTR _wnext$[ebp], edx

; 95   :     bits = state->bits;
; 96   :     lcode = state->lencode;

  00050	8b 50 50	 mov	 edx, DWORD PTR [eax+80]
  00053	89 4d ec	 mov	 DWORD PTR _window$[ebp], ecx

; 97   :     dcode = state->distcode;

  00056	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00059	89 55 e4	 mov	 DWORD PTR _lcode$[ebp], edx
  0005c	89 4d e0	 mov	 DWORD PTR _dcode$[ebp], ecx

; 98   :     lmask = (1U << state->lenbits) - 1;

  0005f	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  00062	ba 01 00 00 00	 mov	 edx, 1
  00067	d3 e2		 shl	 edx, cl

; 99   :     dmask = (1U << state->distbits) - 1;

  00069	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  0006c	89 45 f0	 mov	 DWORD PTR _state$[ebp], eax
  0006f	8b 78 40	 mov	 edi, DWORD PTR [eax+64]
  00072	c7 45 0c 01 00
	00 00		 mov	 DWORD PTR tv909[ebp], 1
  00079	8b 45 0c	 mov	 eax, DWORD PTR tv909[ebp]
  0007c	d3 e0		 shl	 eax, cl
  0007e	4a		 dec	 edx
  0007f	89 55 c4	 mov	 DWORD PTR _lmask$[ebp], edx
  00082	48		 dec	 eax
  00083	89 45 d4	 mov	 DWORD PTR _dmask$[ebp], eax
$LL55@inflate_fa:

; 100  : 
; 101  :     /* decode literals and length/distances until end-of-block or not enough
; 102  :        input data or output space */
; 103  :     do {
; 104  :         if (bits < 15) {

  00086	83 ff 0f	 cmp	 edi, 15			; 0000000fH
  00089	73 23		 jae	 SHORT $LN52@inflate_fa

; 105  :             hold += (unsigned long)(*in++) << bits;

  0008b	8b 45 fc	 mov	 eax, DWORD PTR _in$[ebp]
  0008e	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00091	8b cf		 mov	 ecx, edi
  00093	d3 e0		 shl	 eax, cl

; 106  :             bits += 8;
; 107  :             hold += (unsigned long)(*in++) << bits;

  00095	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00098	03 d8		 add	 ebx, eax
  0009a	8b 45 fc	 mov	 eax, DWORD PTR _in$[ebp]
  0009d	40		 inc	 eax
  0009e	89 45 fc	 mov	 DWORD PTR _in$[ebp], eax
  000a1	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  000a4	ff 45 fc	 inc	 DWORD PTR _in$[ebp]
  000a7	d3 e0		 shl	 eax, cl
  000a9	03 d8		 add	 ebx, eax

; 108  :             bits += 8;

  000ab	83 c7 10	 add	 edi, 16			; 00000010H
$LN52@inflate_fa:

; 109  :         }
; 110  :         here = lcode[hold & lmask];

  000ae	8b 4d e4	 mov	 ecx, DWORD PTR _lcode$[ebp]
  000b1	23 d3		 and	 edx, ebx
  000b3	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]

; 111  :       dolen:
; 112  :         op = (unsigned)(here.bits);

  000b6	8b d0		 mov	 edx, eax
  000b8	c1 ea 08	 shr	 edx, 8
  000bb	0f b6 ca	 movzx	 ecx, dl

; 113  :         hold >>= op;

  000be	d3 eb		 shr	 ebx, cl

; 114  :         bits -= op;

  000c0	2b f9		 sub	 edi, ecx

; 115  :         op = (unsigned)(here.op);

  000c2	0f b6 d0	 movzx	 edx, al

; 116  :         if (op == 0) {                          /* literal */

  000c5	84 c0		 test	 al, al
  000c7	74 3f		 je	 SHORT $LN72@inflate_fa
  000c9	8d a4 24 00 00
	00 00		 npad	 7
$dolen$3809:

; 121  :         }
; 122  :         else if (op & 16) {                     /* length base */

  000d0	f6 c2 10	 test	 dl, 16			; 00000010H
  000d3	75 3b		 jne	 SHORT $LN73@inflate_fa

; 274  :             }
; 275  :         }
; 276  :         else if ((op & 64) == 0) {              /* 2nd level length code */

  000d5	f6 c2 40	 test	 dl, 64			; 00000040H
  000d8	0f 85 89 02 00
	00		 jne	 $LN5@inflate_fa

; 277  :             here = lcode[here.val + (hold & ((1U << op) - 1))];

  000de	8b ca		 mov	 ecx, edx
  000e0	ba 01 00 00 00	 mov	 edx, 1
  000e5	d3 e2		 shl	 edx, cl
  000e7	c1 e8 10	 shr	 eax, 16			; 00000010H
  000ea	4a		 dec	 edx
  000eb	23 d3		 and	 edx, ebx
  000ed	03 d0		 add	 edx, eax
  000ef	8b 45 e4	 mov	 eax, DWORD PTR _lcode$[ebp]
  000f2	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  000f5	8b c8		 mov	 ecx, eax
  000f7	c1 e9 08	 shr	 ecx, 8
  000fa	0f b6 c9	 movzx	 ecx, cl
  000fd	d3 eb		 shr	 ebx, cl
  000ff	2b f9		 sub	 edi, ecx
  00101	0f b6 d0	 movzx	 edx, al
  00104	84 c0		 test	 al, al
  00106	75 c8		 jne	 SHORT $dolen$3809
$LN72@inflate_fa:

; 117  :             Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 118  :                     "inflate:         literal '%c'\n" :
; 119  :                     "inflate:         literal 0x%02x\n", here.val));
; 120  :             *out++ = (unsigned char)(here.val);

  00108	c1 e8 10	 shr	 eax, 16			; 00000010H
  0010b	e9 27 02 00 00	 jmp	 $LN86@inflate_fa
$LN73@inflate_fa:

; 123  :             len = (unsigned)(here.val);

  00110	c1 e8 10	 shr	 eax, 16			; 00000010H

; 124  :             op &= 15;                           /* number of extra bits */

  00113	83 e2 0f	 and	 edx, 15			; 0000000fH
  00116	89 45 0c	 mov	 DWORD PTR _len$[ebp], eax

; 125  :             if (op) {

  00119	74 29		 je	 SHORT $LN48@inflate_fa

; 126  :                 if (bits < op) {

  0011b	3b fa		 cmp	 edi, edx
  0011d	73 12		 jae	 SHORT $LN79@inflate_fa

; 127  :                     hold += (unsigned long)(*in++) << bits;

  0011f	8b 45 fc	 mov	 eax, DWORD PTR _in$[ebp]
  00122	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00125	ff 45 fc	 inc	 DWORD PTR _in$[ebp]
  00128	8b cf		 mov	 ecx, edi
  0012a	d3 e0		 shl	 eax, cl
  0012c	03 d8		 add	 ebx, eax

; 128  :                     bits += 8;

  0012e	83 c7 08	 add	 edi, 8
$LN79@inflate_fa:

; 129  :                 }
; 130  :                 len += (unsigned)hold & ((1U << op) - 1);

  00131	8b ca		 mov	 ecx, edx
  00133	b8 01 00 00 00	 mov	 eax, 1
  00138	d3 e0		 shl	 eax, cl
  0013a	48		 dec	 eax
  0013b	23 c3		 and	 eax, ebx
  0013d	01 45 0c	 add	 DWORD PTR _len$[ebp], eax

; 131  :                 hold >>= op;

  00140	d3 eb		 shr	 ebx, cl

; 132  :                 bits -= op;

  00142	2b fa		 sub	 edi, edx
$LN48@inflate_fa:

; 133  :             }
; 134  :             Tracevv((stderr, "inflate:         length %u\n", len));
; 135  :             if (bits < 15) {

  00144	83 ff 0f	 cmp	 edi, 15			; 0000000fH
  00147	73 20		 jae	 SHORT $LN46@inflate_fa

; 136  :                 hold += (unsigned long)(*in++) << bits;

  00149	8b 45 fc	 mov	 eax, DWORD PTR _in$[ebp]
  0014c	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  0014f	8b cf		 mov	 ecx, edi
  00151	d3 e2		 shl	 edx, cl

; 137  :                 bits += 8;
; 138  :                 hold += (unsigned long)(*in++) << bits;

  00153	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00156	83 c0 02	 add	 eax, 2
  00159	89 45 fc	 mov	 DWORD PTR _in$[ebp], eax
  0015c	03 da		 add	 ebx, edx
  0015e	0f b6 50 ff	 movzx	 edx, BYTE PTR [eax-1]
  00162	d3 e2		 shl	 edx, cl
  00164	03 da		 add	 ebx, edx

; 139  :                 bits += 8;

  00166	83 c7 10	 add	 edi, 16			; 00000010H
$LN46@inflate_fa:

; 140  :             }
; 141  :             here = dcode[hold & dmask];

  00169	8b 45 d4	 mov	 eax, DWORD PTR _dmask$[ebp]
  0016c	8b 4d e0	 mov	 ecx, DWORD PTR _dcode$[ebp]
  0016f	23 c3		 and	 eax, ebx
  00171	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]

; 142  :           dodist:
; 143  :             op = (unsigned)(here.bits);

  00174	8b c2		 mov	 eax, edx
  00176	c1 e8 08	 shr	 eax, 8
  00179	0f b6 c8	 movzx	 ecx, al

; 144  :             hold >>= op;
; 145  :             bits -= op;
; 146  :             op = (unsigned)(here.op);

  0017c	0f b6 c2	 movzx	 eax, dl
  0017f	d3 eb		 shr	 ebx, cl
  00181	2b f9		 sub	 edi, ecx
  00183	89 55 f8	 mov	 DWORD PTR _here$[ebp], edx

; 147  :             if (op & 16) {                      /* distance base */

  00186	a8 10		 test	 al, 16			; 00000010H
  00188	75 3c		 jne	 SHORT $LN74@inflate_fa
  0018a	8d 9b 00 00 00
	00		 npad	 6
$dodist$3824:

; 263  :                     }
; 264  :                 }
; 265  :             }
; 266  :             else if ((op & 64) == 0) {          /* 2nd level distance code */

  00190	a8 40		 test	 al, 64			; 00000040H
  00192	0f 85 c3 01 00
	00		 jne	 $LN8@inflate_fa

; 267  :                 here = dcode[here.val + (hold & ((1U << op) - 1))];

  00198	8b c8		 mov	 ecx, eax
  0019a	0f b7 45 fa	 movzx	 eax, WORD PTR _here$[ebp+2]
  0019e	ba 01 00 00 00	 mov	 edx, 1
  001a3	d3 e2		 shl	 edx, cl
  001a5	8b 4d e0	 mov	 ecx, DWORD PTR _dcode$[ebp]
  001a8	4a		 dec	 edx
  001a9	23 d3		 and	 edx, ebx
  001ab	03 d0		 add	 edx, eax
  001ad	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  001b0	8b c2		 mov	 eax, edx
  001b2	c1 e8 08	 shr	 eax, 8
  001b5	0f b6 c8	 movzx	 ecx, al
  001b8	0f b6 c2	 movzx	 eax, dl
  001bb	d3 eb		 shr	 ebx, cl
  001bd	2b f9		 sub	 edi, ecx
  001bf	89 55 f8	 mov	 DWORD PTR _here$[ebp], edx
  001c2	a8 10		 test	 al, 16			; 00000010H
  001c4	74 ca		 je	 SHORT $dodist$3824
$LN74@inflate_fa:

; 148  :                 dist = (unsigned)(here.val);

  001c6	c1 ea 10	 shr	 edx, 16			; 00000010H

; 149  :                 op &= 15;                       /* number of extra bits */

  001c9	83 e0 0f	 and	 eax, 15			; 0000000fH
  001cc	89 55 f8	 mov	 DWORD PTR _dist$[ebp], edx

; 150  :                 if (bits < op) {

  001cf	3b f8		 cmp	 edi, eax
  001d1	73 28		 jae	 SHORT $LN80@inflate_fa

; 151  :                     hold += (unsigned long)(*in++) << bits;

  001d3	8b 4d fc	 mov	 ecx, DWORD PTR _in$[ebp]
  001d6	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  001d9	ff 45 fc	 inc	 DWORD PTR _in$[ebp]
  001dc	8b cf		 mov	 ecx, edi
  001de	d3 e2		 shl	 edx, cl

; 152  :                     bits += 8;

  001e0	83 c7 08	 add	 edi, 8
  001e3	03 da		 add	 ebx, edx

; 153  :                     if (bits < op) {

  001e5	3b f8		 cmp	 edi, eax
  001e7	73 12		 jae	 SHORT $LN80@inflate_fa

; 154  :                         hold += (unsigned long)(*in++) << bits;

  001e9	8b 4d fc	 mov	 ecx, DWORD PTR _in$[ebp]
  001ec	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  001ef	ff 45 fc	 inc	 DWORD PTR _in$[ebp]
  001f2	8b cf		 mov	 ecx, edi
  001f4	d3 e2		 shl	 edx, cl
  001f6	03 da		 add	 ebx, edx

; 155  :                         bits += 8;

  001f8	83 c7 08	 add	 edi, 8
$LN80@inflate_fa:

; 156  :                     }
; 157  :                 }
; 158  :                 dist += (unsigned)hold & ((1U << op) - 1);

  001fb	ba 01 00 00 00	 mov	 edx, 1
  00200	8b c8		 mov	 ecx, eax
  00202	d3 e2		 shl	 edx, cl

; 159  : #ifdef INFLATE_STRICT
; 160  :                 if (dist > dmax) {
; 161  :                     strm->msg = (char *)"invalid distance too far back";
; 162  :                     state->mode = BAD;
; 163  :                     break;
; 164  :                 }
; 165  : #endif
; 166  :                 hold >>= op;
; 167  :                 bits -= op;

  00204	2b f8		 sub	 edi, eax
  00206	4a		 dec	 edx
  00207	23 d3		 and	 edx, ebx
  00209	d3 eb		 shr	 ebx, cl
  0020b	89 55 d0	 mov	 DWORD PTR tv604[ebp], edx
  0020e	8b 55 f8	 mov	 edx, DWORD PTR _dist$[ebp]
  00211	03 55 d0	 add	 edx, DWORD PTR tv604[ebp]

; 168  :                 Tracevv((stderr, "inflate:         distance %u\n", dist));
; 169  :                 op = (unsigned)(out - beg);     /* max distance in output */

  00214	8b ce		 mov	 ecx, esi
  00216	2b 4d cc	 sub	 ecx, DWORD PTR _beg$[ebp]
  00219	89 55 f8	 mov	 DWORD PTR _dist$[ebp], edx

; 170  :                 if (dist > op) {                /* see if copy from window */

  0021c	3b d1		 cmp	 edx, ecx
  0021e	0f 86 d8 00 00
	00		 jbe	 $LN42@inflate_fa

; 171  :                     op = dist - op;             /* distance back in window */

  00224	8b c2		 mov	 eax, edx
  00226	2b c1		 sub	 eax, ecx

; 172  :                     if (op > whave) {

  00228	3b 45 c8	 cmp	 eax, DWORD PTR _whave$[ebp]
  0022b	76 10		 jbe	 SHORT $LN81@inflate_fa

; 173  :                         if (state->sane) {

  0022d	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00230	83 b9 c4 1b 00
	00 00		 cmp	 DWORD PTR [ecx+7108], 0
  00237	0f 85 12 01 00
	00		 jne	 $LN75@inflate_fa
$LN81@inflate_fa:

; 178  :                         }
; 179  : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 180  :                         if (len <= op - whave) {
; 181  :                             do {
; 182  :                                 *out++ = 0;
; 183  :                             } while (--len);
; 184  :                             continue;
; 185  :                         }
; 186  :                         len -= op - whave;
; 187  :                         do {
; 188  :                             *out++ = 0;
; 189  :                         } while (--op > whave);
; 190  :                         if (op == 0) {
; 191  :                             from = out - dist;
; 192  :                             do {
; 193  :                                 *out++ = *from++;
; 194  :                             } while (--len);
; 195  :                             continue;
; 196  :                         }
; 197  : #endif
; 198  :                     }
; 199  :                     from = window;
; 200  :                     if (wnext == 0) {           /* very common case */
; 201  :                         from += wsize - op;

  0023d	8b 4d ec	 mov	 ecx, DWORD PTR _window$[ebp]
  00240	8b 55 e8	 mov	 edx, DWORD PTR _wnext$[ebp]
  00243	2b c8		 sub	 ecx, eax
  00245	85 d2		 test	 edx, edx
  00247	75 16		 jne	 SHORT $LN39@inflate_fa
  00249	03 4d dc	 add	 ecx, DWORD PTR _wsize$[ebp]

; 202  :                         if (op < len) {         /* some from window */

  0024c	3b 45 0c	 cmp	 eax, DWORD PTR _len$[ebp]
  0024f	73 60		 jae	 SHORT $LN82@inflate_fa

; 203  :                             len -= op;

  00251	29 45 0c	 sub	 DWORD PTR _len$[ebp], eax
$LL37@inflate_fa:

; 204  :                             do {
; 205  :                                 *out++ = *from++;

  00254	8a 11		 mov	 dl, BYTE PTR [ecx]
  00256	88 16		 mov	 BYTE PTR [esi], dl
  00258	46		 inc	 esi
  00259	41		 inc	 ecx

; 206  :                             } while (--op);

  0025a	48		 dec	 eax
  0025b	75 f7		 jne	 SHORT $LL37@inflate_fa

; 207  :                             from = out - dist;  /* rest from output */
; 208  :                         }

  0025d	eb 4d		 jmp	 SHORT $LN87@inflate_fa
$LN39@inflate_fa:

; 209  :                     }
; 210  :                     else if (wnext < op) {      /* wrap around window */
; 211  :                         from += wsize + wnext - op;

  0025f	03 ca		 add	 ecx, edx
  00261	3b d0		 cmp	 edx, eax
  00263	73 36		 jae	 SHORT $LN33@inflate_fa
  00265	03 4d dc	 add	 ecx, DWORD PTR _wsize$[ebp]

; 212  :                         op -= wnext;

  00268	2b c2		 sub	 eax, edx

; 213  :                         if (op < len) {         /* some from end of window */

  0026a	3b 45 0c	 cmp	 eax, DWORD PTR _len$[ebp]
  0026d	73 42		 jae	 SHORT $LN82@inflate_fa

; 214  :                             len -= op;

  0026f	29 45 0c	 sub	 DWORD PTR _len$[ebp], eax

; 217  :                             } while (--op);

  00272	2b ce		 sub	 ecx, esi
$LL31@inflate_fa:

; 215  :                             do {
; 216  :                                 *out++ = *from++;

  00274	8a 14 31	 mov	 dl, BYTE PTR [ecx+esi]
  00277	88 16		 mov	 BYTE PTR [esi], dl
  00279	46		 inc	 esi

; 217  :                             } while (--op);

  0027a	48		 dec	 eax
  0027b	75 f7		 jne	 SHORT $LL31@inflate_fa

; 218  :                             from = window;
; 219  :                             if (wnext < len) {  /* some from start of window */

  0027d	8b 45 e8	 mov	 eax, DWORD PTR _wnext$[ebp]
  00280	8b 4d ec	 mov	 ecx, DWORD PTR _window$[ebp]
  00283	3b 45 0c	 cmp	 eax, DWORD PTR _len$[ebp]
  00286	73 29		 jae	 SHORT $LN82@inflate_fa

; 220  :                                 op = wnext;
; 221  :                                 len -= op;

  00288	29 45 0c	 sub	 DWORD PTR _len$[ebp], eax
  0028b	89 45 d0	 mov	 DWORD PTR _op$[ebp], eax
  0028e	8b ff		 npad	 2
$LL27@inflate_fa:

; 222  :                                 do {
; 223  :                                     *out++ = *from++;

  00290	8a 11		 mov	 dl, BYTE PTR [ecx]
  00292	88 16		 mov	 BYTE PTR [esi], dl
  00294	46		 inc	 esi
  00295	41		 inc	 ecx

; 224  :                                 } while (--op);

  00296	48		 dec	 eax
  00297	75 f7		 jne	 SHORT $LL27@inflate_fa

; 225  :                                 from = out - dist;      /* rest from output */
; 226  :                             }
; 227  :                         }
; 228  :                     }
; 229  :                     else {                      /* contiguous in window */

  00299	eb 11		 jmp	 SHORT $LN87@inflate_fa
$LN33@inflate_fa:

; 230  :                         from += wnext - op;
; 231  :                         if (op < len) {         /* some from window */

  0029b	3b 45 0c	 cmp	 eax, DWORD PTR _len$[ebp]
  0029e	73 11		 jae	 SHORT $LN82@inflate_fa

; 232  :                             len -= op;

  002a0	29 45 0c	 sub	 DWORD PTR _len$[ebp], eax
$LL22@inflate_fa:

; 233  :                             do {
; 234  :                                 *out++ = *from++;

  002a3	8a 11		 mov	 dl, BYTE PTR [ecx]
  002a5	88 16		 mov	 BYTE PTR [esi], dl
  002a7	46		 inc	 esi
  002a8	41		 inc	 ecx

; 235  :                             } while (--op);

  002a9	48		 dec	 eax
  002aa	75 f7		 jne	 SHORT $LL22@inflate_fa
$LN87@inflate_fa:

; 236  :                             from = out - dist;  /* rest from output */

  002ac	8b ce		 mov	 ecx, esi
  002ae	2b 4d f8	 sub	 ecx, DWORD PTR _dist$[ebp]
$LN82@inflate_fa:

; 237  :                         }
; 238  :                     }
; 239  :                     while (len > 2) {

  002b1	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  002b4	83 f8 02	 cmp	 eax, 2
  002b7	76 2d		 jbe	 SHORT $LN18@inflate_fa
  002b9	8d 50 fd	 lea	 edx, DWORD PTR [eax-3]
  002bc	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  002c1	f7 e2		 mul	 edx
  002c3	d1 ea		 shr	 edx, 1
  002c5	42		 inc	 edx
$LL19@inflate_fa:

; 240  :                         *out++ = *from++;

  002c6	0f b6 01	 movzx	 eax, BYTE PTR [ecx]

; 241  :                         *out++ = *from++;
; 242  :                         *out++ = *from++;
; 243  :                         len -= 3;

  002c9	83 6d 0c 03	 sub	 DWORD PTR _len$[ebp], 3
  002cd	88 06		 mov	 BYTE PTR [esi], al
  002cf	0f b6 41 01	 movzx	 eax, BYTE PTR [ecx+1]
  002d3	88 46 01	 mov	 BYTE PTR [esi+1], al
  002d6	0f b6 41 02	 movzx	 eax, BYTE PTR [ecx+2]
  002da	88 46 02	 mov	 BYTE PTR [esi+2], al
  002dd	83 c6 03	 add	 esi, 3
  002e0	83 c1 03	 add	 ecx, 3
  002e3	4a		 dec	 edx
  002e4	75 e0		 jne	 SHORT $LL19@inflate_fa
$LN18@inflate_fa:

; 244  :                     }
; 245  :                     if (len) {

  002e6	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  002e9	85 c0		 test	 eax, eax
  002eb	74 4d		 je	 SHORT $LN54@inflate_fa

; 246  :                         *out++ = *from++;

  002ed	8a 11		 mov	 dl, BYTE PTR [ecx]
  002ef	88 16		 mov	 BYTE PTR [esi], dl
  002f1	46		 inc	 esi

; 247  :                         if (len > 1)

  002f2	83 f8 01	 cmp	 eax, 1
  002f5	76 43		 jbe	 SHORT $LN54@inflate_fa

; 248  :                             *out++ = *from++;

  002f7	8a 41 01	 mov	 al, BYTE PTR [ecx+1]

; 249  :                     }
; 250  :                 }
; 251  :                 else {

  002fa	eb 3b		 jmp	 SHORT $LN86@inflate_fa
$LN42@inflate_fa:

; 252  :                     from = out - dist;          /* copy direct from output */

  002fc	8b c6		 mov	 eax, esi
  002fe	2b c2		 sub	 eax, edx
$LL14@inflate_fa:

; 253  :                     do {                        /* minimum length is three */
; 254  :                         *out++ = *from++;

  00300	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00303	88 0e		 mov	 BYTE PTR [esi], cl

; 255  :                         *out++ = *from++;

  00305	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00308	88 56 01	 mov	 BYTE PTR [esi+1], dl

; 256  :                         *out++ = *from++;

  0030b	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  0030f	88 4e 02	 mov	 BYTE PTR [esi+2], cl

; 257  :                         len -= 3;

  00312	8b 4d 0c	 mov	 ecx, DWORD PTR _len$[ebp]
  00315	83 e9 03	 sub	 ecx, 3
  00318	83 c6 03	 add	 esi, 3
  0031b	83 c0 03	 add	 eax, 3
  0031e	89 4d 0c	 mov	 DWORD PTR _len$[ebp], ecx

; 258  :                     } while (len > 2);

  00321	83 f9 02	 cmp	 ecx, 2
  00324	77 da		 ja	 SHORT $LL14@inflate_fa

; 259  :                     if (len) {

  00326	85 c9		 test	 ecx, ecx
  00328	74 10		 je	 SHORT $LN54@inflate_fa

; 260  :                         *out++ = *from++;

  0032a	8a 10		 mov	 dl, BYTE PTR [eax]
  0032c	88 16		 mov	 BYTE PTR [esi], dl
  0032e	46		 inc	 esi

; 261  :                         if (len > 1)

  0032f	83 f9 01	 cmp	 ecx, 1
  00332	76 06		 jbe	 SHORT $LN54@inflate_fa

; 262  :                             *out++ = *from++;

  00334	8a 40 01	 mov	 al, BYTE PTR [eax+1]
$LN86@inflate_fa:
  00337	88 06		 mov	 BYTE PTR [esi], al
  00339	46		 inc	 esi
$LN54@inflate_fa:

; 288  :             break;
; 289  :         }
; 290  :     } while (in < last && out < end);

  0033a	8b 55 f4	 mov	 edx, DWORD PTR _last$[ebp]
  0033d	39 55 fc	 cmp	 DWORD PTR _in$[ebp], edx
  00340	73 4d		 jae	 SHORT $LN53@inflate_fa
  00342	3b 75 d8	 cmp	 esi, DWORD PTR _end$[ebp]
  00345	73 48		 jae	 SHORT $LN53@inflate_fa

; 302  :     strm->avail_out = (unsigned)(out < end ?
; 303  :                                  257 + (end - out) : 257 - (out - end));

  00347	8b 55 c4	 mov	 edx, DWORD PTR _lmask$[ebp]
  0034a	e9 37 fd ff ff	 jmp	 $LL55@inflate_fa
$LN75@inflate_fa:

; 174  :                             strm->msg =
; 175  :                                 (char *)"invalid distance too far back";

  0034f	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00352	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@

; 176  :                             state->mode = BAD;
; 177  :                             break;

  00359	eb 2a		 jmp	 SHORT $LN88@inflate_fa
$LN8@inflate_fa:

; 268  :                 goto dodist;
; 269  :             }
; 270  :             else {
; 271  :                 strm->msg = (char *)"invalid distance code";

  0035b	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0035e	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@

; 272  :                 state->mode = BAD;
; 273  :                 break;

  00365	eb 1b		 jmp	 SHORT $LN89@inflate_fa
$LN5@inflate_fa:

; 278  :             goto dolen;
; 279  :         }
; 280  :         else if (op & 32) {                     /* end-of-block */

  00367	f6 c2 20	 test	 dl, 32			; 00000020H
  0036a	74 0c		 je	 SHORT $LN3@inflate_fa

; 281  :             Tracevv((stderr, "inflate:         end of block\n"));
; 282  :             state->mode = TYPE;

  0036c	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0036f	c7 42 04 3f 3f
	00 00		 mov	 DWORD PTR [edx+4], 16191 ; 00003f3fH

; 283  :             break;

  00376	eb 14		 jmp	 SHORT $LN90@inflate_fa
$LN3@inflate_fa:

; 284  :         }
; 285  :         else {
; 286  :             strm->msg = (char *)"invalid literal/length code";

  00378	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0037b	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
$LN89@inflate_fa:

; 287  :             state->mode = BAD;

  00382	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
$LN88@inflate_fa:
  00385	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
$LN90@inflate_fa:
  0038c	8b 55 f4	 mov	 edx, DWORD PTR _last$[ebp]
$LN53@inflate_fa:

; 291  : 
; 292  :     /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
; 293  :     len = bits >> 3;

  0038f	8b c7		 mov	 eax, edi
  00391	c1 e8 03	 shr	 eax, 3

; 294  :     in -= len;

  00394	29 45 fc	 sub	 DWORD PTR _in$[ebp], eax

; 295  :     bits -= len << 3;

  00397	03 c0		 add	 eax, eax
  00399	03 c0		 add	 eax, eax
  0039b	03 c0		 add	 eax, eax
  0039d	2b f8		 sub	 edi, eax

; 296  :     hold &= (1U << bits) - 1;

  0039f	8b cf		 mov	 ecx, edi
  003a1	b8 01 00 00 00	 mov	 eax, 1
  003a6	d3 e0		 shl	 eax, cl

; 297  : 
; 298  :     /* update state and return */
; 299  :     strm->next_in = in;

  003a8	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]

; 300  :     strm->next_out = out;

  003ab	89 71 0c	 mov	 DWORD PTR [ecx+12], esi
  003ae	48		 dec	 eax
  003af	23 d8		 and	 ebx, eax
  003b1	8b 45 fc	 mov	 eax, DWORD PTR _in$[ebp]
  003b4	89 01		 mov	 DWORD PTR [ecx], eax

; 301  :     strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));

  003b6	2b d0		 sub	 edx, eax

; 302  :     strm->avail_out = (unsigned)(out < end ?
; 303  :                                  257 + (end - out) : 257 - (out - end));

  003b8	8b 45 d8	 mov	 eax, DWORD PTR _end$[ebp]
  003bb	2b c6		 sub	 eax, esi
  003bd	83 c2 05	 add	 edx, 5
  003c0	05 01 01 00 00	 add	 eax, 257		; 00000101H
  003c5	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 304  :     state->hold = hold;

  003c8	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  003cb	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 305  :     state->bits = bits;

  003ce	89 78 40	 mov	 DWORD PTR [eax+64], edi
  003d1	5f		 pop	 edi
  003d2	5e		 pop	 esi
  003d3	89 58 3c	 mov	 DWORD PTR [eax+60], ebx
  003d6	5b		 pop	 ebx

; 306  :     return;
; 307  : }

  003d7	8b e5		 mov	 esp, ebp
  003d9	5d		 pop	 ebp
  003da	c3		 ret	 0
_inflate_fast ENDP
END
