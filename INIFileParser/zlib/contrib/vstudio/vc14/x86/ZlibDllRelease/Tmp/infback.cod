; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\theclashingfritz\source\repos\INIFileParser\zlib\infback.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@	; `string'
PUBLIC	??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ ; `string'
PUBLIC	??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ ; `string'
PUBLIC	??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ ; `string'
PUBLIC	??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ ; `string'
PUBLIC	??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@	; `string'
PUBLIC	??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ ; `string'
PUBLIC	??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@	; `string'
PUBLIC	??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ ; `string'
;	COMDAT ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
CONST	SEGMENT
??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ DB 'invalid dis'
	DB	'tance too far back', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
CONST	SEGMENT
??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@ DB 'invalid distance code'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
CONST	SEGMENT
??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ DB 'invalid litera'
	DB	'l/length code', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@
CONST	SEGMENT
??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@ DB 'invalid distances set'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ DB 'invalid litera'
	DB	'l/lengths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@
CONST	SEGMENT
??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ DB 'invalid '
	DB	'code -- missing end-of-block', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
CONST	SEGMENT
??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ DB 'invalid bit leng'
	DB	'th repeat', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ DB 'invalid code leng'
	DB	'ths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
CONST	SEGMENT
??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ DB 'too many le'
	DB	'ngth or distance symbols', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
CONST	SEGMENT
??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ DB 'invalid store'
	DB	'd block lengths', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@
CONST	SEGMENT
??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@ DB 'invalid block type', 00H ; `string'
	ORG $+2
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflateBack@@9@9 DW 010H			; `inflateBack'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	_inflateBackEnd
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\infback.c
;	COMDAT _inflateBackEnd
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateBackEnd PROC					; COMDAT

; 633  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 634  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00004	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 24		 je	 SHORT $LN1@inflateBac
  0000b	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  0000e	85 c9		 test	 ecx, ecx
  00010	74 1d		 je	 SHORT $LN1@inflateBac
  00012	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00015	85 c0		 test	 eax, eax
  00017	74 16		 je	 SHORT $LN1@inflateBac

; 636  :     ZFREE(strm, strm->state);

  00019	51		 push	 ecx
  0001a	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0001d	51		 push	 ecx
  0001e	ff d0		 call	 eax
  00020	83 c4 08	 add	 esp, 8

; 637  :     strm->state = Z_NULL;

  00023	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0

; 638  :     Tracev((stderr, "inflate: end\n"));
; 639  :     return Z_OK;

  0002a	33 c0		 xor	 eax, eax
  0002c	5e		 pop	 esi

; 640  : }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
$LN1@inflateBac:

; 635  :         return Z_STREAM_ERROR;

  0002f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00034	5e		 pop	 esi

; 640  : }

  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
_inflateBackEnd ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _fixedtables
_TEXT	SEGMENT
_fixedtables PROC					; COMDAT
; _state$ = eax

; 85   : #ifdef BUILDFIXED
; 86   :     static int virgin = 1;
; 87   :     static code *lenfix, *distfix;
; 88   :     static code fixed[544];
; 89   : 
; 90   :     /* build fixed huffman tables if first call (may not be thread safe) */
; 91   :     if (virgin) {
; 92   :         unsigned sym, bits;
; 93   :         static code *next;
; 94   : 
; 95   :         /* literal/length table */
; 96   :         sym = 0;
; 97   :         while (sym < 144) state->lens[sym++] = 8;
; 98   :         while (sym < 256) state->lens[sym++] = 9;
; 99   :         while (sym < 280) state->lens[sym++] = 7;
; 100  :         while (sym < 288) state->lens[sym++] = 8;
; 101  :         next = fixed;
; 102  :         lenfix = next;
; 103  :         bits = 9;
; 104  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 105  : 
; 106  :         /* distance table */
; 107  :         sym = 0;
; 108  :         while (sym < 32) state->lens[sym++] = 5;
; 109  :         distfix = next;
; 110  :         bits = 5;
; 111  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 112  : 
; 113  :         /* do this just once */
; 114  :         virgin = 0;
; 115  :     }
; 116  : #else /* !BUILDFIXED */
; 117  : #   include "inffixed.h"
; 118  : #endif /* BUILDFIXED */
; 119  :     state->lencode = lenfix;

  00000	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], OFFSET ?lenfix@?1??fixedtables@@9@9

; 120  :     state->lenbits = 9;

  00007	c7 40 58 09 00
	00 00		 mov	 DWORD PTR [eax+88], 9

; 121  :     state->distcode = distfix;

  0000e	c7 40 54 00 00
	00 00		 mov	 DWORD PTR [eax+84], OFFSET ?distfix@?1??fixedtables@@9@9

; 122  :     state->distbits = 5;

  00015	c7 40 5c 05 00
	00 00		 mov	 DWORD PTR [eax+92], 5

; 123  : }

  0001c	c3		 ret	 0
_fixedtables ENDP
_TEXT	ENDS
PUBLIC	_inflateBackInit_
; Function compile flags: /Ogtp
;	COMDAT _inflateBackInit_
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_window$ = 16						; size = 4
_version$ = 20						; size = 4
_stream_size$ = 24					; size = 4
_inflateBackInit_ PROC					; COMDAT

; 34   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 35   :     struct inflate_state FAR *state;
; 36   : 
; 37   :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
; 38   :         stream_size != (int)(sizeof(z_stream)))

  00003	8b 45 14	 mov	 eax, DWORD PTR _version$[ebp]
  00006	53		 push	 ebx
  00007	33 db		 xor	 ebx, ebx
  00009	3b c3		 cmp	 eax, ebx
  0000b	0f 84 a1 00 00
	00		 je	 $LN6@inflateBac@2
  00011	80 38 31	 cmp	 BYTE PTR [eax], 49	; 00000031H
  00014	0f 85 98 00 00
	00		 jne	 $LN6@inflateBac@2
  0001a	83 7d 18 38	 cmp	 DWORD PTR _stream_size$[ebp], 56 ; 00000038H
  0001e	0f 85 8e 00 00
	00		 jne	 $LN6@inflateBac@2

; 40   :     if (strm == Z_NULL || window == Z_NULL ||
; 41   :         windowBits < 8 || windowBits > 15)

  00024	56		 push	 esi
  00025	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00028	57		 push	 edi
  00029	3b f3		 cmp	 esi, ebx
  0002b	74 7b		 je	 SHORT $LN4@inflateBac@2
  0002d	39 5d 10	 cmp	 DWORD PTR _window$[ebp], ebx
  00030	74 76		 je	 SHORT $LN4@inflateBac@2
  00032	8b 7d 0c	 mov	 edi, DWORD PTR _windowBits$[ebp]
  00035	8d 47 f8	 lea	 eax, DWORD PTR [edi-8]
  00038	83 f8 07	 cmp	 eax, 7
  0003b	77 6b		 ja	 SHORT $LN4@inflateBac@2

; 43   :     strm->msg = Z_NULL;                 /* in case we return an error */

  0003d	89 5e 18	 mov	 DWORD PTR [esi+24], ebx

; 44   :     if (strm->zalloc == (alloc_func)0) {

  00040	39 5e 20	 cmp	 DWORD PTR [esi+32], ebx
  00043	75 0a		 jne	 SHORT $LN3@inflateBac@2

; 45   : #ifdef Z_SOLO
; 46   :         return Z_STREAM_ERROR;
; 47   : #else
; 48   :         strm->zalloc = zcalloc;

  00045	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], OFFSET _zcalloc

; 49   :         strm->opaque = (voidpf)0;

  0004c	89 5e 28	 mov	 DWORD PTR [esi+40], ebx
$LN3@inflateBac@2:

; 50   : #endif
; 51   :     }
; 52   :     if (strm->zfree == (free_func)0)

  0004f	39 5e 24	 cmp	 DWORD PTR [esi+36], ebx
  00052	75 07		 jne	 SHORT $LN2@inflateBac@2

; 53   : #ifdef Z_SOLO
; 54   :         return Z_STREAM_ERROR;
; 55   : #else
; 56   :     strm->zfree = zcfree;

  00054	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], OFFSET _zcfree
$LN2@inflateBac@2:

; 57   : #endif
; 58   :     state = (struct inflate_state FAR *)ZALLOC(strm, 1,
; 59   :                                                sizeof(struct inflate_state));

  0005b	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0005e	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  00061	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  00066	6a 01		 push	 1
  00068	51		 push	 ecx
  00069	ff d2		 call	 edx
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 60   :     if (state == Z_NULL) return Z_MEM_ERROR;

  0006e	3b c3		 cmp	 eax, ebx
  00070	75 0a		 jne	 SHORT $LN1@inflateBac@2
  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00079	5b		 pop	 ebx

; 70   : }

  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
$LN1@inflateBac@2:

; 61   :     Tracev((stderr, "inflate: allocated\n"));
; 62   :     strm->state = (struct internal_state FAR *)state;

  0007c	89 46 1c	 mov	 DWORD PTR [esi+28], eax

; 63   :     state->dmax = 32768U;
; 64   :     state->wbits = (uInt)windowBits;
; 65   :     state->wsize = 1U << windowBits;

  0007f	8b cf		 mov	 ecx, edi
  00081	ba 01 00 00 00	 mov	 edx, 1
  00086	d3 e2		 shl	 edx, cl

; 66   :     state->window = window;

  00088	8b 4d 10	 mov	 ecx, DWORD PTR _window$[ebp]
  0008b	89 78 28	 mov	 DWORD PTR [eax+40], edi
  0008e	5f		 pop	 edi

; 67   :     state->wnext = 0;

  0008f	89 58 34	 mov	 DWORD PTR [eax+52], ebx

; 68   :     state->whave = 0;

  00092	89 58 30	 mov	 DWORD PTR [eax+48], ebx
  00095	5e		 pop	 esi
  00096	c7 40 18 00 80
	00 00		 mov	 DWORD PTR [eax+24], 32768 ; 00008000H
  0009d	89 50 2c	 mov	 DWORD PTR [eax+44], edx
  000a0	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 69   :     return Z_OK;

  000a3	33 c0		 xor	 eax, eax
  000a5	5b		 pop	 ebx

; 70   : }

  000a6	5d		 pop	 ebp
  000a7	c3		 ret	 0
$LN4@inflateBac@2:
  000a8	5f		 pop	 edi
  000a9	5e		 pop	 esi

; 42   :         return Z_STREAM_ERROR;

  000aa	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  000af	5b		 pop	 ebx

; 70   : }

  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
$LN6@inflateBac@2:

; 39   :         return Z_VERSION_ERROR;

  000b2	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH
  000b7	5b		 pop	 ebx

; 70   : }

  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
_inflateBackInit_ ENDP
PUBLIC	_inflateBack
; Function compile flags: /Ogtp
;	COMDAT _inflateBack
_TEXT	SEGMENT
tv1944 = -28						; size = 4
tv1453 = -28						; size = 4
_from$ = -28						; size = 4
tv1479 = -24						; size = 4
tv1454 = -24						; size = 4
_len$ = -24						; size = 4
_here$ = -24						; size = 4
_copy$ = -24						; size = 4
_last$ = -20						; size = 4
_left$ = -16						; size = 4
_put$ = -12						; size = 4
_next$ = -8						; size = 4
_have$ = -4						; size = 4
_strm$ = 8						; size = 4
_in$ = 12						; size = 4
_in_desc$ = 16						; size = 4
_out$ = 20						; size = 4
_out_desc$ = 24						; size = 4
_inflateBack PROC					; COMDAT

; 256  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 257  :     struct inflate_state FAR *state;
; 258  :     z_const unsigned char FAR *next;    /* next input */
; 259  :     unsigned char FAR *put;     /* next output */
; 260  :     unsigned have, left;        /* available input and output */
; 261  :     unsigned long hold;         /* bit buffer */
; 262  :     unsigned bits;              /* bits in bit buffer */
; 263  :     unsigned copy;              /* number of stored or match bytes to copy */
; 264  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 265  :     code here;                  /* current decoding table entry */
; 266  :     code last;                  /* parent table entry */
; 267  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 268  :     int ret;                    /* return code */
; 269  :     static const unsigned short order[19] = /* permutation of code lengths */
; 270  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 271  : 
; 272  :     /* Check that the strm exists and that the state was initialized */
; 273  :     if (strm == Z_NULL || strm->state == Z_NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00009	56		 push	 esi
  0000a	33 f6		 xor	 esi, esi
  0000c	57		 push	 edi
  0000d	3b c6		 cmp	 eax, esi
  0000f	0f 84 a6 0c 00
	00		 je	 $LN333@inflateBac@3
  00015	8b 78 1c	 mov	 edi, DWORD PTR [eax+28]
  00018	3b fe		 cmp	 edi, esi
  0001a	0f 84 9b 0c 00
	00		 je	 $LN333@inflateBac@3

; 275  :     state = (struct inflate_state FAR *)strm->state;
; 276  : 
; 277  :     /* Reset the state */
; 278  :     strm->msg = Z_NULL;

  00020	89 70 18	 mov	 DWORD PTR [eax+24], esi

; 279  :     state->mode = TYPE;

  00023	c7 47 04 3f 3f
	00 00		 mov	 DWORD PTR [edi+4], 16191 ; 00003f3fH

; 280  :     state->last = 0;

  0002a	89 77 08	 mov	 DWORD PTR [edi+8], esi

; 281  :     state->whave = 0;

  0002d	89 77 30	 mov	 DWORD PTR [edi+48], esi

; 282  :     next = strm->next_in;

  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	89 4d f8	 mov	 DWORD PTR _next$[ebp], ecx

; 283  :     have = next != Z_NULL ? strm->avail_in : 0;

  00035	3b ce		 cmp	 ecx, esi
  00037	74 08		 je	 SHORT $LN337@inflateBac@3
  00039	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003c	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  0003f	eb 03		 jmp	 SHORT $LN338@inflateBac@3
$LN337@inflateBac@3:
  00041	89 75 fc	 mov	 DWORD PTR _have$[ebp], esi
$LN338@inflateBac@3:

; 284  :     hold = 0;
; 285  :     bits = 0;
; 286  :     put = state->window;
; 287  :     left = state->wsize;
; 288  : 
; 289  :     /* Inflate until end of block marked as last */
; 290  :     for (;;)
; 291  :         switch (state->mode) {

  00044	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00047	8b 57 38	 mov	 edx, DWORD PTR [edi+56]
  0004a	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  0004d	53		 push	 ebx
  0004e	2d 3f 3f 00 00	 sub	 eax, 16191		; 00003f3fH
  00053	33 db		 xor	 ebx, ebx
  00055	89 55 f4	 mov	 DWORD PTR _put$[ebp], edx
  00058	89 4d f0	 mov	 DWORD PTR _left$[ebp], ecx
  0005b	83 f8 12	 cmp	 eax, 18			; 00000012H
  0005e	76 23		 jbe	 SHORT $LN332@inflateBac@3
$LN1@inflateBac@3:

; 618  : 
; 619  :         default:                /* can't happen, but makes compilers happy */
; 620  :             ret = Z_STREAM_ERROR;

  00060	be fe ff ff ff	 mov	 esi, -2			; fffffffeH
$inf_leave$3865:

; 621  :             goto inf_leave;
; 622  :         }
; 623  : 
; 624  :     /* Return unused input */
; 625  :   inf_leave:
; 626  :     strm->next_in = next;

  00065	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00068	8b 4d f8	 mov	 ecx, DWORD PTR _next$[ebp]

; 627  :     strm->avail_in = have;

  0006b	8b 55 fc	 mov	 edx, DWORD PTR _have$[ebp]
  0006e	5b		 pop	 ebx
  0006f	89 08		 mov	 DWORD PTR [eax], ecx
  00071	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00074	5f		 pop	 edi

; 628  :     return ret;

  00075	8b c6		 mov	 eax, esi
  00077	5e		 pop	 esi

; 629  : }

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
  0007c	8d 64 24 00	 npad	 4
$LL418@inflateBac@3:

; 284  :     hold = 0;
; 285  :     bits = 0;
; 286  :     put = state->window;
; 287  :     left = state->wsize;
; 288  : 
; 289  :     /* Inflate until end of block marked as last */
; 290  :     for (;;)
; 291  :         switch (state->mode) {

  00080	8b 55 f4	 mov	 edx, DWORD PTR _put$[ebp]
$LN332@inflateBac@3:
  00083	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN412@inflateBac@3[eax]
  0008a	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN458@inflateBac@3[eax*4]
$LN328@inflateBac@3:

; 292  :         case TYPE:
; 293  :             /* determine and dispatch block type */
; 294  :             if (state->last) {

  00091	83 7f 08 00	 cmp	 DWORD PTR [edi+8], 0
  00095	74 15		 je	 SHORT $LN323@inflateBac@3

; 295  :                 BYTEBITS();

  00097	8b ce		 mov	 ecx, esi
  00099	83 e1 07	 and	 ecx, 7
  0009c	d3 eb		 shr	 ebx, cl
  0009e	2b f1		 sub	 esi, ecx

; 296  :                 state->mode = DONE;

  000a0	c7 47 04 50 3f
	00 00		 mov	 DWORD PTR [edi+4], 16208 ; 00003f50H

; 297  :                 break;

  000a7	e9 9c 0b 00 00	 jmp	 $LN387@inflateBac@3
$LN323@inflateBac@3:

; 298  :             }
; 299  :             NEEDBITS(3);

  000ac	83 fe 03	 cmp	 esi, 3
  000af	73 3a		 jae	 SHORT $LN322@inflateBac@3
$LL320@inflateBac@3:
  000b1	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  000b5	75 19		 jne	 SHORT $LN314@inflateBac@3
  000b7	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  000ba	8d 4d f8	 lea	 ecx, DWORD PTR _next$[ebp]
  000bd	51		 push	 ecx
  000be	52		 push	 edx
  000bf	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  000c2	83 c4 08	 add	 esp, 8
  000c5	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  000c8	85 c0		 test	 eax, eax
  000ca	0f 84 8e 0b 00
	00		 je	 $LN363@inflateBac@3
$LN314@inflateBac@3:
  000d0	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  000d3	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  000d6	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  000d9	8b ce		 mov	 ecx, esi
  000db	d3 e2		 shl	 edx, cl
  000dd	40		 inc	 eax
  000de	83 c6 08	 add	 esi, 8
  000e1	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  000e4	03 da		 add	 ebx, edx
  000e6	83 fe 03	 cmp	 esi, 3
  000e9	72 c6		 jb	 SHORT $LL320@inflateBac@3
$LN322@inflateBac@3:

; 300  :             state->last = BITS(1);

  000eb	8b c3		 mov	 eax, ebx
  000ed	83 e0 01	 and	 eax, 1

; 301  :             DROPBITS(1);

  000f0	d1 eb		 shr	 ebx, 1
  000f2	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 302  :             switch (BITS(2)) {

  000f5	8b c3		 mov	 eax, ebx
  000f7	83 e0 03	 and	 eax, 3
  000fa	83 f8 03	 cmp	 eax, 3
  000fd	77 55		 ja	 SHORT $LN301@inflateBac@3
  000ff	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN459@inflateBac@3[eax*4]
$LN305@inflateBac@3:

; 322  :             }
; 323  :             DROPBITS(2);

  00106	c1 eb 02	 shr	 ebx, 2
  00109	c7 47 04 41 3f
	00 00		 mov	 DWORD PTR [edi+4], 16193 ; 00003f41H
  00110	83 ee 03	 sub	 esi, 3

; 324  :             break;

  00113	e9 30 0b 00 00	 jmp	 $LN387@inflateBac@3
$LN304@inflateBac@3:

; 303  :             case 0:                             /* stored block */
; 304  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 305  :                         state->last ? " (last)" : ""));
; 306  :                 state->mode = STORED;
; 307  :                 break;
; 308  :             case 1:                             /* fixed block */
; 309  :                 fixedtables(state);

  00118	8b c7		 mov	 eax, edi
  0011a	e8 00 00 00 00	 call	 _fixedtables

; 322  :             }
; 323  :             DROPBITS(2);

  0011f	c1 eb 02	 shr	 ebx, 2
  00122	c7 47 04 48 3f
	00 00		 mov	 DWORD PTR [edi+4], 16200 ; 00003f48H
  00129	83 ee 03	 sub	 esi, 3

; 324  :             break;

  0012c	e9 17 0b 00 00	 jmp	 $LN387@inflateBac@3
$LN303@inflateBac@3:

; 322  :             }
; 323  :             DROPBITS(2);

  00131	c1 eb 02	 shr	 ebx, 2
  00134	c7 47 04 44 3f
	00 00		 mov	 DWORD PTR [edi+4], 16196 ; 00003f44H
  0013b	83 ee 03	 sub	 esi, 3

; 324  :             break;

  0013e	e9 05 0b 00 00	 jmp	 $LN387@inflateBac@3
$LN302@inflateBac@3:

; 310  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 311  :                         state->last ? " (last)" : ""));
; 312  :                 state->mode = LEN;              /* decode codes */
; 313  :                 break;
; 314  :             case 2:                             /* dynamic block */
; 315  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 316  :                         state->last ? " (last)" : ""));
; 317  :                 state->mode = TABLE;
; 318  :                 break;
; 319  :             case 3:
; 320  :                 strm->msg = (char *)"invalid block type";

  00143	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00146	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@

; 321  :                 state->mode = BAD;

  0014d	c7 47 04 51 3f
	00 00		 mov	 DWORD PTR [edi+4], 16209 ; 00003f51H
$LN301@inflateBac@3:

; 322  :             }
; 323  :             DROPBITS(2);

  00154	c1 eb 02	 shr	 ebx, 2
  00157	83 ee 03	 sub	 esi, 3

; 324  :             break;

  0015a	e9 e9 0a 00 00	 jmp	 $LN387@inflateBac@3
$LN297@inflateBac@3:

; 325  : 
; 326  :         case STORED:
; 327  :             /* get and verify stored block length */
; 328  :             BYTEBITS();                         /* go to byte boundary */

  0015f	8b ce		 mov	 ecx, esi
  00161	83 e1 07	 and	 ecx, 7
  00164	2b f1		 sub	 esi, ecx
  00166	d3 eb		 shr	 ebx, cl

; 329  :             NEEDBITS(32);

  00168	83 fe 20	 cmp	 esi, 32			; 00000020H
  0016b	73 3d		 jae	 SHORT $LN293@inflateBac@3
  0016d	8d 49 00	 npad	 3
$LL291@inflateBac@3:
  00170	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00174	75 19		 jne	 SHORT $LN285@inflateBac@3
  00176	8b 45 10	 mov	 eax, DWORD PTR _in_desc$[ebp]
  00179	8d 55 f8	 lea	 edx, DWORD PTR _next$[ebp]
  0017c	52		 push	 edx
  0017d	50		 push	 eax
  0017e	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00181	83 c4 08	 add	 esp, 8
  00184	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  00187	85 c0		 test	 eax, eax
  00189	0f 84 cf 0a 00
	00		 je	 $LN363@inflateBac@3
$LN285@inflateBac@3:
  0018f	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00192	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00195	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00198	8b ce		 mov	 ecx, esi
  0019a	d3 e2		 shl	 edx, cl
  0019c	40		 inc	 eax
  0019d	83 c6 08	 add	 esi, 8
  001a0	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  001a3	03 da		 add	 ebx, edx
  001a5	83 fe 20	 cmp	 esi, 32			; 00000020H
  001a8	72 c6		 jb	 SHORT $LL291@inflateBac@3
$LN293@inflateBac@3:

; 330  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  001aa	8b cb		 mov	 ecx, ebx
  001ac	8b c3		 mov	 eax, ebx
  001ae	f7 d1		 not	 ecx
  001b0	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  001b5	c1 e9 10	 shr	 ecx, 16			; 00000010H
  001b8	3b c1		 cmp	 eax, ecx
  001ba	74 16		 je	 SHORT $LN281@inflateBac@3

; 331  :                 strm->msg = (char *)"invalid stored block lengths";

  001bc	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  001bf	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@

; 332  :                 state->mode = BAD;

  001c6	c7 47 04 51 3f
	00 00		 mov	 DWORD PTR [edi+4], 16209 ; 00003f51H

; 333  :                 break;

  001cd	e9 76 0a 00 00	 jmp	 $LN387@inflateBac@3
$LN281@inflateBac@3:

; 334  :             }
; 335  :             state->length = (unsigned)hold & 0xffff;
; 336  :             Tracev((stderr, "inflate:       stored length %u\n",
; 337  :                     state->length));
; 338  :             INITBITS();

  001d2	33 db		 xor	 ebx, ebx
  001d4	33 f6		 xor	 esi, esi
  001d6	89 47 44	 mov	 DWORD PTR [edi+68], eax

; 339  : 
; 340  :             /* copy stored block from input to output */
; 341  :             while (state->length != 0) {

  001d9	85 c0		 test	 eax, eax
  001db	0f 84 94 00 00
	00		 je	 $LN276@inflateBac@3
$LL277@inflateBac@3:

; 342  :                 copy = state->length;

  001e1	8b 47 44	 mov	 eax, DWORD PTR [edi+68]
  001e4	89 45 e8	 mov	 DWORD PTR _copy$[ebp], eax

; 343  :                 PULL();

  001e7	39 5d fc	 cmp	 DWORD PTR _have$[ebp], ebx
  001ea	75 19		 jne	 SHORT $LN274@inflateBac@3
  001ec	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  001ef	8d 4d f8	 lea	 ecx, DWORD PTR _next$[ebp]
  001f2	51		 push	 ecx
  001f3	52		 push	 edx
  001f4	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  001f7	83 c4 08	 add	 esp, 8
  001fa	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  001fd	85 c0		 test	 eax, eax
  001ff	0f 84 6a 0a 00
	00		 je	 $LN365@inflateBac@3
$LN274@inflateBac@3:

; 344  :                 ROOM();

  00205	39 5d f0	 cmp	 DWORD PTR _left$[ebp], ebx
  00208	75 23		 jne	 SHORT $LN269@inflateBac@3
  0020a	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  0020d	8b 4f 38	 mov	 ecx, DWORD PTR [edi+56]
  00210	50		 push	 eax
  00211	89 45 f0	 mov	 DWORD PTR _left$[ebp], eax
  00214	89 47 30	 mov	 DWORD PTR [edi+48], eax
  00217	8b 45 18	 mov	 eax, DWORD PTR _out_desc$[ebp]
  0021a	51		 push	 ecx
  0021b	50		 push	 eax
  0021c	89 4d f4	 mov	 DWORD PTR _put$[ebp], ecx
  0021f	ff 55 14	 call	 DWORD PTR _out$[ebp]
  00222	83 c4 0c	 add	 esp, 12			; 0000000cH
  00225	85 c0		 test	 eax, eax
  00227	0f 85 38 0a 00
	00		 jne	 $LN366@inflateBac@3
$LN269@inflateBac@3:

; 345  :                 if (copy > have) copy = have;

  0022d	8b 45 e8	 mov	 eax, DWORD PTR _copy$[ebp]
  00230	8b 4d fc	 mov	 ecx, DWORD PTR _have$[ebp]
  00233	3b c1		 cmp	 eax, ecx
  00235	76 05		 jbe	 SHORT $LN265@inflateBac@3
  00237	8b c1		 mov	 eax, ecx
  00239	89 4d e8	 mov	 DWORD PTR _copy$[ebp], ecx
$LN265@inflateBac@3:

; 346  :                 if (copy > left) copy = left;

  0023c	8b 4d f0	 mov	 ecx, DWORD PTR _left$[ebp]
  0023f	3b c1		 cmp	 eax, ecx
  00241	76 03		 jbe	 SHORT $LN264@inflateBac@3
  00243	89 4d e8	 mov	 DWORD PTR _copy$[ebp], ecx
$LN264@inflateBac@3:

; 347  :                 zmemcpy(put, next, copy);

  00246	8b 4d e8	 mov	 ecx, DWORD PTR _copy$[ebp]
  00249	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  0024c	8b 45 f4	 mov	 eax, DWORD PTR _put$[ebp]
  0024f	51		 push	 ecx
  00250	52		 push	 edx
  00251	50		 push	 eax
  00252	e8 00 00 00 00	 call	 _memcpy

; 348  :                 have -= copy;

  00257	8b 45 e8	 mov	 eax, DWORD PTR _copy$[ebp]

; 349  :                 next += copy;

  0025a	01 45 f8	 add	 DWORD PTR _next$[ebp], eax
  0025d	29 45 fc	 sub	 DWORD PTR _have$[ebp], eax

; 350  :                 left -= copy;

  00260	29 45 f0	 sub	 DWORD PTR _left$[ebp], eax

; 351  :                 put += copy;

  00263	01 45 f4	 add	 DWORD PTR _put$[ebp], eax

; 352  :                 state->length -= copy;

  00266	29 47 44	 sub	 DWORD PTR [edi+68], eax
  00269	83 c4 0c	 add	 esp, 12			; 0000000cH
  0026c	39 5f 44	 cmp	 DWORD PTR [edi+68], ebx
  0026f	0f 85 6c ff ff
	ff		 jne	 $LL277@inflateBac@3
$LN276@inflateBac@3:

; 353  :             }
; 354  :             Tracev((stderr, "inflate:       stored end\n"));
; 355  :             state->mode = TYPE;

  00275	c7 47 04 3f 3f
	00 00		 mov	 DWORD PTR [edi+4], 16191 ; 00003f3fH

; 356  :             break;

  0027c	e9 c7 09 00 00	 jmp	 $LN387@inflateBac@3
$LN262@inflateBac@3:

; 357  : 
; 358  :         case TABLE:
; 359  :             /* get dynamic table entries descriptor */
; 360  :             NEEDBITS(14);

  00281	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  00284	73 3a		 jae	 SHORT $LN261@inflateBac@3
$LL259@inflateBac@3:
  00286	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  0028a	75 19		 jne	 SHORT $LN253@inflateBac@3
  0028c	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  0028f	8d 4d f8	 lea	 ecx, DWORD PTR _next$[ebp]
  00292	51		 push	 ecx
  00293	52		 push	 edx
  00294	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00297	83 c4 08	 add	 esp, 8
  0029a	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  0029d	85 c0		 test	 eax, eax
  0029f	0f 84 b9 09 00
	00		 je	 $LN363@inflateBac@3
$LN253@inflateBac@3:
  002a5	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  002a8	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  002ab	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  002ae	8b ce		 mov	 ecx, esi
  002b0	d3 e2		 shl	 edx, cl
  002b2	40		 inc	 eax
  002b3	83 c6 08	 add	 esi, 8
  002b6	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  002b9	03 da		 add	 ebx, edx
  002bb	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  002be	72 c6		 jb	 SHORT $LL259@inflateBac@3
$LN261@inflateBac@3:

; 361  :             state->nlen = BITS(5) + 257;

  002c0	8b c3		 mov	 eax, ebx

; 362  :             DROPBITS(5);

  002c2	c1 eb 05	 shr	 ebx, 5

; 363  :             state->ndist = BITS(5) + 1;

  002c5	8b cb		 mov	 ecx, ebx

; 364  :             DROPBITS(5);

  002c7	c1 eb 05	 shr	 ebx, 5

; 365  :             state->ncode = BITS(4) + 4;

  002ca	8b d3		 mov	 edx, ebx
  002cc	83 e0 1f	 and	 eax, 31			; 0000001fH
  002cf	83 e1 1f	 and	 ecx, 31			; 0000001fH
  002d2	83 e2 0f	 and	 edx, 15			; 0000000fH
  002d5	05 01 01 00 00	 add	 eax, 257		; 00000101H
  002da	41		 inc	 ecx
  002db	83 c2 04	 add	 edx, 4

; 366  :             DROPBITS(4);

  002de	c1 eb 04	 shr	 ebx, 4
  002e1	83 ee 0e	 sub	 esi, 14			; 0000000eH
  002e4	89 47 64	 mov	 DWORD PTR [edi+100], eax
  002e7	89 4f 68	 mov	 DWORD PTR [edi+104], ecx
  002ea	89 57 60	 mov	 DWORD PTR [edi+96], edx

; 367  : #ifndef PKZIP_BUG_WORKAROUND
; 368  :             if (state->nlen > 286 || state->ndist > 30) {

  002ed	3d 1e 01 00 00	 cmp	 eax, 286		; 0000011eH
  002f2	0f 87 98 04 00
	00		 ja	 $LN239@inflateBac@3
  002f8	83 f9 1e	 cmp	 ecx, 30			; 0000001eH
  002fb	0f 87 8f 04 00
	00		 ja	 $LN239@inflateBac@3

; 372  :             }
; 373  : #endif
; 374  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 375  : 
; 376  :             /* get code length code lengths (not a typo) */
; 377  :             state->have = 0;

  00301	c7 47 6c 00 00
	00 00		 mov	 DWORD PTR [edi+108], 0

; 378  :             while (state->have < state->ncode) {

  00308	85 d2		 test	 edx, edx
  0030a	76 69		 jbe	 SHORT $LN346@inflateBac@3
  0030c	8d 64 24 00	 npad	 4
$LL238@inflateBac@3:

; 379  :                 NEEDBITS(3);

  00310	83 fe 03	 cmp	 esi, 3
  00313	73 3a		 jae	 SHORT $LN235@inflateBac@3
$LL233@inflateBac@3:
  00315	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00319	75 19		 jne	 SHORT $LN227@inflateBac@3
  0031b	8b 4d 10	 mov	 ecx, DWORD PTR _in_desc$[ebp]
  0031e	8d 45 f8	 lea	 eax, DWORD PTR _next$[ebp]
  00321	50		 push	 eax
  00322	51		 push	 ecx
  00323	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00326	83 c4 08	 add	 esp, 8
  00329	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  0032c	85 c0		 test	 eax, eax
  0032e	0f 84 2a 09 00
	00		 je	 $LN363@inflateBac@3
$LN227@inflateBac@3:
  00334	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00337	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  0033a	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  0033d	8b ce		 mov	 ecx, esi
  0033f	d3 e2		 shl	 edx, cl
  00341	40		 inc	 eax
  00342	83 c6 08	 add	 esi, 8
  00345	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  00348	03 da		 add	 ebx, edx
  0034a	83 fe 03	 cmp	 esi, 3
  0034d	72 c6		 jb	 SHORT $LL233@inflateBac@3
$LN235@inflateBac@3:

; 380  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  0034f	8b 4f 6c	 mov	 ecx, DWORD PTR [edi+108]
  00352	0f b7 14 4d 00
	00 00 00	 movzx	 edx, WORD PTR ?order@?1??inflateBack@@9@9[ecx*2]
  0035a	8b c3		 mov	 eax, ebx
  0035c	83 e0 07	 and	 eax, 7
  0035f	66 89 44 57 74	 mov	 WORD PTR [edi+edx*2+116], ax
  00364	ff 47 6c	 inc	 DWORD PTR [edi+108]
  00367	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]

; 381  :                 DROPBITS(3);

  0036a	c1 eb 03	 shr	 ebx, 3
  0036d	83 ee 03	 sub	 esi, 3
  00370	3b 47 60	 cmp	 eax, DWORD PTR [edi+96]
  00373	72 9b		 jb	 SHORT $LL238@inflateBac@3
$LN346@inflateBac@3:

; 382  :             }
; 383  :             while (state->have < 19)

  00375	b8 13 00 00 00	 mov	 eax, 19			; 00000013H
  0037a	39 47 6c	 cmp	 DWORD PTR [edi+108], eax
  0037d	73 1b		 jae	 SHORT $LN219@inflateBac@3
  0037f	90		 npad	 1
$LL220@inflateBac@3:

; 384  :                 state->lens[order[state->have++]] = 0;

  00380	8b 4f 6c	 mov	 ecx, DWORD PTR [edi+108]
  00383	0f b7 14 4d 00
	00 00 00	 movzx	 edx, WORD PTR ?order@?1??inflateBack@@9@9[ecx*2]
  0038b	33 c9		 xor	 ecx, ecx
  0038d	66 89 4c 57 74	 mov	 WORD PTR [edi+edx*2+116], cx
  00392	ff 47 6c	 inc	 DWORD PTR [edi+108]
  00395	39 47 6c	 cmp	 DWORD PTR [edi+108], eax
  00398	72 e6		 jb	 SHORT $LL220@inflateBac@3
$LN219@inflateBac@3:

; 385  :             state->next = state->codes;

  0039a	8d 87 34 05 00
	00		 lea	 eax, DWORD PTR [edi+1332]
  003a0	8d 4f 70	 lea	 ecx, DWORD PTR [edi+112]
  003a3	89 01		 mov	 DWORD PTR [ecx], eax

; 386  :             state->lencode = (code const FAR *)(state->next);

  003a5	89 47 50	 mov	 DWORD PTR [edi+80], eax

; 387  :             state->lenbits = 7;
; 388  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),
; 389  :                                 &(state->lenbits), state->work);

  003a8	8d 97 f4 02 00
	00		 lea	 edx, DWORD PTR [edi+756]
  003ae	52		 push	 edx
  003af	8d 47 58	 lea	 eax, DWORD PTR [edi+88]
  003b2	50		 push	 eax
  003b3	51		 push	 ecx
  003b4	c7 00 07 00 00
	00		 mov	 DWORD PTR [eax], 7
  003ba	6a 13		 push	 19			; 00000013H
  003bc	8d 47 74	 lea	 eax, DWORD PTR [edi+116]
  003bf	50		 push	 eax
  003c0	6a 00		 push	 0
  003c2	e8 00 00 00 00	 call	 _inflate_table
  003c7	83 c4 18	 add	 esp, 24			; 00000018H

; 390  :             if (ret) {

  003ca	85 c0		 test	 eax, eax
  003cc	74 16		 je	 SHORT $LN218@inflateBac@3

; 391  :                 strm->msg = (char *)"invalid code lengths set";

  003ce	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  003d1	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@

; 392  :                 state->mode = BAD;

  003d8	c7 47 04 51 3f
	00 00		 mov	 DWORD PTR [edi+4], 16209 ; 00003f51H

; 393  :                 break;

  003df	e9 64 08 00 00	 jmp	 $LN387@inflateBac@3
$LN218@inflateBac@3:

; 394  :             }
; 395  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 396  : 
; 397  :             /* get length and distance code code lengths */
; 398  :             state->have = 0;
; 399  :             while (state->have < state->nlen + state->ndist) {

  003e4	8b 47 68	 mov	 eax, DWORD PTR [edi+104]
  003e7	03 47 64	 add	 eax, DWORD PTR [edi+100]
  003ea	c7 47 6c 00 00
	00 00		 mov	 DWORD PTR [edi+108], 0
  003f1	0f 84 36 02 00
	00		 je	 $LN415@inflateBac@3
  003f7	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL217@inflateBac@3:

; 400  :                 for (;;) {
; 401  :                     here = state->lencode[BITS(state->lenbits)];

  00400	8b 4f 58	 mov	 ecx, DWORD PTR [edi+88]
  00403	8b 47 50	 mov	 eax, DWORD PTR [edi+80]
  00406	ba 01 00 00 00	 mov	 edx, 1
  0040b	d3 e2		 shl	 edx, cl
  0040d	4a		 dec	 edx
  0040e	23 d3		 and	 edx, ebx
  00410	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]

; 402  :                     if ((unsigned)(here.bits) <= bits) break;

  00413	8b c8		 mov	 ecx, eax
  00415	c1 e9 08	 shr	 ecx, 8
  00418	0f b6 d1	 movzx	 edx, cl
  0041b	89 45 e8	 mov	 DWORD PTR _here$[ebp], eax
  0041e	3b d6		 cmp	 edx, esi
  00420	76 58		 jbe	 SHORT $LN369@inflateBac@3
$LL215@inflateBac@3:

; 403  :                     PULLBYTE();

  00422	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00426	75 19		 jne	 SHORT $LN208@inflateBac@3
  00428	8b 4d 10	 mov	 ecx, DWORD PTR _in_desc$[ebp]
  0042b	8d 45 f8	 lea	 eax, DWORD PTR _next$[ebp]
  0042e	50		 push	 eax
  0042f	51		 push	 ecx
  00430	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00433	83 c4 08	 add	 esp, 8
  00436	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  00439	85 c0		 test	 eax, eax
  0043b	0f 84 1d 08 00
	00		 je	 $LN363@inflateBac@3
$LN208@inflateBac@3:
  00441	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00444	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00447	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  0044a	40		 inc	 eax
  0044b	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  0044e	8b ce		 mov	 ecx, esi
  00450	d3 e2		 shl	 edx, cl
  00452	8b 4f 58	 mov	 ecx, DWORD PTR [edi+88]
  00455	b8 01 00 00 00	 mov	 eax, 1
  0045a	d3 e0		 shl	 eax, cl
  0045c	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
  0045f	03 da		 add	 ebx, edx
  00461	83 c6 08	 add	 esi, 8
  00464	48		 dec	 eax
  00465	23 c3		 and	 eax, ebx
  00467	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0046a	89 45 e8	 mov	 DWORD PTR _here$[ebp], eax
  0046d	c1 e8 08	 shr	 eax, 8
  00470	0f b6 d0	 movzx	 edx, al
  00473	3b d6		 cmp	 edx, esi
  00475	77 ab		 ja	 SHORT $LL215@inflateBac@3

; 402  :                     if ((unsigned)(here.bits) <= bits) break;

  00477	8b 45 e8	 mov	 eax, DWORD PTR _here$[ebp]
$LN369@inflateBac@3:

; 404  :                 }
; 405  :                 if (here.val < 16) {

  0047a	8b d0		 mov	 edx, eax
  0047c	c1 ea 10	 shr	 edx, 16			; 00000010H
  0047f	66 83 fa 10	 cmp	 dx, 16			; 00000010H
  00483	73 1a		 jae	 SHORT $LN456@inflateBac@3

; 406  :                     DROPBITS(here.bits);

  00485	c1 e8 08	 shr	 eax, 8
  00488	0f b6 c8	 movzx	 ecx, al

; 407  :                     state->lens[state->have++] = here.val;

  0048b	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]
  0048e	d3 eb		 shr	 ebx, cl
  00490	2b f1		 sub	 esi, ecx
  00492	66 89 54 47 74	 mov	 WORD PTR [edi+eax*2+116], dx
  00497	ff 47 6c	 inc	 DWORD PTR [edi+108]

; 408  :                 }
; 409  :                 else {

  0049a	e9 7f 01 00 00	 jmp	 $LN435@inflateBac@3
$LN456@inflateBac@3:

; 410  :                     if (here.val == 16) {

  0049f	75 7f		 jne	 SHORT $LN199@inflateBac@3

; 411  :                         NEEDBITS(here.bits + 2);

  004a1	8b c8		 mov	 ecx, eax
  004a3	c1 e9 08	 shr	 ecx, 8
  004a6	0f b6 d1	 movzx	 edx, cl
  004a9	83 c2 02	 add	 edx, 2
  004ac	3b f2		 cmp	 esi, edx
  004ae	73 43		 jae	 SHORT $LN197@inflateBac@3
$LL195@inflateBac@3:
  004b0	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  004b4	75 19		 jne	 SHORT $LN189@inflateBac@3
  004b6	8b 4d 10	 mov	 ecx, DWORD PTR _in_desc$[ebp]
  004b9	8d 45 f8	 lea	 eax, DWORD PTR _next$[ebp]
  004bc	50		 push	 eax
  004bd	51		 push	 ecx
  004be	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  004c1	83 c4 08	 add	 esp, 8
  004c4	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  004c7	85 c0		 test	 eax, eax
  004c9	0f 84 8f 07 00
	00		 je	 $LN363@inflateBac@3
$LN189@inflateBac@3:
  004cf	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  004d2	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  004d5	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  004d8	40		 inc	 eax
  004d9	8b ce		 mov	 ecx, esi
  004db	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  004de	0f b6 45 e9	 movzx	 eax, BYTE PTR _here$[ebp+1]
  004e2	d3 e2		 shl	 edx, cl
  004e4	83 c6 08	 add	 esi, 8
  004e7	83 c0 02	 add	 eax, 2
  004ea	03 da		 add	 ebx, edx
  004ec	3b f0		 cmp	 esi, eax
  004ee	72 c0		 jb	 SHORT $LL195@inflateBac@3
  004f0	8b 45 e8	 mov	 eax, DWORD PTR _here$[ebp]
$LN197@inflateBac@3:

; 412  :                         DROPBITS(here.bits);

  004f3	0f b6 cc	 movzx	 ecx, ah

; 413  :                         if (state->have == 0) {

  004f6	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]
  004f9	d3 eb		 shr	 ebx, cl
  004fb	2b f1		 sub	 esi, ecx
  004fd	85 c0		 test	 eax, eax
  004ff	0f 84 55 01 00
	00		 je	 $LN374@inflateBac@3

; 417  :                         }
; 418  :                         len = (unsigned)(state->lens[state->have - 1]);

  00505	0f b7 4c 47 72	 movzx	 ecx, WORD PTR [edi+eax*2+114]

; 419  :                         copy = 3 + BITS(2);

  0050a	8b c3		 mov	 eax, ebx
  0050c	83 e0 03	 and	 eax, 3
  0050f	83 c0 03	 add	 eax, 3

; 420  :                         DROPBITS(2);

  00512	c1 eb 02	 shr	 ebx, 2
  00515	89 4d e8	 mov	 DWORD PTR _len$[ebp], ecx
  00518	83 ee 02	 sub	 esi, 2

; 421  :                     }
; 422  :                     else if (here.val == 17) {

  0051b	e9 d0 00 00 00	 jmp	 $LN138@inflateBac@3
$LN199@inflateBac@3:
  00520	66 83 7d ea 11	 cmp	 WORD PTR _here$[ebp+2], 17 ; 00000011H

; 423  :                         NEEDBITS(here.bits + 3);

  00525	0f b6 cc	 movzx	 ecx, ah
  00528	89 4d e8	 mov	 DWORD PTR tv1479[ebp], ecx
  0052b	75 5d		 jne	 SHORT $LN156@inflateBac@3
  0052d	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
  00530	3b f0		 cmp	 esi, eax
  00532	73 42		 jae	 SHORT $LN175@inflateBac@3
$LL173@inflateBac@3:
  00534	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00538	75 19		 jne	 SHORT $LN167@inflateBac@3
  0053a	8b 45 10	 mov	 eax, DWORD PTR _in_desc$[ebp]
  0053d	8d 55 f8	 lea	 edx, DWORD PTR _next$[ebp]
  00540	52		 push	 edx
  00541	50		 push	 eax
  00542	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00545	83 c4 08	 add	 esp, 8
  00548	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  0054b	85 c0		 test	 eax, eax
  0054d	0f 84 0b 07 00
	00		 je	 $LN363@inflateBac@3
$LN167@inflateBac@3:
  00553	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00556	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00559	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  0055c	40		 inc	 eax
  0055d	8b ce		 mov	 ecx, esi
  0055f	d3 e2		 shl	 edx, cl
  00561	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  00564	8b 45 e8	 mov	 eax, DWORD PTR tv1479[ebp]
  00567	83 c6 08	 add	 esi, 8
  0056a	83 c0 03	 add	 eax, 3
  0056d	03 da		 add	 ebx, edx
  0056f	3b f0		 cmp	 esi, eax
  00571	72 c1		 jb	 SHORT $LL173@inflateBac@3
  00573	8b 4d e8	 mov	 ecx, DWORD PTR tv1479[ebp]
$LN175@inflateBac@3:

; 424  :                         DROPBITS(here.bits);

  00576	d3 eb		 shr	 ebx, cl

; 425  :                         len = 0;
; 426  :                         copy = 3 + BITS(3);
; 427  :                         DROPBITS(3);

  00578	ba fd ff ff ff	 mov	 edx, -3			; fffffffdH
  0057d	8b c3		 mov	 eax, ebx
  0057f	83 e0 07	 and	 eax, 7
  00582	83 c0 03	 add	 eax, 3
  00585	c1 eb 03	 shr	 ebx, 3

; 428  :                     }
; 429  :                     else {

  00588	eb 5b		 jmp	 SHORT $LN457@inflateBac@3
$LN156@inflateBac@3:

; 430  :                         NEEDBITS(here.bits + 7);

  0058a	8d 41 07	 lea	 eax, DWORD PTR [ecx+7]
  0058d	3b f0		 cmp	 esi, eax
  0058f	73 42		 jae	 SHORT $LN155@inflateBac@3
$LL153@inflateBac@3:
  00591	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00595	75 19		 jne	 SHORT $LN147@inflateBac@3
  00597	8b 4d 10	 mov	 ecx, DWORD PTR _in_desc$[ebp]
  0059a	8d 45 f8	 lea	 eax, DWORD PTR _next$[ebp]
  0059d	50		 push	 eax
  0059e	51		 push	 ecx
  0059f	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  005a2	83 c4 08	 add	 esp, 8
  005a5	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  005a8	85 c0		 test	 eax, eax
  005aa	0f 84 ae 06 00
	00		 je	 $LN363@inflateBac@3
$LN147@inflateBac@3:
  005b0	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  005b3	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  005b6	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  005b9	40		 inc	 eax
  005ba	8b ce		 mov	 ecx, esi
  005bc	d3 e2		 shl	 edx, cl
  005be	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  005c1	8b 45 e8	 mov	 eax, DWORD PTR tv1479[ebp]
  005c4	83 c6 08	 add	 esi, 8
  005c7	83 c0 07	 add	 eax, 7
  005ca	03 da		 add	 ebx, edx
  005cc	3b f0		 cmp	 esi, eax
  005ce	72 c1		 jb	 SHORT $LL153@inflateBac@3
  005d0	8b 4d e8	 mov	 ecx, DWORD PTR tv1479[ebp]
$LN155@inflateBac@3:

; 431  :                         DROPBITS(here.bits);

  005d3	d3 eb		 shr	 ebx, cl

; 432  :                         len = 0;
; 433  :                         copy = 11 + BITS(7);
; 434  :                         DROPBITS(7);

  005d5	ba f9 ff ff ff	 mov	 edx, -7			; fffffff9H
  005da	8b c3		 mov	 eax, ebx
  005dc	83 e0 7f	 and	 eax, 127		; 0000007fH
  005df	83 c0 0b	 add	 eax, 11			; 0000000bH
  005e2	c1 eb 07	 shr	 ebx, 7
$LN457@inflateBac@3:
  005e5	2b d1		 sub	 edx, ecx
  005e7	03 f2		 add	 esi, edx
  005e9	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0
$LN138@inflateBac@3:

; 435  :                     }
; 436  :                     if (state->have + copy > state->nlen + state->ndist) {

  005f0	8b 57 68	 mov	 edx, DWORD PTR [edi+104]
  005f3	8b 4f 6c	 mov	 ecx, DWORD PTR [edi+108]
  005f6	03 57 64	 add	 edx, DWORD PTR [edi+100]
  005f9	03 c8		 add	 ecx, eax
  005fb	3b ca		 cmp	 ecx, edx
  005fd	77 71		 ja	 SHORT $LN375@inflateBac@3

; 439  :                         break;
; 440  :                     }
; 441  :                     while (copy--)

  005ff	85 c0		 test	 eax, eax
  00601	74 1b		 je	 SHORT $LN435@inflateBac@3
  00603	8b 4d e8	 mov	 ecx, DWORD PTR _len$[ebp]
  00606	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL136@inflateBac@3:

; 442  :                         state->lens[state->have++] = (unsigned short)len;

  00610	8b 57 6c	 mov	 edx, DWORD PTR [edi+108]
  00613	66 89 4c 57 74	 mov	 WORD PTR [edi+edx*2+116], cx
  00618	ff 47 6c	 inc	 DWORD PTR [edi+108]
  0061b	48		 dec	 eax
  0061c	75 f2		 jne	 SHORT $LL136@inflateBac@3
$LN435@inflateBac@3:

; 394  :             }
; 395  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 396  : 
; 397  :             /* get length and distance code code lengths */
; 398  :             state->have = 0;
; 399  :             while (state->have < state->nlen + state->ndist) {

  0061e	8b 47 68	 mov	 eax, DWORD PTR [edi+104]
  00621	03 47 64	 add	 eax, DWORD PTR [edi+100]
  00624	39 47 6c	 cmp	 DWORD PTR [edi+108], eax
  00627	0f 82 d3 fd ff
	ff		 jb	 $LL217@inflateBac@3
$LN415@inflateBac@3:

; 443  :                 }
; 444  :             }
; 445  : 
; 446  :             /* handle error breaks in while */
; 447  :             if (state->mode == BAD) break;

  0062d	81 7f 04 51 3f
	00 00		 cmp	 DWORD PTR [edi+4], 16209 ; 00003f51H
  00634	0f 84 0e 06 00
	00		 je	 $LN387@inflateBac@3

; 448  : 
; 449  :             /* check for end-of-block code (better have one) */
; 450  :             if (state->lens[256] == 0) {

  0063a	66 83 bf 74 02
	00 00 00	 cmp	 WORD PTR [edi+628], 0
  00642	75 42		 jne	 SHORT $LN133@inflateBac@3

; 451  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00644	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00647	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@

; 452  :                 state->mode = BAD;

  0064e	c7 47 04 51 3f
	00 00		 mov	 DWORD PTR [edi+4], 16209 ; 00003f51H

; 453  :                 break;

  00655	e9 ee 05 00 00	 jmp	 $LN387@inflateBac@3
$LN374@inflateBac@3:

; 414  :                             strm->msg = (char *)"invalid bit length repeat";

  0065a	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0065d	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@

; 415  :                             state->mode = BAD;

  00664	c7 47 04 51 3f
	00 00		 mov	 DWORD PTR [edi+4], 16209 ; 00003f51H

; 416  :                             break;

  0066b	e9 d8 05 00 00	 jmp	 $LN387@inflateBac@3
$LN375@inflateBac@3:

; 437  :                         strm->msg = (char *)"invalid bit length repeat";

  00670	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00673	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@

; 438  :                         state->mode = BAD;

  0067a	c7 47 04 51 3f
	00 00		 mov	 DWORD PTR [edi+4], 16209 ; 00003f51H

; 443  :                 }
; 444  :             }
; 445  : 
; 446  :             /* handle error breaks in while */
; 447  :             if (state->mode == BAD) break;

  00681	e9 c2 05 00 00	 jmp	 $LN387@inflateBac@3
$LN133@inflateBac@3:

; 454  :             }
; 455  : 
; 456  :             /* build code tables -- note: do not change the lenbits or distbits
; 457  :                values here (9 and 6) without reading the comments in inftrees.h
; 458  :                concerning the ENOUGH constants, which depend on those values */
; 459  :             state->next = state->codes;

  00686	8d 87 34 05 00
	00		 lea	 eax, DWORD PTR [edi+1332]
  0068c	8d 4f 70	 lea	 ecx, DWORD PTR [edi+112]
  0068f	89 01		 mov	 DWORD PTR [ecx], eax

; 460  :             state->lencode = (code const FAR *)(state->next);

  00691	89 47 50	 mov	 DWORD PTR [edi+80], eax

; 461  :             state->lenbits = 9;
; 462  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
; 463  :                                 &(state->lenbits), state->work);

  00694	8d 97 f4 02 00
	00		 lea	 edx, DWORD PTR [edi+756]
  0069a	52		 push	 edx
  0069b	8d 47 58	 lea	 eax, DWORD PTR [edi+88]
  0069e	50		 push	 eax
  0069f	51		 push	 ecx
  006a0	8b 4f 64	 mov	 ecx, DWORD PTR [edi+100]
  006a3	c7 00 09 00 00
	00		 mov	 DWORD PTR [eax], 9
  006a9	51		 push	 ecx
  006aa	8d 47 74	 lea	 eax, DWORD PTR [edi+116]
  006ad	50		 push	 eax
  006ae	6a 01		 push	 1
  006b0	e8 00 00 00 00	 call	 _inflate_table
  006b5	83 c4 18	 add	 esp, 24			; 00000018H

; 464  :             if (ret) {

  006b8	85 c0		 test	 eax, eax
  006ba	74 16		 je	 SHORT $LN132@inflateBac@3

; 465  :                 strm->msg = (char *)"invalid literal/lengths set";

  006bc	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  006bf	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@

; 466  :                 state->mode = BAD;

  006c6	c7 47 04 51 3f
	00 00		 mov	 DWORD PTR [edi+4], 16209 ; 00003f51H

; 467  :                 break;

  006cd	e9 76 05 00 00	 jmp	 $LN387@inflateBac@3
$LN132@inflateBac@3:

; 468  :             }
; 469  :             state->distcode = (code const FAR *)(state->next);

  006d2	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  006d5	8d 4f 70	 lea	 ecx, DWORD PTR [edi+112]
  006d8	89 47 54	 mov	 DWORD PTR [edi+84], eax

; 470  :             state->distbits = 6;
; 471  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 472  :                             &(state->next), &(state->distbits), state->work);

  006db	8d 97 f4 02 00
	00		 lea	 edx, DWORD PTR [edi+756]
  006e1	52		 push	 edx
  006e2	8b 57 64	 mov	 edx, DWORD PTR [edi+100]
  006e5	8d 47 5c	 lea	 eax, DWORD PTR [edi+92]
  006e8	50		 push	 eax
  006e9	51		 push	 ecx
  006ea	8b 4f 68	 mov	 ecx, DWORD PTR [edi+104]
  006ed	c7 00 06 00 00
	00		 mov	 DWORD PTR [eax], 6
  006f3	51		 push	 ecx
  006f4	8d 44 57 74	 lea	 eax, DWORD PTR [edi+edx*2+116]
  006f8	50		 push	 eax
  006f9	6a 02		 push	 2
  006fb	e8 00 00 00 00	 call	 _inflate_table
  00700	83 c4 18	 add	 esp, 24			; 00000018H

; 473  :             if (ret) {

  00703	85 c0		 test	 eax, eax
  00705	74 16		 je	 SHORT $LN131@inflateBac@3

; 474  :                 strm->msg = (char *)"invalid distances set";

  00707	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0070a	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@

; 475  :                 state->mode = BAD;

  00711	c7 47 04 51 3f
	00 00		 mov	 DWORD PTR [edi+4], 16209 ; 00003f51H

; 476  :                 break;

  00718	e9 2b 05 00 00	 jmp	 $LN387@inflateBac@3
$LN131@inflateBac@3:

; 477  :             }
; 478  :             Tracev((stderr, "inflate:       codes ok\n"));
; 479  :             state->mode = LEN;

  0071d	8b 55 f4	 mov	 edx, DWORD PTR _put$[ebp]
  00720	c7 47 04 48 3f
	00 00		 mov	 DWORD PTR [edi+4], 16200 ; 00003f48H
$LN130@inflateBac@3:

; 480  : 
; 481  :         case LEN:
; 482  :             /* use inflate_fast() if we have enough input and output */
; 483  :             if (have >= 6 && left >= 258) {

  00727	83 7d fc 06	 cmp	 DWORD PTR _have$[ebp], 6
  0072b	72 79		 jb	 SHORT $LN353@inflateBac@3
  0072d	8b 4d f0	 mov	 ecx, DWORD PTR _left$[ebp]
  00730	81 f9 02 01 00
	00		 cmp	 ecx, 258		; 00000102H
  00736	72 6e		 jb	 SHORT $LN353@inflateBac@3

; 484  :                 RESTORE();

  00738	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0073b	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  0073e	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  00741	89 10		 mov	 DWORD PTR [eax], edx
  00743	8b 55 fc	 mov	 edx, DWORD PTR _have$[ebp]
  00746	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00749	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 485  :                 if (state->whave < state->wsize)

  0074c	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  0074f	89 5f 3c	 mov	 DWORD PTR [edi+60], ebx
  00752	89 77 40	 mov	 DWORD PTR [edi+64], esi
  00755	39 47 30	 cmp	 DWORD PTR [edi+48], eax
  00758	73 07		 jae	 SHORT $LN125@inflateBac@3

; 486  :                     state->whave = state->wsize - left;

  0075a	8b d0		 mov	 edx, eax
  0075c	2b d1		 sub	 edx, ecx
  0075e	89 57 30	 mov	 DWORD PTR [edi+48], edx
$LN125@inflateBac@3:

; 487  :                 inflate_fast(strm, state->wsize);

  00761	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00764	50		 push	 eax
  00765	56		 push	 esi
  00766	e8 00 00 00 00	 call	 _inflate_fast

; 488  :                 LOAD();

  0076b	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0076e	8b 16		 mov	 edx, DWORD PTR [esi]
  00770	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00773	89 45 f4	 mov	 DWORD PTR _put$[ebp], eax
  00776	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00779	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  0077c	8b 5f 3c	 mov	 ebx, DWORD PTR [edi+60]
  0077f	8b 77 40	 mov	 esi, DWORD PTR [edi+64]
  00782	83 c4 08	 add	 esp, 8
  00785	89 4d f0	 mov	 DWORD PTR _left$[ebp], ecx
  00788	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax

; 489  :                 break;

  0078b	e9 b8 04 00 00	 jmp	 $LN387@inflateBac@3
$LN239@inflateBac@3:

; 369  :                 strm->msg = (char *)"too many length or distance symbols";

  00790	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00793	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@

; 370  :                 state->mode = BAD;

  0079a	c7 47 04 51 3f
	00 00		 mov	 DWORD PTR [edi+4], 16209 ; 00003f51H

; 371  :                 break;

  007a1	e9 a2 04 00 00	 jmp	 $LN387@inflateBac@3
$LN353@inflateBac@3:

; 490  :             }
; 491  : 
; 492  :             /* get a literal, length, or end-of-block code */
; 493  :             for (;;) {
; 494  :                 here = state->lencode[BITS(state->lenbits)];

  007a6	8b 4f 58	 mov	 ecx, DWORD PTR [edi+88]
  007a9	b8 01 00 00 00	 mov	 eax, 1
  007ae	d3 e0		 shl	 eax, cl
  007b0	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
  007b3	48		 dec	 eax
  007b4	23 c3		 and	 eax, ebx
  007b6	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 495  :                 if ((unsigned)(here.bits) <= bits) break;

  007b9	8b c8		 mov	 ecx, eax
  007bb	c1 e9 08	 shr	 ecx, 8
  007be	0f b6 c9	 movzx	 ecx, cl
  007c1	3b ce		 cmp	 ecx, esi
  007c3	76 57		 jbe	 SHORT $LN376@inflateBac@3
$LL121@inflateBac@3:

; 496  :                 PULLBYTE();

  007c5	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  007c9	75 19		 jne	 SHORT $LN114@inflateBac@3
  007cb	8b 45 10	 mov	 eax, DWORD PTR _in_desc$[ebp]
  007ce	8d 55 f8	 lea	 edx, DWORD PTR _next$[ebp]
  007d1	52		 push	 edx
  007d2	50		 push	 eax
  007d3	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  007d6	83 c4 08	 add	 esp, 8
  007d9	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  007dc	85 c0		 test	 eax, eax
  007de	0f 84 7a 04 00
	00		 je	 $LN363@inflateBac@3
$LN114@inflateBac@3:
  007e4	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  007e7	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  007ea	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  007ed	40		 inc	 eax
  007ee	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  007f1	8b ce		 mov	 ecx, esi
  007f3	d3 e2		 shl	 edx, cl
  007f5	8b 4f 58	 mov	 ecx, DWORD PTR [edi+88]
  007f8	b8 01 00 00 00	 mov	 eax, 1
  007fd	d3 e0		 shl	 eax, cl
  007ff	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
  00802	03 da		 add	 ebx, edx
  00804	83 c6 08	 add	 esi, 8
  00807	48		 dec	 eax
  00808	23 c3		 and	 eax, ebx
  0080a	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0080d	8b d0		 mov	 edx, eax
  0080f	c1 ea 08	 shr	 edx, 8
  00812	0f b6 ca	 movzx	 ecx, dl
  00815	3b ce		 cmp	 ecx, esi
  00817	77 ac		 ja	 SHORT $LL121@inflateBac@3

; 495  :                 if ((unsigned)(here.bits) <= bits) break;

  00819	8b 55 f4	 mov	 edx, DWORD PTR _put$[ebp]
$LN376@inflateBac@3:

; 497  :             }
; 498  :             if (here.op && (here.op & 0xf0) == 0) {

  0081c	84 c0		 test	 al, al
  0081e	0f 84 c3 00 00
	00		 je	 $LN96@inflateBac@3
  00824	a8 f0		 test	 al, 240			; 000000f0H
  00826	0f 85 bb 00 00
	00		 jne	 $LN96@inflateBac@3

; 499  :                 last = here;
; 500  :                 for (;;) {
; 501  :                     here = state->lencode[last.val +
; 502  :                             (BITS(last.bits + last.op) >> last.bits)];

  0082c	8b c8		 mov	 ecx, eax
  0082e	c1 e9 08	 shr	 ecx, 8
  00831	0f b6 d1	 movzx	 edx, cl
  00834	89 4d e4	 mov	 DWORD PTR tv1453[ebp], ecx
  00837	89 55 e8	 mov	 DWORD PTR tv1454[ebp], edx
  0083a	0f b6 c8	 movzx	 ecx, al
  0083d	03 ca		 add	 ecx, edx
  0083f	ba 01 00 00 00	 mov	 edx, 1
  00844	d3 e2		 shl	 edx, cl
  00846	8b 4d e8	 mov	 ecx, DWORD PTR tv1454[ebp]
  00849	89 45 ec	 mov	 DWORD PTR _last$[ebp], eax
  0084c	c1 e8 10	 shr	 eax, 16			; 00000010H
  0084f	4a		 dec	 edx
  00850	23 d3		 and	 edx, ebx
  00852	d3 ea		 shr	 edx, cl
  00854	03 d0		 add	 edx, eax
  00856	8b 47 50	 mov	 eax, DWORD PTR [edi+80]
  00859	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]

; 503  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  0085c	8b c8		 mov	 ecx, eax
  0085e	c1 e9 08	 shr	 ecx, 8
  00861	0f b6 d1	 movzx	 edx, cl
  00864	0f b6 4d e4	 movzx	 ecx, BYTE PTR tv1453[ebp]
  00868	03 d1		 add	 edx, ecx
  0086a	3b d6		 cmp	 edx, esi
  0086c	76 6a		 jbe	 SHORT $LN437@inflateBac@3
  0086e	8b ff		 npad	 2
$LL109@inflateBac@3:

; 504  :                     PULLBYTE();

  00870	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00874	75 19		 jne	 SHORT $LN102@inflateBac@3
  00876	8b 45 10	 mov	 eax, DWORD PTR _in_desc$[ebp]
  00879	8d 55 f8	 lea	 edx, DWORD PTR _next$[ebp]
  0087c	52		 push	 edx
  0087d	50		 push	 eax
  0087e	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00881	83 c4 08	 add	 esp, 8
  00884	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  00887	85 c0		 test	 eax, eax
  00889	0f 84 cf 03 00
	00		 je	 $LN363@inflateBac@3
$LN102@inflateBac@3:
  0088f	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00892	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00895	40		 inc	 eax
  00896	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  00899	8b 45 ec	 mov	 eax, DWORD PTR _last$[ebp]
  0089c	8b ce		 mov	 ecx, esi
  0089e	d3 e2		 shl	 edx, cl
  008a0	0f b6 c8	 movzx	 ecx, al
  008a3	03 da		 add	 ebx, edx
  008a5	0f b6 d4	 movzx	 edx, ah
  008a8	03 ca		 add	 ecx, edx
  008aa	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  008ad	b8 01 00 00 00	 mov	 eax, 1
  008b2	d3 e0		 shl	 eax, cl
  008b4	8b ca		 mov	 ecx, edx
  008b6	83 c6 08	 add	 esi, 8
  008b9	48		 dec	 eax
  008ba	23 c3		 and	 eax, ebx
  008bc	d3 e8		 shr	 eax, cl
  008be	0f b7 4d ee	 movzx	 ecx, WORD PTR _last$[ebp+2]
  008c2	03 c1		 add	 eax, ecx
  008c4	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
  008c7	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  008ca	8b c8		 mov	 ecx, eax
  008cc	c1 e9 08	 shr	 ecx, 8
  008cf	0f b6 c9	 movzx	 ecx, cl
  008d2	03 ca		 add	 ecx, edx
  008d4	3b ce		 cmp	 ecx, esi
  008d6	77 98		 ja	 SHORT $LL109@inflateBac@3
$LN437@inflateBac@3:

; 505  :                 }
; 506  :                 DROPBITS(last.bits);

  008d8	0f b6 4d ed	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  008dc	8b 55 f4	 mov	 edx, DWORD PTR _put$[ebp]
  008df	d3 eb		 shr	 ebx, cl
  008e1	0f b6 4d ed	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  008e5	2b f1		 sub	 esi, ecx
$LN96@inflateBac@3:

; 507  :             }
; 508  :             DROPBITS(here.bits);

  008e7	8b c8		 mov	 ecx, eax
  008e9	c1 e9 08	 shr	 ecx, 8
  008ec	0f b6 c9	 movzx	 ecx, cl
  008ef	d3 eb		 shr	 ebx, cl
  008f1	2b f1		 sub	 esi, ecx
  008f3	89 4d e8	 mov	 DWORD PTR tv1454[ebp], ecx

; 509  :             state->length = (unsigned)here.val;

  008f6	8b c8		 mov	 ecx, eax
  008f8	c1 e9 10	 shr	 ecx, 16			; 00000010H
  008fb	89 4f 44	 mov	 DWORD PTR [edi+68], ecx

; 510  : 
; 511  :             /* process literal */
; 512  :             if (here.op == 0) {

  008fe	84 c0		 test	 al, al
  00900	75 44		 jne	 SHORT $LN92@inflateBac@3

; 513  :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 514  :                         "inflate:         literal '%c'\n" :
; 515  :                         "inflate:         literal 0x%02x\n", here.val));
; 516  :                 ROOM();

  00902	83 7d f0 00	 cmp	 DWORD PTR _left$[ebp], 0
  00906	75 26		 jne	 SHORT $LN90@inflateBac@3
  00908	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  0090b	8b 4f 38	 mov	 ecx, DWORD PTR [edi+56]
  0090e	8b 55 18	 mov	 edx, DWORD PTR _out_desc$[ebp]
  00911	50		 push	 eax
  00912	51		 push	 ecx
  00913	52		 push	 edx
  00914	89 4d f4	 mov	 DWORD PTR _put$[ebp], ecx
  00917	89 45 f0	 mov	 DWORD PTR _left$[ebp], eax
  0091a	89 47 30	 mov	 DWORD PTR [edi+48], eax
  0091d	ff 55 14	 call	 DWORD PTR _out$[ebp]
  00920	83 c4 0c	 add	 esp, 12			; 0000000cH
  00923	85 c0		 test	 eax, eax
  00925	0f 85 3a 03 00
	00		 jne	 $LN366@inflateBac@3
  0092b	8b 55 f4	 mov	 edx, DWORD PTR _put$[ebp]
$LN90@inflateBac@3:

; 517  :                 *put++ = (unsigned char)(state->length);

  0092e	8a 47 44	 mov	 al, BYTE PTR [edi+68]
  00931	88 02		 mov	 BYTE PTR [edx], al
  00933	42		 inc	 edx

; 518  :                 left--;

  00934	ff 4d f0	 dec	 DWORD PTR _left$[ebp]
  00937	89 55 f4	 mov	 DWORD PTR _put$[ebp], edx

; 519  :                 state->mode = LEN;

  0093a	c7 47 04 48 3f
	00 00		 mov	 DWORD PTR [edi+4], 16200 ; 00003f48H

; 520  :                 break;

  00941	e9 02 03 00 00	 jmp	 $LN387@inflateBac@3
$LN92@inflateBac@3:

; 521  :             }
; 522  : 
; 523  :             /* process end of block */
; 524  :             if (here.op & 32) {

  00946	a8 20		 test	 al, 32			; 00000020H
  00948	74 0c		 je	 SHORT $LN86@inflateBac@3

; 525  :                 Tracevv((stderr, "inflate:         end of block\n"));
; 526  :                 state->mode = TYPE;

  0094a	c7 47 04 3f 3f
	00 00		 mov	 DWORD PTR [edi+4], 16191 ; 00003f3fH

; 527  :                 break;

  00951	e9 f2 02 00 00	 jmp	 $LN387@inflateBac@3
$LN86@inflateBac@3:

; 528  :             }
; 529  : 
; 530  :             /* invalid code */
; 531  :             if (here.op & 64) {

  00956	a8 40		 test	 al, 64			; 00000040H
  00958	74 16		 je	 SHORT $LN85@inflateBac@3

; 532  :                 strm->msg = (char *)"invalid literal/length code";

  0095a	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0095d	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@

; 533  :                 state->mode = BAD;

  00964	c7 47 04 51 3f
	00 00		 mov	 DWORD PTR [edi+4], 16209 ; 00003f51H

; 534  :                 break;

  0096b	e9 d8 02 00 00	 jmp	 $LN387@inflateBac@3
$LN85@inflateBac@3:

; 535  :             }
; 536  : 
; 537  :             /* length code -- get extra bits, if any */
; 538  :             state->extra = (unsigned)(here.op) & 15;

  00970	0f b6 c0	 movzx	 eax, al
  00973	83 e0 0f	 and	 eax, 15			; 0000000fH
  00976	89 47 4c	 mov	 DWORD PTR [edi+76], eax

; 539  :             if (state->extra != 0) {

  00979	74 56		 je	 SHORT $LN68@inflateBac@3

; 540  :                 NEEDBITS(state->extra);

  0097b	3b f0		 cmp	 esi, eax
  0097d	73 3e		 jae	 SHORT $LN82@inflateBac@3
  0097f	90		 npad	 1
$LL80@inflateBac@3:
  00980	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00984	75 19		 jne	 SHORT $LN74@inflateBac@3
  00986	8b 45 10	 mov	 eax, DWORD PTR _in_desc$[ebp]
  00989	8d 55 f8	 lea	 edx, DWORD PTR _next$[ebp]
  0098c	52		 push	 edx
  0098d	50		 push	 eax
  0098e	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00991	83 c4 08	 add	 esp, 8
  00994	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  00997	85 c0		 test	 eax, eax
  00999	0f 84 bf 02 00
	00		 je	 $LN363@inflateBac@3
$LN74@inflateBac@3:
  0099f	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  009a2	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  009a5	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  009a8	8b ce		 mov	 ecx, esi
  009aa	d3 e2		 shl	 edx, cl
  009ac	40		 inc	 eax
  009ad	83 c6 08	 add	 esi, 8
  009b0	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  009b3	03 da		 add	 ebx, edx
  009b5	3b 77 4c	 cmp	 esi, DWORD PTR [edi+76]
  009b8	72 c6		 jb	 SHORT $LL80@inflateBac@3
  009ba	8b 55 f4	 mov	 edx, DWORD PTR _put$[ebp]
$LN82@inflateBac@3:

; 541  :                 state->length += BITS(state->extra);

  009bd	8b 4f 4c	 mov	 ecx, DWORD PTR [edi+76]
  009c0	b8 01 00 00 00	 mov	 eax, 1
  009c5	d3 e0		 shl	 eax, cl
  009c7	48		 dec	 eax
  009c8	23 c3		 and	 eax, ebx
  009ca	01 47 44	 add	 DWORD PTR [edi+68], eax

; 542  :                 DROPBITS(state->extra);

  009cd	d3 eb		 shr	 ebx, cl
  009cf	2b f1		 sub	 esi, ecx
$LN68@inflateBac@3:

; 543  :             }
; 544  :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 545  : 
; 546  :             /* get distance code */
; 547  :             for (;;) {
; 548  :                 here = state->distcode[BITS(state->distbits)];

  009d1	8b 4f 5c	 mov	 ecx, DWORD PTR [edi+92]
  009d4	b8 01 00 00 00	 mov	 eax, 1
  009d9	d3 e0		 shl	 eax, cl
  009db	8b 4f 54	 mov	 ecx, DWORD PTR [edi+84]
  009de	48		 dec	 eax
  009df	23 c3		 and	 eax, ebx
  009e1	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 549  :                 if ((unsigned)(here.bits) <= bits) break;

  009e4	8b c8		 mov	 ecx, eax
  009e6	c1 e9 08	 shr	 ecx, 8
  009e9	0f b6 c9	 movzx	 ecx, cl
  009ec	3b ce		 cmp	 ecx, esi
  009ee	76 57		 jbe	 SHORT $LN381@inflateBac@3
$LL67@inflateBac@3:

; 550  :                 PULLBYTE();

  009f0	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  009f4	75 19		 jne	 SHORT $LN60@inflateBac@3
  009f6	8b 45 10	 mov	 eax, DWORD PTR _in_desc$[ebp]
  009f9	8d 55 f8	 lea	 edx, DWORD PTR _next$[ebp]
  009fc	52		 push	 edx
  009fd	50		 push	 eax
  009fe	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00a01	83 c4 08	 add	 esp, 8
  00a04	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  00a07	85 c0		 test	 eax, eax
  00a09	0f 84 4f 02 00
	00		 je	 $LN363@inflateBac@3
$LN60@inflateBac@3:
  00a0f	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00a12	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00a15	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00a18	40		 inc	 eax
  00a19	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  00a1c	8b ce		 mov	 ecx, esi
  00a1e	d3 e2		 shl	 edx, cl
  00a20	8b 4f 5c	 mov	 ecx, DWORD PTR [edi+92]
  00a23	b8 01 00 00 00	 mov	 eax, 1
  00a28	d3 e0		 shl	 eax, cl
  00a2a	8b 4f 54	 mov	 ecx, DWORD PTR [edi+84]
  00a2d	03 da		 add	 ebx, edx
  00a2f	83 c6 08	 add	 esi, 8
  00a32	48		 dec	 eax
  00a33	23 c3		 and	 eax, ebx
  00a35	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00a38	8b d0		 mov	 edx, eax
  00a3a	c1 ea 08	 shr	 edx, 8
  00a3d	0f b6 ca	 movzx	 ecx, dl
  00a40	3b ce		 cmp	 ecx, esi
  00a42	77 ac		 ja	 SHORT $LL67@inflateBac@3

; 549  :                 if ((unsigned)(here.bits) <= bits) break;

  00a44	8b 55 f4	 mov	 edx, DWORD PTR _put$[ebp]
$LN381@inflateBac@3:

; 551  :             }
; 552  :             if ((here.op & 0xf0) == 0) {

  00a47	a8 f0		 test	 al, 240			; 000000f0H
  00a49	0f 85 b9 00 00
	00		 jne	 $LN42@inflateBac@3

; 553  :                 last = here;
; 554  :                 for (;;) {
; 555  :                     here = state->distcode[last.val +
; 556  :                             (BITS(last.bits + last.op) >> last.bits)];

  00a4f	8b c8		 mov	 ecx, eax
  00a51	c1 e9 08	 shr	 ecx, 8
  00a54	0f b6 d1	 movzx	 edx, cl
  00a57	89 4d e4	 mov	 DWORD PTR tv1453[ebp], ecx
  00a5a	89 55 e8	 mov	 DWORD PTR tv1454[ebp], edx
  00a5d	0f b6 c8	 movzx	 ecx, al
  00a60	03 ca		 add	 ecx, edx
  00a62	ba 01 00 00 00	 mov	 edx, 1
  00a67	d3 e2		 shl	 edx, cl
  00a69	8b 4d e8	 mov	 ecx, DWORD PTR tv1454[ebp]
  00a6c	89 45 ec	 mov	 DWORD PTR _last$[ebp], eax
  00a6f	c1 e8 10	 shr	 eax, 16			; 00000010H
  00a72	4a		 dec	 edx
  00a73	23 d3		 and	 edx, ebx
  00a75	d3 ea		 shr	 edx, cl
  00a77	03 d0		 add	 edx, eax
  00a79	8b 47 54	 mov	 eax, DWORD PTR [edi+84]
  00a7c	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]

; 557  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00a7f	8b c8		 mov	 ecx, eax
  00a81	c1 e9 08	 shr	 ecx, 8
  00a84	0f b6 d1	 movzx	 edx, cl
  00a87	0f b6 4d e4	 movzx	 ecx, BYTE PTR tv1453[ebp]
  00a8b	03 d1		 add	 edx, ecx
  00a8d	3b d6		 cmp	 edx, esi
  00a8f	76 68		 jbe	 SHORT $LN439@inflateBac@3
$LL55@inflateBac@3:

; 558  :                     PULLBYTE();

  00a91	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00a95	75 19		 jne	 SHORT $LN48@inflateBac@3
  00a97	8b 45 10	 mov	 eax, DWORD PTR _in_desc$[ebp]
  00a9a	8d 55 f8	 lea	 edx, DWORD PTR _next$[ebp]
  00a9d	52		 push	 edx
  00a9e	50		 push	 eax
  00a9f	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00aa2	83 c4 08	 add	 esp, 8
  00aa5	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  00aa8	85 c0		 test	 eax, eax
  00aaa	0f 84 ae 01 00
	00		 je	 $LN363@inflateBac@3
$LN48@inflateBac@3:
  00ab0	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00ab3	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00ab6	40		 inc	 eax
  00ab7	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  00aba	8b 45 ec	 mov	 eax, DWORD PTR _last$[ebp]
  00abd	8b ce		 mov	 ecx, esi
  00abf	d3 e2		 shl	 edx, cl
  00ac1	0f b6 c8	 movzx	 ecx, al
  00ac4	03 da		 add	 ebx, edx
  00ac6	0f b6 d4	 movzx	 edx, ah
  00ac9	03 ca		 add	 ecx, edx
  00acb	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00ace	b8 01 00 00 00	 mov	 eax, 1
  00ad3	d3 e0		 shl	 eax, cl
  00ad5	8b ca		 mov	 ecx, edx
  00ad7	83 c6 08	 add	 esi, 8
  00ada	48		 dec	 eax
  00adb	23 c3		 and	 eax, ebx
  00add	d3 e8		 shr	 eax, cl
  00adf	0f b7 4d ee	 movzx	 ecx, WORD PTR _last$[ebp+2]
  00ae3	03 c1		 add	 eax, ecx
  00ae5	8b 4f 54	 mov	 ecx, DWORD PTR [edi+84]
  00ae8	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00aeb	8b c8		 mov	 ecx, eax
  00aed	c1 e9 08	 shr	 ecx, 8
  00af0	0f b6 c9	 movzx	 ecx, cl
  00af3	03 ca		 add	 ecx, edx
  00af5	3b ce		 cmp	 ecx, esi
  00af7	77 98		 ja	 SHORT $LL55@inflateBac@3
$LN439@inflateBac@3:

; 559  :                 }
; 560  :                 DROPBITS(last.bits);

  00af9	0f b6 4d ed	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  00afd	8b 55 f4	 mov	 edx, DWORD PTR _put$[ebp]
  00b00	d3 eb		 shr	 ebx, cl
  00b02	0f b6 4d ed	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  00b06	2b f1		 sub	 esi, ecx
$LN42@inflateBac@3:

; 561  :             }
; 562  :             DROPBITS(here.bits);

  00b08	8b c8		 mov	 ecx, eax
  00b0a	c1 e9 08	 shr	 ecx, 8
  00b0d	0f b6 c9	 movzx	 ecx, cl
  00b10	d3 eb		 shr	 ebx, cl
  00b12	2b f1		 sub	 esi, ecx
  00b14	89 4d e8	 mov	 DWORD PTR tv1454[ebp], ecx

; 563  :             if (here.op & 64) {

  00b17	a8 40		 test	 al, 64			; 00000040H
  00b19	74 16		 je	 SHORT $LN38@inflateBac@3

; 564  :                 strm->msg = (char *)"invalid distance code";

  00b1b	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00b1e	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@

; 565  :                 state->mode = BAD;

  00b25	c7 47 04 51 3f
	00 00		 mov	 DWORD PTR [edi+4], 16209 ; 00003f51H

; 566  :                 break;

  00b2c	e9 17 01 00 00	 jmp	 $LN387@inflateBac@3
$LN38@inflateBac@3:

; 567  :             }
; 568  :             state->offset = (unsigned)here.val;

  00b31	8b c8		 mov	 ecx, eax

; 569  : 
; 570  :             /* get distance extra bits, if any */
; 571  :             state->extra = (unsigned)(here.op) & 15;

  00b33	0f b6 c0	 movzx	 eax, al
  00b36	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00b39	83 e0 0f	 and	 eax, 15			; 0000000fH
  00b3c	89 4f 48	 mov	 DWORD PTR [edi+72], ecx
  00b3f	89 47 4c	 mov	 DWORD PTR [edi+76], eax

; 572  :             if (state->extra != 0) {

  00b42	74 55		 je	 SHORT $LN21@inflateBac@3

; 573  :                 NEEDBITS(state->extra);

  00b44	3b f0		 cmp	 esi, eax
  00b46	73 3d		 jae	 SHORT $LN35@inflateBac@3
$LL33@inflateBac@3:
  00b48	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00b4c	75 19		 jne	 SHORT $LN27@inflateBac@3
  00b4e	8b 45 10	 mov	 eax, DWORD PTR _in_desc$[ebp]
  00b51	8d 55 f8	 lea	 edx, DWORD PTR _next$[ebp]
  00b54	52		 push	 edx
  00b55	50		 push	 eax
  00b56	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00b59	83 c4 08	 add	 esp, 8
  00b5c	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  00b5f	85 c0		 test	 eax, eax
  00b61	0f 84 f7 00 00
	00		 je	 $LN363@inflateBac@3
$LN27@inflateBac@3:
  00b67	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00b6a	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00b6d	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00b70	8b ce		 mov	 ecx, esi
  00b72	d3 e2		 shl	 edx, cl
  00b74	40		 inc	 eax
  00b75	83 c6 08	 add	 esi, 8
  00b78	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  00b7b	03 da		 add	 ebx, edx
  00b7d	3b 77 4c	 cmp	 esi, DWORD PTR [edi+76]
  00b80	72 c6		 jb	 SHORT $LL33@inflateBac@3
  00b82	8b 55 f4	 mov	 edx, DWORD PTR _put$[ebp]
$LN35@inflateBac@3:

; 574  :                 state->offset += BITS(state->extra);

  00b85	8b 4f 4c	 mov	 ecx, DWORD PTR [edi+76]
  00b88	b8 01 00 00 00	 mov	 eax, 1
  00b8d	d3 e0		 shl	 eax, cl
  00b8f	48		 dec	 eax
  00b90	23 c3		 and	 eax, ebx
  00b92	01 47 48	 add	 DWORD PTR [edi+72], eax

; 575  :                 DROPBITS(state->extra);

  00b95	d3 eb		 shr	 ebx, cl
  00b97	2b f1		 sub	 esi, ecx
$LN21@inflateBac@3:

; 576  :             }
; 577  :             if (state->offset > state->wsize - (state->whave < state->wsize ?
; 578  :                                                 left : 0)) {

  00b99	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00b9c	39 47 30	 cmp	 DWORD PTR [edi+48], eax
  00b9f	1b c9		 sbb	 ecx, ecx
  00ba1	23 4d f0	 and	 ecx, DWORD PTR _left$[ebp]
  00ba4	2b c1		 sub	 eax, ecx
  00ba6	39 47 48	 cmp	 DWORD PTR [edi+72], eax
  00ba9	76 16		 jbe	 SHORT $LL19@inflateBac@3

; 579  :                 strm->msg = (char *)"invalid distance too far back";

  00bab	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00bae	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@

; 580  :                 state->mode = BAD;

  00bb5	c7 47 04 51 3f
	00 00		 mov	 DWORD PTR [edi+4], 16209 ; 00003f51H

; 581  :                 break;

  00bbc	e9 87 00 00 00	 jmp	 $LN387@inflateBac@3
$LL19@inflateBac@3:

; 582  :             }
; 583  :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 584  : 
; 585  :             /* copy match from window to output */
; 586  :             do {
; 587  :                 ROOM();

  00bc1	83 7d f0 00	 cmp	 DWORD PTR _left$[ebp], 0
  00bc5	75 26		 jne	 SHORT $LN15@inflateBac@3
  00bc7	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00bca	8b 4f 38	 mov	 ecx, DWORD PTR [edi+56]
  00bcd	50		 push	 eax
  00bce	89 45 f0	 mov	 DWORD PTR _left$[ebp], eax
  00bd1	89 47 30	 mov	 DWORD PTR [edi+48], eax
  00bd4	8b 45 18	 mov	 eax, DWORD PTR _out_desc$[ebp]
  00bd7	51		 push	 ecx
  00bd8	50		 push	 eax
  00bd9	89 4d f4	 mov	 DWORD PTR _put$[ebp], ecx
  00bdc	ff 55 14	 call	 DWORD PTR _out$[ebp]
  00bdf	83 c4 0c	 add	 esp, 12			; 0000000cH
  00be2	85 c0		 test	 eax, eax
  00be4	0f 85 7b 00 00
	00		 jne	 $LN366@inflateBac@3
  00bea	8b 55 f4	 mov	 edx, DWORD PTR _put$[ebp]
$LN15@inflateBac@3:

; 588  :                 copy = state->wsize - state->offset;

  00bed	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  00bf0	2b 4f 48	 sub	 ecx, DWORD PTR [edi+72]

; 589  :                 if (copy < left) {

  00bf3	3b 4d f0	 cmp	 ecx, DWORD PTR _left$[ebp]
  00bf6	73 0d		 jae	 SHORT $LN11@inflateBac@3

; 590  :                     from = put + copy;

  00bf8	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  00bfb	89 45 e4	 mov	 DWORD PTR _from$[ebp], eax

; 591  :                     copy = left - copy;

  00bfe	8b 45 f0	 mov	 eax, DWORD PTR _left$[ebp]
  00c01	2b c1		 sub	 eax, ecx

; 592  :                 }
; 593  :                 else {

  00c03	eb 0b		 jmp	 SHORT $LN10@inflateBac@3
$LN11@inflateBac@3:

; 594  :                     from = put - state->offset;

  00c05	8b c2		 mov	 eax, edx
  00c07	2b 47 48	 sub	 eax, DWORD PTR [edi+72]
  00c0a	89 45 e4	 mov	 DWORD PTR _from$[ebp], eax

; 595  :                     copy = left;

  00c0d	8b 45 f0	 mov	 eax, DWORD PTR _left$[ebp]
$LN10@inflateBac@3:

; 596  :                 }
; 597  :                 if (copy > state->length) copy = state->length;

  00c10	8b 4f 44	 mov	 ecx, DWORD PTR [edi+68]
  00c13	3b c1		 cmp	 eax, ecx
  00c15	76 02		 jbe	 SHORT $LN9@inflateBac@3
  00c17	8b c1		 mov	 eax, ecx
$LN9@inflateBac@3:

; 598  :                 state->length -= copy;
; 599  :                 left -= copy;

  00c19	29 45 f0	 sub	 DWORD PTR _left$[ebp], eax
  00c1c	2b c8		 sub	 ecx, eax
  00c1e	89 4f 44	 mov	 DWORD PTR [edi+68], ecx

; 602  :                 } while (--copy);

  00c21	8b 4d e4	 mov	 ecx, DWORD PTR _from$[ebp]
  00c24	2b ca		 sub	 ecx, edx
  00c26	89 4d e4	 mov	 DWORD PTR tv1944[ebp], ecx
  00c29	eb 08		 jmp	 SHORT $LN8@inflateBac@3
  00c2b	eb 03 8d 49 00	 npad	 5
$LL441@inflateBac@3:
  00c30	8b 4d e4	 mov	 ecx, DWORD PTR tv1944[ebp]
$LN8@inflateBac@3:

; 600  :                 do {
; 601  :                     *put++ = *from++;

  00c33	8a 0c 11	 mov	 cl, BYTE PTR [ecx+edx]
  00c36	88 0a		 mov	 BYTE PTR [edx], cl
  00c38	42		 inc	 edx

; 602  :                 } while (--copy);

  00c39	48		 dec	 eax
  00c3a	75 f4		 jne	 SHORT $LL441@inflateBac@3

; 603  :             } while (state->length != 0);

  00c3c	89 55 f4	 mov	 DWORD PTR _put$[ebp], edx
  00c3f	39 47 44	 cmp	 DWORD PTR [edi+68], eax
  00c42	0f 85 79 ff ff
	ff		 jne	 $LL19@inflateBac@3
$LN387@inflateBac@3:

; 284  :     hold = 0;
; 285  :     bits = 0;
; 286  :     put = state->window;
; 287  :     left = state->wsize;
; 288  : 
; 289  :     /* Inflate until end of block marked as last */
; 290  :     for (;;)
; 291  :         switch (state->mode) {

  00c48	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00c4b	2d 3f 3f 00 00	 sub	 eax, 16191		; 00003f3fH
  00c50	83 f8 12	 cmp	 eax, 18			; 00000012H
  00c53	0f 86 27 f4 ff
	ff		 jbe	 $LL418@inflateBac@3

; 513  :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 514  :                         "inflate:         literal '%c'\n" :
; 515  :                         "inflate:         literal 0x%02x\n", here.val));
; 516  :                 ROOM();

  00c59	e9 02 f4 ff ff	 jmp	 $LN1@inflateBac@3
$LN363@inflateBac@3:

; 298  :             }
; 299  :             NEEDBITS(3);

  00c5e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
$LN366@inflateBac@3:
  00c65	be fb ff ff ff	 mov	 esi, -5			; fffffffbH
  00c6a	e9 f6 f3 ff ff	 jmp	 $inf_leave$3865
$LN365@inflateBac@3:

; 343  :                 PULL();

  00c6f	89 5d f8	 mov	 DWORD PTR _next$[ebp], ebx
  00c72	be fb ff ff ff	 mov	 esi, -5			; fffffffbH
  00c77	e9 e9 f3 ff ff	 jmp	 $inf_leave$3865
$LN5@inflateBac@3:

; 604  :             break;
; 605  : 
; 606  :         case DONE:
; 607  :             /* inflate stream terminated properly -- write leftover output */
; 608  :             ret = Z_STREAM_END;
; 609  :             if (left < state->wsize) {

  00c7c	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00c7f	be 01 00 00 00	 mov	 esi, 1
  00c84	39 45 f0	 cmp	 DWORD PTR _left$[ebp], eax
  00c87	0f 83 d8 f3 ff
	ff		 jae	 $inf_leave$3865

; 610  :                 if (out(out_desc, state->window, state->wsize - left))

  00c8d	2b 45 f0	 sub	 eax, DWORD PTR _left$[ebp]
  00c90	8b 57 38	 mov	 edx, DWORD PTR [edi+56]
  00c93	50		 push	 eax
  00c94	8b 45 18	 mov	 eax, DWORD PTR _out_desc$[ebp]
  00c97	52		 push	 edx
  00c98	50		 push	 eax
  00c99	ff 55 14	 call	 DWORD PTR _out$[ebp]
  00c9c	83 c4 0c	 add	 esp, 12			; 0000000cH
  00c9f	85 c0		 test	 eax, eax
  00ca1	0f 84 be f3 ff
	ff		 je	 $inf_leave$3865

; 611  :                     ret = Z_BUF_ERROR;

  00ca7	be fb ff ff ff	 mov	 esi, -5			; fffffffbH

; 612  :             }
; 613  :             goto inf_leave;

  00cac	e9 b4 f3 ff ff	 jmp	 $inf_leave$3865
$LN2@inflateBac@3:

; 614  : 
; 615  :         case BAD:
; 616  :             ret = Z_DATA_ERROR;

  00cb1	be fd ff ff ff	 mov	 esi, -3			; fffffffdH

; 617  :             goto inf_leave;

  00cb6	e9 aa f3 ff ff	 jmp	 $inf_leave$3865
$LN333@inflateBac@3:
  00cbb	5f		 pop	 edi

; 274  :         return Z_STREAM_ERROR;

  00cbc	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00cc1	5e		 pop	 esi

; 629  : }

  00cc2	8b e5		 mov	 esp, ebp
  00cc4	5d		 pop	 ebp
  00cc5	c3		 ret	 0
  00cc6	8b ff		 npad	 2
$LN458@inflateBac@3:
  00cc8	00 00 00 00	 DD	 $LN328@inflateBac@3
  00ccc	00 00 00 00	 DD	 $LN297@inflateBac@3
  00cd0	00 00 00 00	 DD	 $LN262@inflateBac@3
  00cd4	00 00 00 00	 DD	 $LN130@inflateBac@3
  00cd8	00 00 00 00	 DD	 $LN5@inflateBac@3
  00cdc	00 00 00 00	 DD	 $LN2@inflateBac@3
  00ce0	00 00 00 00	 DD	 $LN1@inflateBac@3
$LN412@inflateBac@3:
  00ce4	00		 DB	 0
  00ce5	06		 DB	 6
  00ce6	01		 DB	 1
  00ce7	06		 DB	 6
  00ce8	06		 DB	 6
  00ce9	02		 DB	 2
  00cea	06		 DB	 6
  00ceb	06		 DB	 6
  00cec	06		 DB	 6
  00ced	03		 DB	 3
  00cee	06		 DB	 6
  00cef	06		 DB	 6
  00cf0	06		 DB	 6
  00cf1	06		 DB	 6
  00cf2	06		 DB	 6
  00cf3	06		 DB	 6
  00cf4	06		 DB	 6
  00cf5	04		 DB	 4
  00cf6	05		 DB	 5
  00cf7	90		 npad	 1
$LN459@inflateBac@3:
  00cf8	00 00 00 00	 DD	 $LN305@inflateBac@3
  00cfc	00 00 00 00	 DD	 $LN304@inflateBac@3
  00d00	00 00 00 00	 DD	 $LN303@inflateBac@3
  00d04	00 00 00 00	 DD	 $LN302@inflateBac@3
_inflateBack ENDP
END
