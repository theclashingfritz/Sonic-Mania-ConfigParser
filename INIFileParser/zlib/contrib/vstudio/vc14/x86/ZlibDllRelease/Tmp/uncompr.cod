; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\theclashingfritz\source\repos\INIFileParser\zlib\uncompr.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_uncompress2
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\uncompr.c
;	COMDAT _uncompress2
_TEXT	SEGMENT
_buf$ = -57						; size = 1
_stream$ = -56						; size = 56
_dest$ = 8						; size = 4
_destLen$ = 12						; size = 4
_source$ = 16						; size = 4
_sourceLen$ = 20					; size = 4
_uncompress2 PROC					; COMDAT

; 32   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H

; 33   :     z_stream stream;
; 34   :     int err;
; 35   :     const uInt max = (uInt)-1;
; 36   :     uLong len, left;
; 37   :     Byte buf[1];    /* for detection of incomplete stream when *destLen == 0 */
; 38   : 
; 39   :     len = *sourceLen;

  00006	8b 45 14	 mov	 eax, DWORD PTR _sourceLen$[ebp]

; 40   :     if (*destLen) {

  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _destLen$[ebp]
  0000c	83 ec 3c	 sub	 esp, 60			; 0000003cH
  0000f	53		 push	 ebx
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	8b 38		 mov	 edi, DWORD PTR [eax]
  00014	8b 01		 mov	 eax, DWORD PTR [ecx]
  00016	33 f6		 xor	 esi, esi
  00018	3b c6		 cmp	 eax, esi
  0001a	74 06		 je	 SHORT $LN11@uncompress

; 41   :         left = *destLen;

  0001c	8b d8		 mov	 ebx, eax

; 42   :         *destLen = 0;

  0001e	89 31		 mov	 DWORD PTR [ecx], esi

; 43   :     }
; 44   :     else {

  00020	eb 0c		 jmp	 SHORT $LN10@uncompress
$LN11@uncompress:

; 45   :         left = 1;
; 46   :         dest = buf;

  00022	8d 4c 24 0f	 lea	 ecx, DWORD PTR _buf$[esp+72]
  00026	bb 01 00 00 00	 mov	 ebx, 1
  0002b	89 4d 08	 mov	 DWORD PTR _dest$[ebp], ecx
$LN10@uncompress:

; 47   :     }
; 48   : 
; 49   :     stream.next_in = (z_const Bytef *)source;

  0002e	8b 55 10	 mov	 edx, DWORD PTR _source$[ebp]

; 50   :     stream.avail_in = 0;
; 51   :     stream.zalloc = (alloc_func)0;
; 52   :     stream.zfree = (free_func)0;
; 53   :     stream.opaque = (voidpf)0;
; 54   : 
; 55   :     err = inflateInit(&stream);

  00031	6a 38		 push	 56			; 00000038H
  00033	8d 44 24 14	 lea	 eax, DWORD PTR _stream$[esp+76]
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_06CJNJFBNP@1?42?411?$AA@
  0003c	50		 push	 eax
  0003d	89 54 24 1c	 mov	 DWORD PTR _stream$[esp+84], edx
  00041	89 74 24 20	 mov	 DWORD PTR _stream$[esp+88], esi
  00045	89 74 24 3c	 mov	 DWORD PTR _stream$[esp+116], esi
  00049	89 74 24 40	 mov	 DWORD PTR _stream$[esp+120], esi
  0004d	89 74 24 44	 mov	 DWORD PTR _stream$[esp+124], esi
  00051	e8 00 00 00 00	 call	 _inflateInit_
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH

; 56   :     if (err != Z_OK) return err;

  00059	3b c6		 cmp	 eax, esi
  0005b	0f 85 bf 00 00
	00		 jne	 $LN12@uncompress

; 57   : 
; 58   :     stream.next_out = dest;

  00061	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  00064	89 4c 24 1c	 mov	 DWORD PTR _stream$[esp+84], ecx

; 59   :     stream.avail_out = 0;

  00068	89 74 24 20	 mov	 DWORD PTR _stream$[esp+88], esi
  0006c	eb 04		 jmp	 SHORT $LN8@uncompress
  0006e	8b ff		 npad	 2
$LL25@uncompress:
  00070	33 f6		 xor	 esi, esi
$LN8@uncompress:

; 60   : 
; 61   :     do {
; 62   :         if (stream.avail_out == 0) {

  00072	39 74 24 20	 cmp	 DWORD PTR _stream$[esp+88], esi
  00076	75 12		 jne	 SHORT $LN5@uncompress

; 63   :             stream.avail_out = left > (uLong)max ? max : (uInt)left;

  00078	83 fb ff	 cmp	 ebx, -1
  0007b	76 05		 jbe	 SHORT $LN14@uncompress
  0007d	83 c8 ff	 or	 eax, -1
  00080	eb 02		 jmp	 SHORT $LN28@uncompress
$LN14@uncompress:
  00082	8b c3		 mov	 eax, ebx
$LN28@uncompress:
  00084	89 44 24 20	 mov	 DWORD PTR _stream$[esp+88], eax

; 64   :             left -= stream.avail_out;

  00088	2b d8		 sub	 ebx, eax
$LN5@uncompress:

; 65   :         }
; 66   :         if (stream.avail_in == 0) {

  0008a	39 74 24 14	 cmp	 DWORD PTR _stream$[esp+76], esi
  0008e	75 12		 jne	 SHORT $LN4@uncompress

; 67   :             stream.avail_in = len > (uLong)max ? max : (uInt)len;

  00090	83 ff ff	 cmp	 edi, -1
  00093	76 05		 jbe	 SHORT $LN16@uncompress
  00095	83 c8 ff	 or	 eax, -1
  00098	eb 02		 jmp	 SHORT $LN29@uncompress
$LN16@uncompress:
  0009a	8b c7		 mov	 eax, edi
$LN29@uncompress:
  0009c	89 44 24 14	 mov	 DWORD PTR _stream$[esp+76], eax

; 68   :             len -= stream.avail_in;

  000a0	2b f8		 sub	 edi, eax
$LN4@uncompress:

; 69   :         }
; 70   :         err = inflate(&stream, Z_NO_FLUSH);

  000a2	8d 54 24 10	 lea	 edx, DWORD PTR _stream$[esp+72]
  000a6	56		 push	 esi
  000a7	52		 push	 edx
  000a8	e8 00 00 00 00	 call	 _inflate
  000ad	8b f0		 mov	 esi, eax
  000af	83 c4 08	 add	 esp, 8

; 71   :     } while (err == Z_OK);

  000b2	85 f6		 test	 esi, esi
  000b4	74 ba		 je	 SHORT $LL25@uncompress

; 72   : 
; 73   :     *sourceLen -= len + stream.avail_in;

  000b6	8b 4c 24 14	 mov	 ecx, DWORD PTR _stream$[esp+76]
  000ba	8b 45 14	 mov	 eax, DWORD PTR _sourceLen$[ebp]
  000bd	03 cf		 add	 ecx, edi
  000bf	29 08		 sub	 DWORD PTR [eax], ecx

; 74   :     if (dest != buf)

  000c1	8d 54 24 0f	 lea	 edx, DWORD PTR _buf$[esp+72]
  000c5	39 55 08	 cmp	 DWORD PTR _dest$[ebp], edx
  000c8	74 0b		 je	 SHORT $LN3@uncompress

; 75   :         *destLen = stream.total_out;

  000ca	8b 44 24 24	 mov	 eax, DWORD PTR _stream$[esp+92]
  000ce	8b 4d 0c	 mov	 ecx, DWORD PTR _destLen$[ebp]
  000d1	89 01		 mov	 DWORD PTR [ecx], eax
  000d3	eb 0f		 jmp	 SHORT $LN1@uncompress
$LN3@uncompress:

; 76   :     else if (stream.total_out && err == Z_BUF_ERROR)

  000d5	83 7c 24 24 00	 cmp	 DWORD PTR _stream$[esp+92], 0
  000da	74 08		 je	 SHORT $LN1@uncompress
  000dc	83 fe fb	 cmp	 esi, -5			; fffffffbH
  000df	75 03		 jne	 SHORT $LN1@uncompress

; 77   :         left = 1;

  000e1	8d 5e 06	 lea	 ebx, DWORD PTR [esi+6]
$LN1@uncompress:

; 78   : 
; 79   :     inflateEnd(&stream);

  000e4	8d 54 24 10	 lea	 edx, DWORD PTR _stream$[esp+72]
  000e8	52		 push	 edx
  000e9	e8 00 00 00 00	 call	 _inflateEnd
  000ee	83 c4 04	 add	 esp, 4

; 80   :     return err == Z_STREAM_END ? Z_OK :
; 81   :            err == Z_NEED_DICT ? Z_DATA_ERROR  :
; 82   :            err == Z_BUF_ERROR && left + stream.avail_out ? Z_DATA_ERROR :
; 83   :            err;

  000f1	83 fe 01	 cmp	 esi, 1
  000f4	75 09		 jne	 SHORT $LN22@uncompress
  000f6	33 c0		 xor	 eax, eax

; 84   : }

  000f8	5f		 pop	 edi
  000f9	5e		 pop	 esi
  000fa	5b		 pop	 ebx
  000fb	8b e5		 mov	 esp, ebp
  000fd	5d		 pop	 ebp
  000fe	c3		 ret	 0
$LN22@uncompress:

; 80   :     return err == Z_STREAM_END ? Z_OK :
; 81   :            err == Z_NEED_DICT ? Z_DATA_ERROR  :
; 82   :            err == Z_BUF_ERROR && left + stream.avail_out ? Z_DATA_ERROR :
; 83   :            err;

  000ff	83 fe 02	 cmp	 esi, 2
  00102	75 0a		 jne	 SHORT $LN20@uncompress
  00104	8d 46 fb	 lea	 eax, DWORD PTR [esi-5]

; 84   : }

  00107	5f		 pop	 edi
  00108	5e		 pop	 esi
  00109	5b		 pop	 ebx
  0010a	8b e5		 mov	 esp, ebp
  0010c	5d		 pop	 ebp
  0010d	c3		 ret	 0
$LN20@uncompress:

; 80   :     return err == Z_STREAM_END ? Z_OK :
; 81   :            err == Z_NEED_DICT ? Z_DATA_ERROR  :
; 82   :            err == Z_BUF_ERROR && left + stream.avail_out ? Z_DATA_ERROR :
; 83   :            err;

  0010e	83 fe fb	 cmp	 esi, -5			; fffffffbH
  00111	75 0b		 jne	 SHORT $LN18@uncompress
  00113	8b 44 24 20	 mov	 eax, DWORD PTR _stream$[esp+88]
  00117	03 c3		 add	 eax, ebx
  00119	8d 46 02	 lea	 eax, DWORD PTR [esi+2]
  0011c	75 02		 jne	 SHORT $LN12@uncompress
$LN18@uncompress:
  0011e	8b c6		 mov	 eax, esi
$LN12@uncompress:

; 84   : }

  00120	5f		 pop	 edi
  00121	5e		 pop	 esi
  00122	5b		 pop	 ebx
  00123	8b e5		 mov	 esp, ebp
  00125	5d		 pop	 ebp
  00126	c3		 ret	 0
_uncompress2 ENDP
PUBLIC	_uncompress
; Function compile flags: /Ogtp
;	COMDAT _uncompress
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_destLen$ = 12						; size = 4
_source$ = 16						; size = 4
_sourceLen$ = 20					; size = 4
_uncompress PROC					; COMDAT

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 92   :     return uncompress2(dest, destLen, source, &sourceLen);

  00003	8b 4d 10	 mov	 ecx, DWORD PTR _source$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR _destLen$[ebp]
  00009	8d 45 14	 lea	 eax, DWORD PTR _sourceLen$[ebp]
  0000c	50		 push	 eax
  0000d	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  00010	51		 push	 ecx
  00011	52		 push	 edx
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _uncompress2
  00018	83 c4 10	 add	 esp, 16			; 00000010H

; 93   : }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
_uncompress ENDP
END
