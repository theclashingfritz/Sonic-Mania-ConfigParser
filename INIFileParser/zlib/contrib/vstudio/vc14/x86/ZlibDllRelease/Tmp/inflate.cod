; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\theclashingfritz\source\repos\INIFileParser\zlib\inflate.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ ; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@	; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ ; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@	; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ ; `string'
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ DB 'incorrect length che'
	DB	'ck', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ DB 'unknown header fl'
	DB	'ags set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ DB 'unknown compress'
	DB	'ion method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ DB 'incorrect header che'
	DB	'ck', 00H					; `string'
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\inflate.c
;	COMDAT _syncsearch
_TEXT	SEGMENT
_have$ = 8						; size = 4
_len$ = 12						; size = 4
_syncsearch PROC					; COMDAT
; _buf$ = esi

; 1381 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR _have$[ebp]

; 1382 :     unsigned got;
; 1383 :     unsigned next;
; 1384 : 
; 1385 :     got = *have;

  00006	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 1386 :     next = 0;

  00008	33 c0		 xor	 eax, eax

; 1387 :     while (next < len && got < 4) {

  0000a	39 45 0c	 cmp	 DWORD PTR _len$[ebp], eax
  0000d	76 41		 jbe	 SHORT $LN11@syncsearch
  0000f	53		 push	 ebx
  00010	57		 push	 edi
$LL6@syncsearch:
  00011	83 f9 04	 cmp	 ecx, 4
  00014	73 35		 jae	 SHORT $LN12@syncsearch

; 1388 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  00016	8a 14 30	 mov	 dl, BYTE PTR [eax+esi]
  00019	83 f9 02	 cmp	 ecx, 2
  0001c	1b ff		 sbb	 edi, edi
  0001e	81 e7 01 ff ff
	ff		 and	 edi, -255		; ffffff01H
  00024	0f b6 da	 movzx	 ebx, dl
  00027	81 c7 ff 00 00
	00		 add	 edi, 255		; 000000ffH
  0002d	3b df		 cmp	 ebx, edi
  0002f	75 03		 jne	 SHORT $LN4@syncsearch

; 1389 :             got++;

  00031	41		 inc	 ecx
  00032	eb 11		 jmp	 SHORT $LN1@syncsearch
$LN4@syncsearch:

; 1390 :         else if (buf[next])

  00034	84 d2		 test	 dl, dl
  00036	74 04		 je	 SHORT $LN2@syncsearch

; 1391 :             got = 0;

  00038	33 c9		 xor	 ecx, ecx

; 1392 :         else

  0003a	eb 09		 jmp	 SHORT $LN1@syncsearch
$LN2@syncsearch:

; 1393 :             got = 4 - got;

  0003c	ba 04 00 00 00	 mov	 edx, 4
  00041	2b d1		 sub	 edx, ecx
  00043	8b ca		 mov	 ecx, edx
$LN1@syncsearch:

; 1394 :         next++;

  00045	40		 inc	 eax
  00046	3b 45 0c	 cmp	 eax, DWORD PTR _len$[ebp]
  00049	72 c6		 jb	 SHORT $LL6@syncsearch
$LN12@syncsearch:

; 1395 :     }
; 1396 :     *have = got;

  0004b	8b 55 08	 mov	 edx, DWORD PTR _have$[ebp]
  0004e	5f		 pop	 edi
  0004f	5b		 pop	 ebx
$LN11@syncsearch:
  00050	89 0a		 mov	 DWORD PTR [edx], ecx

; 1397 :     return next;
; 1398 : }

  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
_syncsearch ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _updatewindow
_TEXT	SEGMENT
_end$ = 8						; size = 4
_updatewindow PROC					; COMDAT
; _strm$ = eax
; _copy$ = ecx

; 400  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 401  :     struct inflate_state FAR *state;
; 402  :     unsigned dist;
; 403  : 
; 404  :     state = (struct inflate_state FAR *)strm->state;

  00005	8b 70 1c	 mov	 esi, DWORD PTR [eax+28]
  00008	57		 push	 edi

; 405  : 
; 406  :     /* if it hasn't been done already, allocate space for the window */
; 407  :     if (state->window == Z_NULL) {

  00009	33 ff		 xor	 edi, edi
  0000b	8b d9		 mov	 ebx, ecx
  0000d	39 7e 38	 cmp	 DWORD PTR [esi+56], edi
  00010	75 28		 jne	 SHORT $LN9@updatewind

; 408  :         state->window = (unsigned char FAR *)
; 409  :                         ZALLOC(strm, 1U << state->wbits,
; 410  :                                sizeof(unsigned char));

  00012	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  00015	ba 01 00 00 00	 mov	 edx, 1
  0001a	d3 e2		 shl	 edx, cl
  0001c	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0001f	6a 01		 push	 1
  00021	52		 push	 edx
  00022	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  00025	51		 push	 ecx
  00026	ff d2		 call	 edx
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002b	89 46 38	 mov	 DWORD PTR [esi+56], eax

; 411  :         if (state->window == Z_NULL) return 1;

  0002e	3b c7		 cmp	 eax, edi
  00030	75 08		 jne	 SHORT $LN9@updatewind
  00032	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 444  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN9@updatewind:

; 412  :     }
; 413  : 
; 414  :     /* if window not in use yet, initialize */
; 415  :     if (state->wsize == 0) {

  0003a	39 7e 2c	 cmp	 DWORD PTR [esi+44], edi
  0003d	75 13		 jne	 SHORT $LN8@updatewind

; 416  :         state->wsize = 1U << state->wbits;

  0003f	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  00042	b8 01 00 00 00	 mov	 eax, 1
  00047	d3 e0		 shl	 eax, cl

; 417  :         state->wnext = 0;

  00049	89 7e 34	 mov	 DWORD PTR [esi+52], edi

; 418  :         state->whave = 0;

  0004c	89 7e 30	 mov	 DWORD PTR [esi+48], edi
  0004f	89 46 2c	 mov	 DWORD PTR [esi+44], eax
$LN8@updatewind:

; 419  :     }
; 420  : 
; 421  :     /* copy state->wsize or less output bytes into the circular window */
; 422  :     if (copy >= state->wsize) {

  00052	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00055	3b d8		 cmp	 ebx, eax
  00057	72 23		 jb	 SHORT $LN7@updatewind

; 423  :         zmemcpy(state->window, end - state->wsize, state->wsize);

  00059	8b 4d 08	 mov	 ecx, DWORD PTR _end$[ebp]
  0005c	50		 push	 eax
  0005d	2b c8		 sub	 ecx, eax
  0005f	51		 push	 ecx
  00060	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  00063	51		 push	 ecx
  00064	e8 00 00 00 00	 call	 _memcpy

; 424  :         state->wnext = 0;
; 425  :         state->whave = state->wsize;

  00069	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006f	89 7e 34	 mov	 DWORD PTR [esi+52], edi
  00072	5f		 pop	 edi
  00073	89 56 30	 mov	 DWORD PTR [esi+48], edx
  00076	5e		 pop	 esi

; 441  :         }
; 442  :     }
; 443  :     return 0;

  00077	33 c0		 xor	 eax, eax
  00079	5b		 pop	 ebx

; 444  : }

  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
$LN7@updatewind:

; 426  :     }
; 427  :     else {
; 428  :         dist = state->wsize - state->wnext;

  0007c	2b 46 34	 sub	 eax, DWORD PTR [esi+52]
  0007f	8b f8		 mov	 edi, eax

; 429  :         if (dist > copy) dist = copy;

  00081	3b fb		 cmp	 edi, ebx
  00083	76 02		 jbe	 SHORT $LN5@updatewind
  00085	8b fb		 mov	 edi, ebx
$LN5@updatewind:

; 430  :         zmemcpy(state->window + state->wnext, end - copy, dist);

  00087	8b 45 08	 mov	 eax, DWORD PTR _end$[ebp]
  0008a	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  0008d	03 4e 34	 add	 ecx, DWORD PTR [esi+52]
  00090	57		 push	 edi
  00091	2b c3		 sub	 eax, ebx
  00093	50		 push	 eax
  00094	51		 push	 ecx
  00095	e8 00 00 00 00	 call	 _memcpy
  0009a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 431  :         copy -= dist;

  0009d	2b df		 sub	 ebx, edi

; 432  :         if (copy) {

  0009f	74 23		 je	 SHORT $LN4@updatewind

; 433  :             zmemcpy(state->window, end - copy, copy);

  000a1	8b 45 08	 mov	 eax, DWORD PTR _end$[ebp]
  000a4	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  000a7	53		 push	 ebx
  000a8	2b c3		 sub	 eax, ebx
  000aa	50		 push	 eax
  000ab	52		 push	 edx
  000ac	e8 00 00 00 00	 call	 _memcpy

; 434  :             state->wnext = copy;
; 435  :             state->whave = state->wsize;

  000b1	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000b4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b7	5f		 pop	 edi
  000b8	89 5e 34	 mov	 DWORD PTR [esi+52], ebx
  000bb	89 46 30	 mov	 DWORD PTR [esi+48], eax
  000be	5e		 pop	 esi

; 441  :         }
; 442  :     }
; 443  :     return 0;

  000bf	33 c0		 xor	 eax, eax
  000c1	5b		 pop	 ebx

; 444  : }

  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
$LN4@updatewind:

; 436  :         }
; 437  :         else {
; 438  :             state->wnext += dist;
; 439  :             if (state->wnext == state->wsize) state->wnext = 0;

  000c4	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000c7	01 7e 34	 add	 DWORD PTR [esi+52], edi
  000ca	39 46 34	 cmp	 DWORD PTR [esi+52], eax
  000cd	75 07		 jne	 SHORT $LN2@updatewind
  000cf	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0
$LN2@updatewind:

; 440  :             if (state->whave < state->wsize) state->whave += dist;

  000d6	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  000d9	3b c8		 cmp	 ecx, eax
  000db	73 05		 jae	 SHORT $LN1@updatewind
  000dd	03 cf		 add	 ecx, edi
  000df	89 4e 30	 mov	 DWORD PTR [esi+48], ecx
$LN1@updatewind:

; 441  :         }
; 442  :     }
; 443  :     return 0;

  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi
  000e4	33 c0		 xor	 eax, eax
  000e6	5b		 pop	 ebx

; 444  : }

  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
_updatewindow ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _fixedtables
_TEXT	SEGMENT
_fixedtables PROC					; COMDAT
; _state$ = eax

; 281  : #ifdef BUILDFIXED
; 282  :     static int virgin = 1;
; 283  :     static code *lenfix, *distfix;
; 284  :     static code fixed[544];
; 285  : 
; 286  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 287  :     if (virgin) {
; 288  :         unsigned sym, bits;
; 289  :         static code *next;
; 290  : 
; 291  :         /* literal/length table */
; 292  :         sym = 0;
; 293  :         while (sym < 144) state->lens[sym++] = 8;
; 294  :         while (sym < 256) state->lens[sym++] = 9;
; 295  :         while (sym < 280) state->lens[sym++] = 7;
; 296  :         while (sym < 288) state->lens[sym++] = 8;
; 297  :         next = fixed;
; 298  :         lenfix = next;
; 299  :         bits = 9;
; 300  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 301  : 
; 302  :         /* distance table */
; 303  :         sym = 0;
; 304  :         while (sym < 32) state->lens[sym++] = 5;
; 305  :         distfix = next;
; 306  :         bits = 5;
; 307  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 308  : 
; 309  :         /* do this just once */
; 310  :         virgin = 0;
; 311  :     }
; 312  : #else /* !BUILDFIXED */
; 313  : #   include "inffixed.h"
; 314  : #endif /* BUILDFIXED */
; 315  :     state->lencode = lenfix;

  00000	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], OFFSET ?lenfix@?1??fixedtables@@9@9

; 316  :     state->lenbits = 9;

  00007	c7 40 58 09 00
	00 00		 mov	 DWORD PTR [eax+88], 9

; 317  :     state->distcode = distfix;

  0000e	c7 40 54 00 00
	00 00		 mov	 DWORD PTR [eax+84], OFFSET ?distfix@?1??fixedtables@@9@9

; 318  :     state->distbits = 5;

  00015	c7 40 5c 05 00
	00 00		 mov	 DWORD PTR [eax+92], 5

; 319  : }

  0001c	c3		 ret	 0
_fixedtables ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _inflateStateCheck
_TEXT	SEGMENT
_inflateStateCheck PROC					; COMDAT
; _strm$ = eax

; 108  :     struct inflate_state FAR *state;
; 109  :     if (strm == Z_NULL ||
; 110  :         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)

  00000	85 c0		 test	 eax, eax
  00002	74 2d		 je	 SHORT $LN3@inflateSta
  00004	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00008	74 27		 je	 SHORT $LN3@inflateSta
  0000a	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  0000e	74 21		 je	 SHORT $LN3@inflateSta

; 112  :     state = (struct inflate_state FAR *)strm->state;

  00010	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]

; 113  :     if (state == Z_NULL || state->strm != strm ||
; 114  :         state->mode < HEAD || state->mode > SYNC)

  00013	85 c9		 test	 ecx, ecx
  00015	74 1a		 je	 SHORT $LN3@inflateSta
  00017	39 01		 cmp	 DWORD PTR [ecx], eax
  00019	75 16		 jne	 SHORT $LN3@inflateSta
  0001b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0001e	81 f9 34 3f 00
	00		 cmp	 ecx, 16180		; 00003f34H
  00024	7c 0b		 jl	 SHORT $LN3@inflateSta
  00026	81 f9 53 3f 00
	00		 cmp	 ecx, 16211		; 00003f53H
  0002c	7f 03		 jg	 SHORT $LN3@inflateSta

; 115  :         return 1;
; 116  :     return 0;

  0002e	33 c0		 xor	 eax, eax

; 117  : }

  00030	c3		 ret	 0
$LN3@inflateSta:

; 111  :         return 1;

  00031	b8 01 00 00 00	 mov	 eax, 1

; 117  : }

  00036	c3		 ret	 0
_inflateStateCheck ENDP
PUBLIC	_inflateCodesUsed
; Function compile flags: /Ogtp
;	COMDAT _inflateCodesUsed
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateCodesUsed PROC					; COMDAT

; 1556 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1557 :     struct inflate_state FAR *state;
; 1558 :     if (inflateStateCheck(strm)) return (unsigned long)-1;

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	8b c2		 mov	 eax, edx
  00008	e8 00 00 00 00	 call	 _inflateStateCheck
  0000d	85 c0		 test	 eax, eax
  0000f	74 05		 je	 SHORT $LN1@inflateCod
  00011	83 c8 ff	 or	 eax, -1

; 1561 : }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
$LN1@inflateCod:

; 1559 :     state = (struct inflate_state FAR *)strm->state;

  00016	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]

; 1560 :     return (unsigned long)(state->next - state->codes);

  00019	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  0001c	2b c1		 sub	 eax, ecx
  0001e	2d 34 05 00 00	 sub	 eax, 1332		; 00000534H
  00023	c1 f8 02	 sar	 eax, 2

; 1561 : }

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
_inflateCodesUsed ENDP
_TEXT	ENDS
PUBLIC	_inflateMark
; Function compile flags: /Ogtp
;	COMDAT _inflateMark
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateMark PROC					; COMDAT

; 1543 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1544 :     struct inflate_state FAR *state;
; 1545 : 
; 1546 :     if (inflateStateCheck(strm))

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	8b c2		 mov	 eax, edx
  00008	e8 00 00 00 00	 call	 _inflateStateCheck
  0000d	85 c0		 test	 eax, eax
  0000f	74 07		 je	 SHORT $LN1@inflateMar

; 1547 :         return -(1L << 16);

  00011	b8 00 00 ff ff	 mov	 eax, -65536		; ffff0000H

; 1552 : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
$LN1@inflateMar:

; 1548 :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]

; 1549 :     return (long)(((unsigned long)((long)state->back)) << 16) +
; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));

  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	81 f9 43 3f 00
	00		 cmp	 ecx, 16195		; 00003f43H
  00024	75 10		 jne	 SHORT $LN6@inflateMar
  00026	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00029	8b 80 c8 1b 00
	00		 mov	 eax, DWORD PTR [eax+7112]
  0002f	c1 e0 10	 shl	 eax, 16			; 00000010H
  00032	03 c1		 add	 eax, ecx

; 1552 : }

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
$LN6@inflateMar:

; 1549 :     return (long)(((unsigned long)((long)state->back)) << 16) +
; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));

  00036	81 f9 4c 3f 00
	00		 cmp	 ecx, 16204		; 00003f4cH
  0003c	75 16		 jne	 SHORT $LN4@inflateMar
  0003e	8b 88 cc 1b 00
	00		 mov	 ecx, DWORD PTR [eax+7116]
  00044	2b 48 44	 sub	 ecx, DWORD PTR [eax+68]
  00047	8b 80 c8 1b 00
	00		 mov	 eax, DWORD PTR [eax+7112]
  0004d	c1 e0 10	 shl	 eax, 16			; 00000010H
  00050	03 c1		 add	 eax, ecx

; 1552 : }

  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
$LN4@inflateMar:

; 1549 :     return (long)(((unsigned long)((long)state->back)) << 16) +
; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));

  00054	8b 80 c8 1b 00
	00		 mov	 eax, DWORD PTR [eax+7112]
  0005a	33 c9		 xor	 ecx, ecx
  0005c	c1 e0 10	 shl	 eax, 16			; 00000010H
  0005f	03 c1		 add	 eax, ecx

; 1552 : }

  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_inflateMark ENDP
_TEXT	ENDS
PUBLIC	_inflateValidate
; Function compile flags: /Ogtp
;	COMDAT _inflateValidate
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_check$ = 12						; size = 4
_inflateValidate PROC					; COMDAT

; 1529 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1530 :     struct inflate_state FAR *state;
; 1531 : 
; 1532 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	8b c2		 mov	 eax, edx
  00008	e8 00 00 00 00	 call	 _inflateStateCheck
  0000d	85 c0		 test	 eax, eax
  0000f	74 07		 je	 SHORT $LN3@inflateVal
  00011	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1539 : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
$LN3@inflateVal:

; 1533 :     state = (struct inflate_state FAR *)strm->state;
; 1534 :     if (check)

  00018	83 7d 0c 00	 cmp	 DWORD PTR _check$[ebp], 0
  0001c	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0001f	74 08		 je	 SHORT $LN2@inflateVal

; 1535 :         state->wrap |= 4;

  00021	83 48 0c 04	 or	 DWORD PTR [eax+12], 4

; 1538 :     return Z_OK;

  00025	33 c0		 xor	 eax, eax

; 1539 : }

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@inflateVal:

; 1536 :     else
; 1537 :         state->wrap &= ~4;

  00029	83 60 0c fb	 and	 DWORD PTR [eax+12], -5	; fffffffbH

; 1538 :     return Z_OK;

  0002d	33 c0		 xor	 eax, eax

; 1539 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_inflateValidate ENDP
_TEXT	ENDS
PUBLIC	_inflateUndermine
; Function compile flags: /Ogtp
;	COMDAT _inflateUndermine
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_subvert$ = 12						; size = 4
_inflateUndermine PROC					; COMDAT

; 1511 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1512 :     struct inflate_state FAR *state;
; 1513 : 
; 1514 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	8b c2		 mov	 eax, edx
  00008	e8 00 00 00 00	 call	 _inflateStateCheck
  0000d	85 c0		 test	 eax, eax
  0000f	74 07		 je	 SHORT $LN1@inflateUnd
  00011	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1523 : #endif
; 1524 : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
$LN1@inflateUnd:

; 1515 :     state = (struct inflate_state FAR *)strm->state;
; 1516 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1517 :     state->sane = !subvert;
; 1518 :     return Z_OK;
; 1519 : #else
; 1520 :     (void)subvert;
; 1521 :     state->sane = 1;

  00018	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0001b	c7 80 c4 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+7108], 1

; 1522 :     return Z_DATA_ERROR;

  00025	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 1523 : #endif
; 1524 : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
_inflateUndermine ENDP
_TEXT	ENDS
PUBLIC	_inflateCopy
; Function compile flags: /Ogtp
;	COMDAT _inflateCopy
_TEXT	SEGMENT
_copy$ = -8						; size = 4
_window$ = -4						; size = 4
_dest$ = 8						; size = 4
_source$ = 12						; size = 4
_inflateCopy PROC					; COMDAT

; 1464 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 1465 :     struct inflate_state FAR *state;
; 1466 :     struct inflate_state FAR *copy;
; 1467 :     unsigned char FAR *window;
; 1468 :     unsigned wsize;
; 1469 : 
; 1470 :     /* check input */
; 1471 :     if (inflateStateCheck(source) || dest == Z_NULL)

  00007	8b 75 0c	 mov	 esi, DWORD PTR _source$[ebp]
  0000a	8b c6		 mov	 eax, esi
  0000c	e8 00 00 00 00	 call	 _inflateStateCheck
  00011	85 c0		 test	 eax, eax
  00013	0f 85 1c 01 00
	00		 jne	 $LN6@inflateCop
  00019	39 45 08	 cmp	 DWORD PTR _dest$[ebp], eax
  0001c	0f 84 13 01 00
	00		 je	 $LN6@inflateCop

; 1473 :     state = (struct inflate_state FAR *)source->state;
; 1474 : 
; 1475 :     /* allocate space */
; 1476 :     copy = (struct inflate_state FAR *)
; 1477 :            ZALLOC(source, 1, sizeof(struct inflate_state));

  00022	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00025	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00028	53		 push	 ebx
  00029	8b 5e 1c	 mov	 ebx, DWORD PTR [esi+28]
  0002c	57		 push	 edi
  0002d	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  00032	6a 01		 push	 1
  00034	50		 push	 eax
  00035	ff d1		 call	 ecx
  00037	8b f8		 mov	 edi, eax
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003c	89 7d f8	 mov	 DWORD PTR _copy$[ebp], edi

; 1478 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  0003f	85 ff		 test	 edi, edi
  00041	74 3a		 je	 SHORT $LN12@inflateCop

; 1479 :     window = Z_NULL;
; 1480 :     if (state->window != Z_NULL) {

  00043	83 7b 38 00	 cmp	 DWORD PTR [ebx+56], 0
  00047	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _window$[ebp], 0
  0004e	74 39		 je	 SHORT $LN3@inflateCop

; 1481 :         window = (unsigned char FAR *)
; 1482 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));

  00050	8b 4b 28	 mov	 ecx, DWORD PTR [ebx+40]
  00053	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00056	ba 01 00 00 00	 mov	 edx, 1
  0005b	d3 e2		 shl	 edx, cl
  0005d	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00060	6a 01		 push	 1
  00062	52		 push	 edx
  00063	50		 push	 eax
  00064	ff d1		 call	 ecx
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	89 45 fc	 mov	 DWORD PTR _window$[ebp], eax

; 1483 :         if (window == Z_NULL) {

  0006c	85 c0		 test	 eax, eax
  0006e	75 19		 jne	 SHORT $LN3@inflateCop

; 1484 :             ZFREE(source, copy);

  00070	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  00073	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00076	57		 push	 edi
  00077	52		 push	 edx
  00078	ff d0		 call	 eax
  0007a	83 c4 08	 add	 esp, 8
$LN12@inflateCop:

; 1485 :             return Z_MEM_ERROR;

  0007d	5f		 pop	 edi
  0007e	5b		 pop	 ebx
  0007f	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00084	5e		 pop	 esi

; 1506 : }

  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
$LN3@inflateCop:

; 1486 :         }
; 1487 :     }
; 1488 : 
; 1489 :     /* copy state */
; 1490 :     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

  00089	8b 7d 08	 mov	 edi, DWORD PTR _dest$[ebp]
  0008c	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH

; 1491 :     zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));

  00091	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  00096	f3 a5		 rep movsd
  00098	8b 75 f8	 mov	 esi, DWORD PTR _copy$[ebp]
  0009b	53		 push	 ebx
  0009c	56		 push	 esi
  0009d	e8 00 00 00 00	 call	 _memcpy

; 1492 :     copy->strm = dest;

  000a2	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  000a5	89 0e		 mov	 DWORD PTR [esi], ecx

; 1493 :     if (state->lencode >= state->codes &&
; 1494 :         state->lencode <= state->codes + ENOUGH - 1) {

  000a7	8b 43 50	 mov	 eax, DWORD PTR [ebx+80]
  000aa	8d 93 34 05 00
	00		 lea	 edx, DWORD PTR [ebx+1332]
  000b0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b3	3b c2		 cmp	 eax, edx
  000b5	72 35		 jb	 SHORT $LN2@inflateCop
  000b7	8d 8b c0 1b 00
	00		 lea	 ecx, DWORD PTR [ebx+7104]
  000bd	3b c1		 cmp	 eax, ecx
  000bf	77 2b		 ja	 SHORT $LN2@inflateCop

; 1495 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  000c1	2b c3		 sub	 eax, ebx
  000c3	2d 34 05 00 00	 sub	 eax, 1332		; 00000534H
  000c8	c1 f8 02	 sar	 eax, 2
  000cb	8d 94 86 34 05
	00 00		 lea	 edx, DWORD PTR [esi+eax*4+1332]
  000d2	89 56 50	 mov	 DWORD PTR [esi+80], edx

; 1496 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  000d5	8b 43 54	 mov	 eax, DWORD PTR [ebx+84]
  000d8	2b c3		 sub	 eax, ebx
  000da	2d 34 05 00 00	 sub	 eax, 1332		; 00000534H
  000df	c1 f8 02	 sar	 eax, 2
  000e2	8d 8c 86 34 05
	00 00		 lea	 ecx, DWORD PTR [esi+eax*4+1332]
  000e9	89 4e 54	 mov	 DWORD PTR [esi+84], ecx
$LN2@inflateCop:

; 1497 :     }
; 1498 :     copy->next = copy->codes + (state->next - state->codes);

  000ec	8b 53 70	 mov	 edx, DWORD PTR [ebx+112]

; 1499 :     if (window != Z_NULL) {

  000ef	8b 7d fc	 mov	 edi, DWORD PTR _window$[ebp]
  000f2	2b d3		 sub	 edx, ebx
  000f4	81 ea 34 05 00
	00		 sub	 edx, 1332		; 00000534H
  000fa	c1 fa 02	 sar	 edx, 2
  000fd	8d 84 96 34 05
	00 00		 lea	 eax, DWORD PTR [esi+edx*4+1332]
  00104	89 46 70	 mov	 DWORD PTR [esi+112], eax
  00107	85 ff		 test	 edi, edi
  00109	74 18		 je	 SHORT $LN1@inflateCop

; 1500 :         wsize = 1U << state->wbits;

  0010b	8b 4b 28	 mov	 ecx, DWORD PTR [ebx+40]

; 1501 :         zmemcpy(window, state->window, wsize);

  0010e	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  00111	ba 01 00 00 00	 mov	 edx, 1
  00116	d3 e2		 shl	 edx, cl
  00118	52		 push	 edx
  00119	50		 push	 eax
  0011a	57		 push	 edi
  0011b	e8 00 00 00 00	 call	 _memcpy
  00120	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@inflateCop:

; 1502 :     }
; 1503 :     copy->window = window;
; 1504 :     dest->state = (struct internal_state FAR *)copy;

  00123	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  00126	89 7e 38	 mov	 DWORD PTR [esi+56], edi
  00129	5f		 pop	 edi
  0012a	5b		 pop	 ebx
  0012b	89 71 1c	 mov	 DWORD PTR [ecx+28], esi

; 1505 :     return Z_OK;

  0012e	33 c0		 xor	 eax, eax
  00130	5e		 pop	 esi

; 1506 : }

  00131	8b e5		 mov	 esp, ebp
  00133	5d		 pop	 ebp
  00134	c3		 ret	 0
$LN6@inflateCop:

; 1472 :         return Z_STREAM_ERROR;

  00135	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0013a	5e		 pop	 esi

; 1506 : }

  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c3		 ret	 0
_inflateCopy ENDP
_TEXT	ENDS
PUBLIC	_inflateSyncPoint
; Function compile flags: /Ogtp
;	COMDAT _inflateSyncPoint
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateSyncPoint PROC					; COMDAT

; 1453 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1454 :     struct inflate_state FAR *state;
; 1455 : 
; 1456 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	8b c2		 mov	 eax, edx
  00008	e8 00 00 00 00	 call	 _inflateStateCheck
  0000d	85 c0		 test	 eax, eax
  0000f	74 07		 je	 SHORT $LN1@inflateSyn
  00011	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1459 : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
$LN1@inflateSyn:

; 1457 :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]

; 1458 :     return state->mode == STORED && state->bits == 0;

  0001b	81 78 04 41 3f
	00 00		 cmp	 DWORD PTR [eax+4], 16193 ; 00003f41H
  00022	75 0d		 jne	 SHORT $LN4@inflateSyn
  00024	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  00028	75 07		 jne	 SHORT $LN4@inflateSyn
  0002a	b8 01 00 00 00	 mov	 eax, 1

; 1459 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
$LN4@inflateSyn:

; 1458 :     return state->mode == STORED && state->bits == 0;

  00031	33 c0		 xor	 eax, eax

; 1459 : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
_inflateSyncPoint ENDP
_TEXT	ENDS
PUBLIC	_inflateGetHeader
; Function compile flags: /Ogtp
;	COMDAT _inflateGetHeader
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_head$ = 12						; size = 4
_inflateGetHeader PROC					; COMDAT

; 1352 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1353 :     struct inflate_state FAR *state;
; 1354 : 
; 1355 :     /* check state */
; 1356 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	8b c2		 mov	 eax, edx
  00008	e8 00 00 00 00	 call	 _inflateStateCheck
  0000d	85 c0		 test	 eax, eax
  0000f	74 07		 je	 SHORT $LN2@inflateGet
$LN5@inflateGet:
  00011	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1364 : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
$LN2@inflateGet:

; 1357 :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]

; 1358 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  0001b	f6 40 0c 02	 test	 BYTE PTR [eax+12], 2
  0001f	74 f0		 je	 SHORT $LN5@inflateGet

; 1359 : 
; 1360 :     /* save header structure */
; 1361 :     state->head = head;

  00021	8b 4d 0c	 mov	 ecx, DWORD PTR _head$[ebp]
  00024	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 1362 :     head->done = 0;

  00027	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0

; 1363 :     return Z_OK;

  0002e	33 c0		 xor	 eax, eax

; 1364 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
_inflateGetHeader ENDP
_TEXT	ENDS
PUBLIC	_inflateGetDictionary
; Function compile flags: /Ogtp
;	COMDAT _inflateGetDictionary
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateGetDictionary PROC				; COMDAT

; 1295 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1296 :     struct inflate_state FAR *state;
; 1297 : 
; 1298 :     /* check state */
; 1299 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	8b c2		 mov	 eax, edx
  00008	e8 00 00 00 00	 call	 _inflateStateCheck
  0000d	85 c0		 test	 eax, eax
  0000f	74 07		 je	 SHORT $LN3@inflateGet@2
  00011	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1312 : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
$LN3@inflateGet@2:
  00018	56		 push	 esi

; 1300 :     state = (struct inflate_state FAR *)strm->state;

  00019	8b 72 1c	 mov	 esi, DWORD PTR [edx+28]

; 1301 : 
; 1302 :     /* copy dictionary */
; 1303 :     if (state->whave && dictionary != Z_NULL) {

  0001c	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0001f	85 c0		 test	 eax, eax
  00021	74 31		 je	 SHORT $LN2@inflateGet@2
  00023	57		 push	 edi
  00024	8b 7d 0c	 mov	 edi, DWORD PTR _dictionary$[ebp]
  00027	85 ff		 test	 edi, edi
  00029	74 28		 je	 SHORT $LN6@inflateGet@2

; 1304 :         zmemcpy(dictionary, state->window + state->wnext,
; 1305 :                 state->whave - state->wnext);

  0002b	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  0002e	2b c1		 sub	 eax, ecx
  00030	50		 push	 eax
  00031	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00034	03 c1		 add	 eax, ecx
  00036	50		 push	 eax
  00037	57		 push	 edi
  00038	e8 00 00 00 00	 call	 _memcpy

; 1306 :         zmemcpy(dictionary + state->whave - state->wnext,
; 1307 :                 state->window, state->wnext);

  0003d	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00040	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  00043	50		 push	 eax
  00044	2b f8		 sub	 edi, eax
  00046	03 7e 30	 add	 edi, DWORD PTR [esi+48]
  00049	51		 push	 ecx
  0004a	57		 push	 edi
  0004b	e8 00 00 00 00	 call	 _memcpy
  00050	83 c4 18	 add	 esp, 24			; 00000018H
$LN6@inflateGet@2:
  00053	5f		 pop	 edi
$LN2@inflateGet@2:

; 1308 :     }
; 1309 :     if (dictLength != Z_NULL)

  00054	8b 45 10	 mov	 eax, DWORD PTR _dictLength$[ebp]
  00057	85 c0		 test	 eax, eax
  00059	74 05		 je	 SHORT $LN1@inflateGet@2

; 1310 :         *dictLength = state->whave;

  0005b	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  0005e	89 10		 mov	 DWORD PTR [eax], edx
$LN1@inflateGet@2:

; 1311 :     return Z_OK;

  00060	33 c0		 xor	 eax, eax
  00062	5e		 pop	 esi

; 1312 : }

  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
_inflateGetDictionary ENDP
_TEXT	ENDS
PUBLIC	_inflateEnd
; Function compile flags: /Ogtp
;	COMDAT _inflateEnd
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateEnd PROC					; COMDAT

; 1279 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1280 :     struct inflate_state FAR *state;
; 1281 :     if (inflateStateCheck(strm))

  00004	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00007	8b c6		 mov	 eax, esi
  00009	e8 00 00 00 00	 call	 _inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 08		 je	 SHORT $LN2@inflateEnd

; 1282 :         return Z_STREAM_ERROR;

  00012	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00017	5e		 pop	 esi

; 1289 : }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
$LN2@inflateEnd:

; 1283 :     state = (struct inflate_state FAR *)strm->state;

  0001a	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]

; 1284 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  0001d	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  00020	85 c0		 test	 eax, eax
  00022	74 0d		 je	 SHORT $LN1@inflateEnd
  00024	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00027	50		 push	 eax
  00028	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  0002b	50		 push	 eax
  0002c	ff d1		 call	 ecx
  0002e	83 c4 08	 add	 esp, 8
$LN1@inflateEnd:

; 1285 :     ZFREE(strm, strm->state);

  00031	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  00034	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00037	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  0003a	52		 push	 edx
  0003b	50		 push	 eax
  0003c	ff d1		 call	 ecx
  0003e	83 c4 08	 add	 esp, 8

; 1286 :     strm->state = Z_NULL;

  00041	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0

; 1287 :     Tracev((stderr, "inflate: end\n"));
; 1288 :     return Z_OK;

  00048	33 c0		 xor	 eax, eax
  0004a	5e		 pop	 esi

; 1289 : }

  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
_inflateEnd ENDP
_TEXT	ENDS
PUBLIC	_inflatePrime
; Function compile flags: /Ogtp
;	COMDAT _inflatePrime
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_bits$ = 12						; size = 4
_value$ = 16						; size = 4
_inflatePrime PROC					; COMDAT

; 251  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 252  :     struct inflate_state FAR *state;
; 253  : 
; 254  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	8b c2		 mov	 eax, edx
  00008	e8 00 00 00 00	 call	 _inflateStateCheck
  0000d	85 c0		 test	 eax, eax
  0000f	74 07		 je	 SHORT $LN4@inflatePri
  00011	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 266  : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
$LN4@inflatePri:

; 255  :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]

; 256  :     if (bits < 0) {

  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR _bits$[ebp]
  0001e	33 d2		 xor	 edx, edx
  00020	3b ca		 cmp	 ecx, edx
  00022	7d 0a		 jge	 SHORT $LN3@inflatePri

; 257  :         state->hold = 0;

  00024	89 50 3c	 mov	 DWORD PTR [eax+60], edx

; 258  :         state->bits = 0;

  00027	89 50 40	 mov	 DWORD PTR [eax+64], edx

; 259  :         return Z_OK;

  0002a	33 c0		 xor	 eax, eax

; 266  : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
$LN3@inflatePri:
  0002e	56		 push	 esi

; 260  :     }
; 261  :     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;

  0002f	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00032	7f 27		 jg	 SHORT $LN1@inflatePri
  00034	8b 50 40	 mov	 edx, DWORD PTR [eax+64]
  00037	8d 34 0a	 lea	 esi, DWORD PTR [edx+ecx]
  0003a	83 fe 20	 cmp	 esi, 32			; 00000020H
  0003d	77 1c		 ja	 SHORT $LN1@inflatePri

; 262  :     value &= (1L << bits) - 1;

  0003f	57		 push	 edi
  00040	bf 01 00 00 00	 mov	 edi, 1
  00045	d3 e7		 shl	 edi, cl

; 263  :     state->hold += (unsigned)value << state->bits;

  00047	8b ca		 mov	 ecx, edx

; 264  :     state->bits += (uInt)bits;

  00049	89 70 40	 mov	 DWORD PTR [eax+64], esi
  0004c	4f		 dec	 edi
  0004d	23 7d 10	 and	 edi, DWORD PTR _value$[ebp]
  00050	d3 e7		 shl	 edi, cl
  00052	01 78 3c	 add	 DWORD PTR [eax+60], edi
  00055	5f		 pop	 edi

; 265  :     return Z_OK;

  00056	33 c0		 xor	 eax, eax
  00058	5e		 pop	 esi

; 266  : }

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
$LN1@inflatePri:

; 260  :     }
; 261  :     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;

  0005b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00060	5e		 pop	 esi

; 266  : }

  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_inflatePrime ENDP
_TEXT	ENDS
PUBLIC	_inflateResetKeep
; Function compile flags: /Ogtp
;	COMDAT _inflateResetKeep
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateResetKeep PROC					; COMDAT

; 121  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 122  :     struct inflate_state FAR *state;
; 123  : 
; 124  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	8b c2		 mov	 eax, edx
  00008	e8 00 00 00 00	 call	 _inflateStateCheck
  0000d	85 c0		 test	 eax, eax
  0000f	74 07		 je	 SHORT $LN2@inflateRes
  00011	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 142  : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
$LN2@inflateRes:

; 125  :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0001b	56		 push	 esi

; 126  :     strm->total_in = strm->total_out = state->total = 0;

  0001c	33 f6		 xor	 esi, esi
  0001e	89 70 20	 mov	 DWORD PTR [eax+32], esi
  00021	89 72 14	 mov	 DWORD PTR [edx+20], esi
  00024	89 72 08	 mov	 DWORD PTR [edx+8], esi

; 127  :     strm->msg = Z_NULL;

  00027	89 72 18	 mov	 DWORD PTR [edx+24], esi

; 128  :     if (state->wrap)        /* to support ill-conceived Java test suite */

  0002a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0002d	3b ce		 cmp	 ecx, esi
  0002f	74 06		 je	 SHORT $LN1@inflateRes

; 129  :         strm->adler = state->wrap & 1;

  00031	83 e1 01	 and	 ecx, 1
  00034	89 4a 30	 mov	 DWORD PTR [edx+48], ecx
$LN1@inflateRes:

; 130  :     state->mode = HEAD;
; 131  :     state->last = 0;
; 132  :     state->havedict = 0;
; 133  :     state->dmax = 32768U;
; 134  :     state->head = Z_NULL;
; 135  :     state->hold = 0;
; 136  :     state->bits = 0;
; 137  :     state->lencode = state->distcode = state->next = state->codes;

  00037	8d 88 34 05 00
	00		 lea	 ecx, DWORD PTR [eax+1332]
  0003d	89 70 08	 mov	 DWORD PTR [eax+8], esi
  00040	89 70 10	 mov	 DWORD PTR [eax+16], esi
  00043	89 70 24	 mov	 DWORD PTR [eax+36], esi
  00046	89 70 3c	 mov	 DWORD PTR [eax+60], esi
  00049	89 70 40	 mov	 DWORD PTR [eax+64], esi
  0004c	c7 40 04 34 3f
	00 00		 mov	 DWORD PTR [eax+4], 16180 ; 00003f34H
  00053	c7 40 18 00 80
	00 00		 mov	 DWORD PTR [eax+24], 32768 ; 00008000H
  0005a	89 48 70	 mov	 DWORD PTR [eax+112], ecx
  0005d	89 48 54	 mov	 DWORD PTR [eax+84], ecx
  00060	89 48 50	 mov	 DWORD PTR [eax+80], ecx

; 138  :     state->sane = 1;

  00063	c7 80 c4 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+7108], 1

; 139  :     state->back = -1;

  0006d	c7 80 c8 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+7112], -1

; 140  :     Tracev((stderr, "inflate: reset\n"));
; 141  :     return Z_OK;

  00077	33 c0		 xor	 eax, eax
  00079	5e		 pop	 esi

; 142  : }

  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
_inflateResetKeep ENDP
PUBLIC	_inflateSetDictionary
; Function compile flags: /Ogtp
;	COMDAT _inflateSetDictionary
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateSetDictionary PROC				; COMDAT

; 1318 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1319 :     struct inflate_state FAR *state;
; 1320 :     unsigned long dictid;
; 1321 :     int ret;
; 1322 : 
; 1323 :     /* check state */
; 1324 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	8b c2		 mov	 eax, edx
  00008	e8 00 00 00 00	 call	 _inflateStateCheck
  0000d	85 c0		 test	 eax, eax
  0000f	74 07		 je	 SHORT $LN5@inflateSet
  00011	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1347 : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
$LN5@inflateSet:
  00018	56		 push	 esi

; 1325 :     state = (struct inflate_state FAR *)strm->state;

  00019	8b 72 1c	 mov	 esi, DWORD PTR [edx+28]

; 1326 :     if (state->wrap != 0 && state->mode != DICT)

  0001c	83 7e 0c 00	 cmp	 DWORD PTR [esi+12], 0
  00020	b8 3e 3f 00 00	 mov	 eax, 16190		; 00003f3eH
  00025	74 0d		 je	 SHORT $LN4@inflateSet
  00027	39 46 04	 cmp	 DWORD PTR [esi+4], eax
  0002a	74 08		 je	 SHORT $LN4@inflateSet

; 1327 :         return Z_STREAM_ERROR;

  0002c	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00031	5e		 pop	 esi

; 1347 : }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
$LN4@inflateSet:
  00034	53		 push	 ebx

; 1328 : 
; 1329 :     /* check for correct dictionary identifier */
; 1330 :     if (state->mode == DICT) {

  00035	8b 5d 0c	 mov	 ebx, DWORD PTR _dictionary$[ebp]
  00038	57		 push	 edi
  00039	8b 7d 10	 mov	 edi, DWORD PTR _dictLength$[ebp]
  0003c	39 46 04	 cmp	 DWORD PTR [esi+4], eax
  0003f	75 2b		 jne	 SHORT $LN2@inflateSet

; 1331 :         dictid = adler32(0L, Z_NULL, 0);
; 1332 :         dictid = adler32(dictid, dictionary, dictLength);

  00041	57		 push	 edi
  00042	53		 push	 ebx
  00043	6a 00		 push	 0
  00045	6a 00		 push	 0
  00047	6a 00		 push	 0
  00049	e8 00 00 00 00	 call	 _adler32
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 _adler32
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1333 :         if (dictid != state->check)

  0005a	3b 46 1c	 cmp	 eax, DWORD PTR [esi+28]
  0005d	74 0a		 je	 SHORT $LN8@inflateSet

; 1334 :             return Z_DATA_ERROR;

  0005f	5f		 pop	 edi
  00060	5b		 pop	 ebx
  00061	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00066	5e		 pop	 esi

; 1347 : }

  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
$LN8@inflateSet:

; 1333 :         if (dictid != state->check)

  00069	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
$LN2@inflateSet:

; 1335 :     }
; 1336 : 
; 1337 :     /* copy dictionary to window using updatewindow(), which will amend the
; 1338 :        existing dictionary if appropriate */
; 1339 :     ret = updatewindow(strm, dictionary + dictLength, dictLength);

  0006c	03 df		 add	 ebx, edi
  0006e	53		 push	 ebx
  0006f	8b cf		 mov	 ecx, edi
  00071	8b c2		 mov	 eax, edx
  00073	e8 00 00 00 00	 call	 _updatewindow
  00078	83 c4 04	 add	 esp, 4

; 1340 :     if (ret) {

  0007b	85 c0		 test	 eax, eax
  0007d	74 11		 je	 SHORT $LN1@inflateSet

; 1341 :         state->mode = MEM;

  0007f	5f		 pop	 edi
  00080	5b		 pop	 ebx
  00081	c7 46 04 52 3f
	00 00		 mov	 DWORD PTR [esi+4], 16210 ; 00003f52H

; 1342 :         return Z_MEM_ERROR;

  00088	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0008d	5e		 pop	 esi

; 1347 : }

  0008e	5d		 pop	 ebp
  0008f	c3		 ret	 0
$LN1@inflateSet:
  00090	5f		 pop	 edi
  00091	5b		 pop	 ebx

; 1343 :     }
; 1344 :     state->havedict = 1;

  00092	c7 46 10 01 00
	00 00		 mov	 DWORD PTR [esi+16], 1

; 1345 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1346 :     return Z_OK;

  00099	33 c0		 xor	 eax, eax
  0009b	5e		 pop	 esi

; 1347 : }

  0009c	5d		 pop	 ebp
  0009d	c3		 ret	 0
_inflateSetDictionary ENDP
_TEXT	ENDS
PUBLIC	_inflate
; Function compile flags: /Ogtp
;	COMDAT _inflate
_TEXT	SEGMENT
_in$ = -48						; size = 4
tv3179 = -44						; size = 4
tv2460 = -44						; size = 4
tv2456 = -44						; size = 4
tv2435 = -44						; size = 4
tv2420 = -44						; size = 4
tv2305 = -44						; size = 4
tv2289 = -44						; size = 4
tv2266 = -44						; size = 4
tv1426 = -44						; size = 4
_from$ = -44						; size = 4
_ret$ = -40						; size = 4
tv2446 = -36						; size = 4
tv2263 = -36						; size = 4
_last$ = -36						; size = 4
_out$ = -32						; size = 4
tv2519 = -28						; size = 4
tv2458 = -28						; size = 4
tv2454 = -28						; size = 4
tv2421 = -28						; size = 4
_len$ = -28						; size = 4
_put$ = -24						; size = 4
_hbuf$ = -20						; size = 4
_left$ = -16						; size = 4
_here$ = -12						; size = 4
_copy$ = -12						; size = 4
_next$ = -8						; size = 4
_have$ = -4						; size = 4
_strm$ = 8						; size = 4
_flush$ = 12						; size = 4
_inflate PROC						; COMDAT

; 625  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 626  :     struct inflate_state FAR *state;
; 627  :     z_const unsigned char FAR *next;    /* next input */
; 628  :     unsigned char FAR *put;     /* next output */
; 629  :     unsigned have, left;        /* available input and output */
; 630  :     unsigned long hold;         /* bit buffer */
; 631  :     unsigned bits;              /* bits in bit buffer */
; 632  :     unsigned in, out;           /* save starting available input and output */
; 633  :     unsigned copy;              /* number of stored or match bytes to copy */
; 634  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 635  :     code here;                  /* current decoding table entry */
; 636  :     code last;                  /* parent table entry */
; 637  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 638  :     int ret;                    /* return code */
; 639  : #ifdef GUNZIP
; 640  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 641  : #endif
; 642  :     static const unsigned short order[19] = /* permutation of code lengths */
; 643  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 644  : 
; 645  :     if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||
; 646  :         (strm->next_in == Z_NULL && strm->avail_in != 0))

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	83 ec 30	 sub	 esp, 48			; 00000030H
  00009	8b c2		 mov	 eax, edx
  0000b	e8 00 00 00 00	 call	 _inflateStateCheck
  00010	85 c0		 test	 eax, eax
  00012	0f 85 20 15 00
	00		 jne	 $LN499@inflate
  00018	39 42 0c	 cmp	 DWORD PTR [edx+12], eax
  0001b	0f 84 17 15 00
	00		 je	 $LN499@inflate
  00021	39 02		 cmp	 DWORD PTR [edx], eax
  00023	75 09		 jne	 SHORT $LN500@inflate
  00025	39 42 04	 cmp	 DWORD PTR [edx+4], eax
  00028	0f 85 0a 15 00
	00		 jne	 $LN499@inflate
$LN500@inflate:
  0002e	56		 push	 esi

; 648  : 
; 649  :     state = (struct inflate_state FAR *)strm->state;

  0002f	8b 72 1c	 mov	 esi, DWORD PTR [edx+28]

; 650  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  00032	81 7e 04 3f 3f
	00 00		 cmp	 DWORD PTR [esi+4], 16191 ; 00003f3fH
  00039	75 07		 jne	 SHORT $LN497@inflate
  0003b	c7 46 04 40 3f
	00 00		 mov	 DWORD PTR [esi+4], 16192 ; 00003f40H
$LN497@inflate:

; 651  :     LOAD();

  00042	8b c2		 mov	 eax, edx
  00044	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00047	8b 10		 mov	 edx, DWORD PTR [eax]
  00049	89 4d e8	 mov	 DWORD PTR _put$[ebp], ecx
  0004c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0004f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00052	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax

; 652  :     in = have;

  00055	89 45 d0	 mov	 DWORD PTR _in$[ebp], eax

; 653  :     out = left;
; 654  :     ret = Z_OK;
; 655  :     for (;;)
; 656  :         switch (state->mode) {

  00058	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0005b	53		 push	 ebx
  0005c	8b 5e 3c	 mov	 ebx, DWORD PTR [esi+60]
  0005f	2d 34 3f 00 00	 sub	 eax, 16180		; 00003f34H
  00064	57		 push	 edi
  00065	8b 7e 40	 mov	 edi, DWORD PTR [esi+64]
  00068	89 4d f0	 mov	 DWORD PTR _left$[ebp], ecx
  0006b	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  0006e	89 4d e0	 mov	 DWORD PTR _out$[ebp], ecx
  00071	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0
  00078	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  0007b	0f 87 2e 13 00
	00		 ja	 $LN12@inflate
$LL494@inflate:
  00081	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN789@inflate[eax*4]
$LN490@inflate:

; 657  :         case HEAD:
; 658  :             if (state->wrap == 0) {

  00088	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0008b	85 c0		 test	 eax, eax
  0008d	75 0c		 jne	 SHORT $LN488@inflate

; 659  :                 state->mode = TYPEDO;

  0008f	c7 46 04 40 3f
	00 00		 mov	 DWORD PTR [esi+4], 16192 ; 00003f40H

; 660  :                 break;

  00096	e9 03 13 00 00	 jmp	 $LN491@inflate
$LN488@inflate:

; 661  :             }
; 662  :             NEEDBITS(16);

  0009b	83 ff 10	 cmp	 edi, 16			; 00000010H
  0009e	73 22		 jae	 SHORT $LN487@inflate
$LL485@inflate:
  000a0	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  000a4	0f 84 55 13 00
	00		 je	 $inf_leave$3959
  000aa	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000ad	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  000b0	8b cf		 mov	 ecx, edi
  000b2	d3 e0		 shl	 eax, cl
  000b4	42		 inc	 edx
  000b5	83 c7 08	 add	 edi, 8
  000b8	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  000bb	03 d8		 add	 ebx, eax
  000bd	83 ff 10	 cmp	 edi, 16			; 00000010H
  000c0	72 de		 jb	 SHORT $LL485@inflate
$LN487@inflate:

; 663  : #ifdef GUNZIP
; 664  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  000c2	f6 46 0c 02	 test	 BYTE PTR [esi+12], 2
  000c6	74 4e		 je	 SHORT $LN479@inflate
  000c8	81 fb 1f 8b 00
	00		 cmp	 ebx, 35615		; 00008b1fH
  000ce	75 46		 jne	 SHORT $LN479@inflate

; 665  :                 if (state->wbits == 0)

  000d0	83 7e 28 00	 cmp	 DWORD PTR [esi+40], 0
  000d4	75 07		 jne	 SHORT $LN478@inflate

; 666  :                     state->wbits = 15;

  000d6	c7 46 28 0f 00
	00 00		 mov	 DWORD PTR [esi+40], 15	; 0000000fH
$LN478@inflate:

; 667  :                 state->check = crc32(0L, Z_NULL, 0);

  000dd	6a 00		 push	 0
  000df	6a 00		 push	 0
  000e1	6a 00		 push	 0
  000e3	e8 00 00 00 00	 call	 _crc32

; 668  :                 CRC2(state->check, hold);

  000e8	6a 02		 push	 2
  000ea	8d 4d ec	 lea	 ecx, DWORD PTR _hbuf$[ebp]
  000ed	51		 push	 ecx
  000ee	50		 push	 eax
  000ef	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  000f2	66 c7 45 ec 1f
	8b		 mov	 WORD PTR _hbuf$[ebp], 35615 ; 00008b1fH
  000f8	e8 00 00 00 00	 call	 _crc32

; 669  :                 INITBITS();
; 670  :                 state->mode = FLAGS;
; 671  :                 break;

  000fd	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  00100	83 c4 18	 add	 esp, 24			; 00000018H
  00103	33 db		 xor	 ebx, ebx
  00105	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  00108	33 ff		 xor	 edi, edi
  0010a	c7 46 04 35 3f
	00 00		 mov	 DWORD PTR [esi+4], 16181 ; 00003f35H
  00111	e9 88 12 00 00	 jmp	 $LN491@inflate
$LN479@inflate:

; 672  :             }
; 673  :             state->flags = 0;           /* expect zlib header */
; 674  :             if (state->head != Z_NULL)

  00116	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00119	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00120	85 c0		 test	 eax, eax
  00122	74 07		 je	 SHORT $LN471@inflate

; 675  :                 state->head->done = -1;

  00124	c7 40 30 ff ff
	ff ff		 mov	 DWORD PTR [eax+48], -1
$LN471@inflate:

; 676  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */
; 677  : #else
; 678  :             if (
; 679  : #endif
; 680  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {

  0012b	f6 46 0c 01	 test	 BYTE PTR [esi+12], 1
  0012f	0f 84 ab 00 00
	00		 je	 $LN469@inflate
  00135	0f b6 c3	 movzx	 eax, bl
  00138	c1 e0 08	 shl	 eax, 8
  0013b	8b d3		 mov	 edx, ebx
  0013d	c1 ea 08	 shr	 edx, 8
  00140	03 c2		 add	 eax, edx
  00142	33 d2		 xor	 edx, edx
  00144	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  00149	f7 f1		 div	 ecx
  0014b	85 d2		 test	 edx, edx
  0014d	0f 85 8d 00 00
	00		 jne	 $LN469@inflate

; 684  :             }
; 685  :             if (BITS(4) != Z_DEFLATED) {

  00153	8b d3		 mov	 edx, ebx
  00155	80 e2 0f	 and	 dl, 15			; 0000000fH
  00158	80 fa 08	 cmp	 dl, 8
  0015b	74 12		 je	 SHORT $LN467@inflate

; 686  :                 strm->msg = (char *)"unknown compression method";

  0015d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]

; 687  :                 state->mode = BAD;
; 688  :                 break;

  00160	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  00163	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
  0016a	e9 28 12 00 00	 jmp	 $LN788@inflate
$LN467@inflate:

; 689  :             }
; 690  :             DROPBITS(4);

  0016f	c1 eb 04	 shr	 ebx, 4

; 691  :             len = BITS(4) + 8;

  00172	8b cb		 mov	 ecx, ebx
  00174	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00177	83 ef 04	 sub	 edi, 4
  0017a	83 c1 08	 add	 ecx, 8

; 692  :             if (state->wbits == 0)

  0017d	83 7e 28 00	 cmp	 DWORD PTR [esi+40], 0
  00181	75 03		 jne	 SHORT $LN464@inflate

; 693  :                 state->wbits = len;

  00183	89 4e 28	 mov	 DWORD PTR [esi+40], ecx
$LN464@inflate:

; 694  :             if (len > 15 || len > state->wbits) {

  00186	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  00189	77 43		 ja	 SHORT $LN462@inflate
  0018b	3b 4e 28	 cmp	 ecx, DWORD PTR [esi+40]
  0018e	77 3e		 ja	 SHORT $LN462@inflate

; 698  :             }
; 699  :             state->dmax = 1U << len;

  00190	ba 01 00 00 00	 mov	 edx, 1
  00195	d3 e2		 shl	 edx, cl

; 700  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 701  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  00197	6a 00		 push	 0
  00199	6a 00		 push	 0
  0019b	6a 00		 push	 0
  0019d	89 56 18	 mov	 DWORD PTR [esi+24], edx
  001a0	e8 00 00 00 00	 call	 _adler32
  001a5	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]

; 702  :             state->mode = hold & 0x200 ? DICTID : TYPE;
; 703  :             INITBITS();
; 704  :             break;

  001a8	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  001ab	c1 eb 08	 shr	 ebx, 8
  001ae	f7 d3		 not	 ebx
  001b0	83 e3 02	 and	 ebx, 2
  001b3	81 cb 3d 3f 00
	00		 or	 ebx, 16189		; 00003f3dH
  001b9	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  001bc	89 41 30	 mov	 DWORD PTR [ecx+48], eax
  001bf	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  001c2	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c5	33 db		 xor	 ebx, ebx
  001c7	33 ff		 xor	 edi, edi
  001c9	e9 d0 11 00 00	 jmp	 $LN491@inflate
$LN462@inflate:

; 695  :                 strm->msg = (char *)"invalid window size";

  001ce	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  001d1	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@

; 696  :                 state->mode = BAD;
; 697  :                 break;

  001d8	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  001db	e9 b7 11 00 00	 jmp	 $LN788@inflate
$LN469@inflate:

; 681  :                 strm->msg = (char *)"incorrect header check";

  001e0	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]

; 682  :                 state->mode = BAD;
; 683  :                 break;

  001e3	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  001e6	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@
  001ed	e9 a5 11 00 00	 jmp	 $LN788@inflate
$LN457@inflate:

; 705  : #ifdef GUNZIP
; 706  :         case FLAGS:
; 707  :             NEEDBITS(16);

  001f2	83 ff 10	 cmp	 edi, 16			; 00000010H
  001f5	73 2b		 jae	 SHORT $LN456@inflate
  001f7	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL454@inflate:
  00200	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00204	0f 84 f5 11 00
	00		 je	 $inf_leave$3959
  0020a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0020d	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00210	8b cf		 mov	 ecx, edi
  00212	d3 e0		 shl	 eax, cl
  00214	42		 inc	 edx
  00215	83 c7 08	 add	 edi, 8
  00218	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  0021b	03 d8		 add	 ebx, eax
  0021d	83 ff 10	 cmp	 edi, 16			; 00000010H
  00220	72 de		 jb	 SHORT $LL454@inflate
$LN456@inflate:

; 708  :             state->flags = (int)(hold);

  00222	89 5e 14	 mov	 DWORD PTR [esi+20], ebx

; 709  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  00225	80 fb 08	 cmp	 bl, 8
  00228	74 0f		 je	 SHORT $LN448@inflate

; 710  :                 strm->msg = (char *)"unknown compression method";

  0022a	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0022d	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@

; 711  :                 state->mode = BAD;
; 712  :                 break;

  00234	e9 5e 11 00 00	 jmp	 $LN788@inflate
$LN448@inflate:

; 713  :             }
; 714  :             if (state->flags & 0xe000) {

  00239	f7 c3 00 e0 00
	00		 test	 ebx, 57344		; 0000e000H
  0023f	74 0f		 je	 SHORT $LN447@inflate

; 715  :                 strm->msg = (char *)"unknown header flags set";

  00241	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00244	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@

; 716  :                 state->mode = BAD;
; 717  :                 break;

  0024b	e9 47 11 00 00	 jmp	 $LN788@inflate
$LN447@inflate:

; 718  :             }
; 719  :             if (state->head != Z_NULL)

  00250	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00253	85 c0		 test	 eax, eax
  00255	74 0a		 je	 SHORT $LN446@inflate

; 720  :                 state->head->text = (int)((hold >> 8) & 1);

  00257	8b cb		 mov	 ecx, ebx
  00259	c1 e9 08	 shr	 ecx, 8
  0025c	83 e1 01	 and	 ecx, 1
  0025f	89 08		 mov	 DWORD PTR [eax], ecx
$LN446@inflate:

; 721  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  00261	f7 46 14 00 02
	00 00		 test	 DWORD PTR [esi+20], 512	; 00000200H
  00268	74 27		 je	 SHORT $LN442@inflate
  0026a	f6 46 0c 04	 test	 BYTE PTR [esi+12], 4
  0026e	74 21		 je	 SHORT $LN442@inflate

; 722  :                 CRC2(state->check, hold);

  00270	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00273	6a 02		 push	 2
  00275	8d 55 ec	 lea	 edx, DWORD PTR _hbuf$[ebp]
  00278	88 5d ec	 mov	 BYTE PTR _hbuf$[ebp], bl
  0027b	52		 push	 edx
  0027c	c1 eb 08	 shr	 ebx, 8
  0027f	50		 push	 eax
  00280	88 5d ed	 mov	 BYTE PTR _hbuf$[ebp+1], bl
  00283	e8 00 00 00 00	 call	 _crc32
  00288	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  0028b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0028e	89 46 1c	 mov	 DWORD PTR [esi+28], eax
$LN442@inflate:

; 723  :             INITBITS();

  00291	33 db		 xor	 ebx, ebx
  00293	33 ff		 xor	 edi, edi

; 724  :             state->mode = TIME;

  00295	c7 46 04 36 3f
	00 00		 mov	 DWORD PTR [esi+4], 16182 ; 00003f36H

; 725  :         case TIME:
; 726  :             NEEDBITS(32);

  0029c	eb 05		 jmp	 SHORT $LL434@inflate
$LN437@inflate:
  0029e	83 ff 20	 cmp	 edi, 32			; 00000020H
  002a1	73 22		 jae	 SHORT $LN436@inflate
$LL434@inflate:
  002a3	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  002a7	0f 84 52 11 00
	00		 je	 $inf_leave$3959
  002ad	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  002b0	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  002b3	8b cf		 mov	 ecx, edi
  002b5	d3 e0		 shl	 eax, cl
  002b7	42		 inc	 edx
  002b8	83 c7 08	 add	 edi, 8
  002bb	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  002be	03 d8		 add	 ebx, eax
  002c0	83 ff 20	 cmp	 edi, 32			; 00000020H
  002c3	72 de		 jb	 SHORT $LL434@inflate
$LN436@inflate:

; 727  :             if (state->head != Z_NULL)

  002c5	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  002c8	85 c0		 test	 eax, eax
  002ca	74 03		 je	 SHORT $LN428@inflate

; 728  :                 state->head->time = hold;

  002cc	89 58 04	 mov	 DWORD PTR [eax+4], ebx
$LN428@inflate:

; 729  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  002cf	f7 46 14 00 02
	00 00		 test	 DWORD PTR [esi+20], 512	; 00000200H
  002d6	74 37		 je	 SHORT $LN424@inflate
  002d8	f6 46 0c 04	 test	 BYTE PTR [esi+12], 4
  002dc	74 31		 je	 SHORT $LN424@inflate

; 730  :                 CRC4(state->check, hold);

  002de	8b cb		 mov	 ecx, ebx
  002e0	c1 e9 08	 shr	 ecx, 8
  002e3	6a 04		 push	 4
  002e5	8d 45 ec	 lea	 eax, DWORD PTR _hbuf$[ebp]
  002e8	88 4d ed	 mov	 BYTE PTR _hbuf$[ebp+1], cl
  002eb	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  002ee	8b d3		 mov	 edx, ebx
  002f0	88 5d ec	 mov	 BYTE PTR _hbuf$[ebp], bl
  002f3	50		 push	 eax
  002f4	c1 ea 10	 shr	 edx, 16			; 00000010H
  002f7	c1 eb 18	 shr	 ebx, 24			; 00000018H
  002fa	51		 push	 ecx
  002fb	88 55 ee	 mov	 BYTE PTR _hbuf$[ebp+2], dl
  002fe	88 5d ef	 mov	 BYTE PTR _hbuf$[ebp+3], bl
  00301	e8 00 00 00 00	 call	 _crc32
  00306	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  00309	83 c4 0c	 add	 esp, 12			; 0000000cH
  0030c	89 46 1c	 mov	 DWORD PTR [esi+28], eax
$LN424@inflate:

; 731  :             INITBITS();

  0030f	33 db		 xor	 ebx, ebx
  00311	33 ff		 xor	 edi, edi

; 732  :             state->mode = OS;

  00313	c7 46 04 37 3f
	00 00		 mov	 DWORD PTR [esi+4], 16183 ; 00003f37H

; 733  :         case OS:
; 734  :             NEEDBITS(16);

  0031a	eb 05		 jmp	 SHORT $LL416@inflate
$LN419@inflate:
  0031c	83 ff 10	 cmp	 edi, 16			; 00000010H
  0031f	73 22		 jae	 SHORT $LN418@inflate
$LL416@inflate:
  00321	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00325	0f 84 d4 10 00
	00		 je	 $inf_leave$3959
  0032b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0032e	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00331	8b cf		 mov	 ecx, edi
  00333	d3 e0		 shl	 eax, cl
  00335	42		 inc	 edx
  00336	83 c7 08	 add	 edi, 8
  00339	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  0033c	03 d8		 add	 ebx, eax
  0033e	83 ff 10	 cmp	 edi, 16			; 00000010H
  00341	72 de		 jb	 SHORT $LL416@inflate
$LN418@inflate:

; 735  :             if (state->head != Z_NULL) {

  00343	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00346	85 c0		 test	 eax, eax
  00348	74 16		 je	 SHORT $LN410@inflate

; 736  :                 state->head->xflags = (int)(hold & 0xff);

  0034a	8b cb		 mov	 ecx, ebx
  0034c	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00352	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 737  :                 state->head->os = (int)(hold >> 8);

  00355	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00358	8b c3		 mov	 eax, ebx
  0035a	c1 e8 08	 shr	 eax, 8
  0035d	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$LN410@inflate:

; 738  :             }
; 739  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  00360	f7 46 14 00 02
	00 00		 test	 DWORD PTR [esi+20], 512	; 00000200H
  00367	74 27		 je	 SHORT $LN406@inflate
  00369	f6 46 0c 04	 test	 BYTE PTR [esi+12], 4
  0036d	74 21		 je	 SHORT $LN406@inflate

; 740  :                 CRC2(state->check, hold);

  0036f	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00372	6a 02		 push	 2
  00374	8d 55 ec	 lea	 edx, DWORD PTR _hbuf$[ebp]
  00377	88 5d ec	 mov	 BYTE PTR _hbuf$[ebp], bl
  0037a	52		 push	 edx
  0037b	c1 eb 08	 shr	 ebx, 8
  0037e	50		 push	 eax
  0037f	88 5d ed	 mov	 BYTE PTR _hbuf$[ebp+1], bl
  00382	e8 00 00 00 00	 call	 _crc32
  00387	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  0038a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0038d	89 46 1c	 mov	 DWORD PTR [esi+28], eax
$LN406@inflate:

; 741  :             INITBITS();

  00390	33 db		 xor	 ebx, ebx
  00392	33 ff		 xor	 edi, edi

; 742  :             state->mode = EXLEN;

  00394	c7 46 04 38 3f
	00 00		 mov	 DWORD PTR [esi+4], 16184 ; 00003f38H
$LN709@inflate:

; 743  :         case EXLEN:
; 744  :             if (state->flags & 0x0400) {

  0039b	f7 46 14 00 04
	00 00		 test	 DWORD PTR [esi+20], 1024 ; 00000400H
  003a2	74 71		 je	 SHORT $LN401@inflate

; 745  :                 NEEDBITS(16);

  003a4	83 ff 10	 cmp	 edi, 16			; 00000010H
  003a7	73 29		 jae	 SHORT $LN399@inflate
  003a9	8d a4 24 00 00
	00 00		 npad	 7
$LL397@inflate:
  003b0	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  003b4	0f 84 45 10 00
	00		 je	 $inf_leave$3959
  003ba	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  003bd	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  003c0	8b cf		 mov	 ecx, edi
  003c2	d3 e0		 shl	 eax, cl
  003c4	42		 inc	 edx
  003c5	83 c7 08	 add	 edi, 8
  003c8	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  003cb	03 d8		 add	 ebx, eax
  003cd	83 ff 10	 cmp	 edi, 16			; 00000010H
  003d0	72 de		 jb	 SHORT $LL397@inflate
$LN399@inflate:

; 746  :                 state->length = (unsigned)(hold);
; 747  :                 if (state->head != Z_NULL)

  003d2	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  003d5	89 5e 44	 mov	 DWORD PTR [esi+68], ebx
  003d8	85 c0		 test	 eax, eax
  003da	74 03		 je	 SHORT $LN391@inflate

; 748  :                     state->head->extra_len = (unsigned)hold;

  003dc	89 58 14	 mov	 DWORD PTR [eax+20], ebx
$LN391@inflate:

; 749  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  003df	f7 46 14 00 02
	00 00		 test	 DWORD PTR [esi+20], 512	; 00000200H
  003e6	74 27		 je	 SHORT $LN387@inflate
  003e8	f6 46 0c 04	 test	 BYTE PTR [esi+12], 4
  003ec	74 21		 je	 SHORT $LN387@inflate

; 750  :                     CRC2(state->check, hold);

  003ee	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  003f1	6a 02		 push	 2
  003f3	8d 4d ec	 lea	 ecx, DWORD PTR _hbuf$[ebp]
  003f6	88 5d ec	 mov	 BYTE PTR _hbuf$[ebp], bl
  003f9	51		 push	 ecx
  003fa	c1 eb 08	 shr	 ebx, 8
  003fd	52		 push	 edx
  003fe	88 5d ed	 mov	 BYTE PTR _hbuf$[ebp+1], bl
  00401	e8 00 00 00 00	 call	 _crc32
  00406	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  00409	83 c4 0c	 add	 esp, 12			; 0000000cH
  0040c	89 46 1c	 mov	 DWORD PTR [esi+28], eax
$LN387@inflate:

; 751  :                 INITBITS();

  0040f	33 db		 xor	 ebx, ebx
  00411	33 ff		 xor	 edi, edi

; 752  :             }
; 753  :             else if (state->head != Z_NULL)

  00413	eb 0e		 jmp	 SHORT $LN382@inflate
$LN401@inflate:
  00415	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00418	85 c0		 test	 eax, eax
  0041a	74 07		 je	 SHORT $LN382@inflate

; 754  :                 state->head->extra = Z_NULL;

  0041c	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
$LN382@inflate:

; 755  :             state->mode = EXTRA;

  00423	c7 46 04 39 3f
	00 00		 mov	 DWORD PTR [esi+4], 16185 ; 00003f39H
$LN711@inflate:

; 756  :         case EXTRA:
; 757  :             if (state->flags & 0x0400) {

  0042a	f7 46 14 00 04
	00 00		 test	 DWORD PTR [esi+20], 1024 ; 00000400H
  00431	0f 84 a0 00 00
	00		 je	 $LN375@inflate

; 758  :                 copy = state->length;

  00437	8b 46 44	 mov	 eax, DWORD PTR [esi+68]

; 759  :                 if (copy > have) copy = have;

  0043a	8b 4d fc	 mov	 ecx, DWORD PTR _have$[ebp]
  0043d	89 45 f4	 mov	 DWORD PTR _copy$[ebp], eax
  00440	3b c1		 cmp	 eax, ecx
  00442	76 05		 jbe	 SHORT $LN379@inflate
  00444	8b c1		 mov	 eax, ecx
  00446	89 4d f4	 mov	 DWORD PTR _copy$[ebp], ecx
$LN379@inflate:

; 760  :                 if (copy) {

  00449	85 c0		 test	 eax, eax
  0044b	0f 84 7c 00 00
	00		 je	 $LN378@inflate

; 761  :                     if (state->head != Z_NULL &&
; 762  :                         state->head->extra != Z_NULL) {

  00451	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00454	85 c9		 test	 ecx, ecx
  00456	74 3e		 je	 SHORT $LN749@inflate
  00458	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0045b	89 4d d4	 mov	 DWORD PTR tv2266[ebp], ecx
  0045e	85 c9		 test	 ecx, ecx
  00460	74 34		 je	 SHORT $LN749@inflate

; 763  :                         len = state->head->extra_len - state->length;

  00462	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  00465	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  00468	2b 4e 44	 sub	 ecx, DWORD PTR [esi+68]

; 764  :                         zmemcpy(state->head->extra + len, next,
; 765  :                                 len + copy > state->head->extra_max ?
; 766  :                                 state->head->extra_max - len : copy);

  0046b	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  0046e	89 4d e4	 mov	 DWORD PTR _len$[ebp], ecx
  00471	03 c8		 add	 ecx, eax
  00473	3b ca		 cmp	 ecx, edx
  00475	76 05		 jbe	 SHORT $LN503@inflate
  00477	2b 55 e4	 sub	 edx, DWORD PTR _len$[ebp]
  0047a	8b c2		 mov	 eax, edx
$LN503@inflate:
  0047c	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  0047f	50		 push	 eax
  00480	8b 45 d4	 mov	 eax, DWORD PTR tv2266[ebp]
  00483	03 45 e4	 add	 eax, DWORD PTR _len$[ebp]
  00486	52		 push	 edx
  00487	50		 push	 eax
  00488	e8 00 00 00 00	 call	 _memcpy
  0048d	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  00490	8b 45 f4	 mov	 eax, DWORD PTR _copy$[ebp]
  00493	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN749@inflate:

; 767  :                     }
; 768  :                     if ((state->flags & 0x0200) && (state->wrap & 4))

  00496	f7 46 14 00 02
	00 00		 test	 DWORD PTR [esi+20], 512	; 00000200H
  0049d	74 23		 je	 SHORT $LN376@inflate
  0049f	f6 46 0c 04	 test	 BYTE PTR [esi+12], 4
  004a3	74 1d		 je	 SHORT $LN376@inflate

; 769  :                         state->check = crc32(state->check, next, copy);

  004a5	8b 55 f4	 mov	 edx, DWORD PTR _copy$[ebp]
  004a8	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  004ab	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  004ae	52		 push	 edx
  004af	50		 push	 eax
  004b0	51		 push	 ecx
  004b1	e8 00 00 00 00	 call	 _crc32
  004b6	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  004b9	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  004bc	8b 45 f4	 mov	 eax, DWORD PTR _copy$[ebp]
  004bf	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN376@inflate:

; 770  :                     have -= copy;

  004c2	29 45 fc	 sub	 DWORD PTR _have$[ebp], eax

; 771  :                     next += copy;

  004c5	03 d0		 add	 edx, eax

; 772  :                     state->length -= copy;

  004c7	29 46 44	 sub	 DWORD PTR [esi+68], eax
  004ca	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
$LN378@inflate:

; 773  :                 }
; 774  :                 if (state->length) goto inf_leave;

  004cd	83 7e 44 00	 cmp	 DWORD PTR [esi+68], 0
  004d1	0f 85 28 0f 00
	00		 jne	 $inf_leave$3959
$LN375@inflate:

; 775  :             }
; 776  :             state->length = 0;

  004d7	c7 46 44 00 00
	00 00		 mov	 DWORD PTR [esi+68], 0

; 777  :             state->mode = NAME;

  004de	c7 46 04 3a 3f
	00 00		 mov	 DWORD PTR [esi+4], 16186 ; 00003f3aH
$LN712@inflate:

; 778  :         case NAME:
; 779  :             if (state->flags & 0x0800) {

  004e5	f7 46 14 00 08
	00 00		 test	 DWORD PTR [esi+20], 2048 ; 00000800H
  004ec	0f 84 8f 00 00
	00		 je	 $LN373@inflate

; 780  :                 if (have == 0) goto inf_leave;

  004f2	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  004f6	0f 84 03 0f 00
	00		 je	 $inf_leave$3959

; 781  :                 copy = 0;

  004fc	33 c0		 xor	 eax, eax
  004fe	8b ff		 npad	 2
$LL371@inflate:

; 782  :                 do {
; 783  :                     len = (unsigned)(next[copy++]);

  00500	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00504	40		 inc	 eax
  00505	89 45 f4	 mov	 DWORD PTR _copy$[ebp], eax

; 784  :                     if (state->head != Z_NULL &&
; 785  :                             state->head->name != Z_NULL &&
; 786  :                             state->length < state->head->name_max)

  00508	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0050b	89 4d e4	 mov	 DWORD PTR _len$[ebp], ecx
  0050e	85 c0		 test	 eax, eax
  00510	74 21		 je	 SHORT $LN370@inflate
  00512	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00515	89 4d d4	 mov	 DWORD PTR tv2289[ebp], ecx
  00518	85 c9		 test	 ecx, ecx
  0051a	74 17		 je	 SHORT $LN370@inflate
  0051c	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  0051f	3b 48 20	 cmp	 ecx, DWORD PTR [eax+32]
  00522	73 0f		 jae	 SHORT $LN370@inflate

; 787  :                         state->head->name[state->length++] = (Bytef)len;

  00524	8b 55 d4	 mov	 edx, DWORD PTR tv2289[ebp]
  00527	8a 45 e4	 mov	 al, BYTE PTR _len$[ebp]
  0052a	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  0052d	ff 46 44	 inc	 DWORD PTR [esi+68]
  00530	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
$LN370@inflate:

; 788  :                 } while (len && copy < have);

  00533	83 7d e4 00	 cmp	 DWORD PTR _len$[ebp], 0
  00537	74 08		 je	 SHORT $LN367@inflate
  00539	8b 45 f4	 mov	 eax, DWORD PTR _copy$[ebp]
  0053c	3b 45 fc	 cmp	 eax, DWORD PTR _have$[ebp]
  0053f	72 bf		 jb	 SHORT $LL371@inflate
$LN367@inflate:

; 789  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  00541	f7 46 14 00 02
	00 00		 test	 DWORD PTR [esi+20], 512	; 00000200H
  00548	74 20		 je	 SHORT $LN366@inflate
  0054a	f6 46 0c 04	 test	 BYTE PTR [esi+12], 4
  0054e	74 1a		 je	 SHORT $LN366@inflate

; 790  :                     state->check = crc32(state->check, next, copy);

  00550	8b 4d f4	 mov	 ecx, DWORD PTR _copy$[ebp]
  00553	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  00556	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00559	51		 push	 ecx
  0055a	52		 push	 edx
  0055b	50		 push	 eax
  0055c	e8 00 00 00 00	 call	 _crc32
  00561	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  00564	83 c4 0c	 add	 esp, 12			; 0000000cH
  00567	89 46 1c	 mov	 DWORD PTR [esi+28], eax
$LN366@inflate:

; 791  :                 have -= copy;

  0056a	8b 45 f4	 mov	 eax, DWORD PTR _copy$[ebp]
  0056d	29 45 fc	 sub	 DWORD PTR _have$[ebp], eax

; 792  :                 next += copy;

  00570	03 d0		 add	 edx, eax

; 793  :                 if (len) goto inf_leave;

  00572	83 7d e4 00	 cmp	 DWORD PTR _len$[ebp], 0
  00576	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  00579	0f 85 80 0e 00
	00		 jne	 $inf_leave$3959

; 794  :             }
; 795  :             else if (state->head != Z_NULL)

  0057f	eb 0e		 jmp	 SHORT $LN363@inflate
$LN373@inflate:
  00581	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00584	85 c0		 test	 eax, eax
  00586	74 07		 je	 SHORT $LN363@inflate

; 796  :                 state->head->name = Z_NULL;

  00588	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
$LN363@inflate:

; 797  :             state->length = 0;

  0058f	c7 46 44 00 00
	00 00		 mov	 DWORD PTR [esi+68], 0

; 798  :             state->mode = COMMENT;

  00596	c7 46 04 3b 3f
	00 00		 mov	 DWORD PTR [esi+4], 16187 ; 00003f3bH
$LN716@inflate:

; 799  :         case COMMENT:
; 800  :             if (state->flags & 0x1000) {

  0059d	f7 46 14 00 10
	00 00		 test	 DWORD PTR [esi+20], 4096 ; 00001000H
  005a4	0f 84 8d 00 00
	00		 je	 $LN361@inflate

; 801  :                 if (have == 0) goto inf_leave;

  005aa	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  005ae	0f 84 4b 0e 00
	00		 je	 $inf_leave$3959

; 802  :                 copy = 0;

  005b4	33 c0		 xor	 eax, eax
$LL359@inflate:

; 803  :                 do {
; 804  :                     len = (unsigned)(next[copy++]);

  005b6	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  005ba	40		 inc	 eax
  005bb	89 45 f4	 mov	 DWORD PTR _copy$[ebp], eax

; 805  :                     if (state->head != Z_NULL &&
; 806  :                             state->head->comment != Z_NULL &&
; 807  :                             state->length < state->head->comm_max)

  005be	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  005c1	89 4d e4	 mov	 DWORD PTR _len$[ebp], ecx
  005c4	85 c0		 test	 eax, eax
  005c6	74 21		 je	 SHORT $LN358@inflate
  005c8	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  005cb	89 4d d4	 mov	 DWORD PTR tv2305[ebp], ecx
  005ce	85 c9		 test	 ecx, ecx
  005d0	74 17		 je	 SHORT $LN358@inflate
  005d2	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  005d5	3b 48 28	 cmp	 ecx, DWORD PTR [eax+40]
  005d8	73 0f		 jae	 SHORT $LN358@inflate

; 808  :                         state->head->comment[state->length++] = (Bytef)len;

  005da	8b 55 d4	 mov	 edx, DWORD PTR tv2305[ebp]
  005dd	8a 45 e4	 mov	 al, BYTE PTR _len$[ebp]
  005e0	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  005e3	ff 46 44	 inc	 DWORD PTR [esi+68]
  005e6	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
$LN358@inflate:

; 809  :                 } while (len && copy < have);

  005e9	83 7d e4 00	 cmp	 DWORD PTR _len$[ebp], 0
  005ed	74 08		 je	 SHORT $LN355@inflate
  005ef	8b 45 f4	 mov	 eax, DWORD PTR _copy$[ebp]
  005f2	3b 45 fc	 cmp	 eax, DWORD PTR _have$[ebp]
  005f5	72 bf		 jb	 SHORT $LL359@inflate
$LN355@inflate:

; 810  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  005f7	f7 46 14 00 02
	00 00		 test	 DWORD PTR [esi+20], 512	; 00000200H
  005fe	74 20		 je	 SHORT $LN354@inflate
  00600	f6 46 0c 04	 test	 BYTE PTR [esi+12], 4
  00604	74 1a		 je	 SHORT $LN354@inflate

; 811  :                     state->check = crc32(state->check, next, copy);

  00606	8b 4d f4	 mov	 ecx, DWORD PTR _copy$[ebp]
  00609	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  0060c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0060f	51		 push	 ecx
  00610	52		 push	 edx
  00611	50		 push	 eax
  00612	e8 00 00 00 00	 call	 _crc32
  00617	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  0061a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0061d	89 46 1c	 mov	 DWORD PTR [esi+28], eax
$LN354@inflate:

; 812  :                 have -= copy;

  00620	8b 45 f4	 mov	 eax, DWORD PTR _copy$[ebp]
  00623	29 45 fc	 sub	 DWORD PTR _have$[ebp], eax

; 813  :                 next += copy;

  00626	03 d0		 add	 edx, eax

; 814  :                 if (len) goto inf_leave;

  00628	83 7d e4 00	 cmp	 DWORD PTR _len$[ebp], 0
  0062c	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  0062f	0f 85 ca 0d 00
	00		 jne	 $inf_leave$3959

; 815  :             }
; 816  :             else if (state->head != Z_NULL)

  00635	eb 0e		 jmp	 SHORT $LN351@inflate
$LN361@inflate:
  00637	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0063a	85 c0		 test	 eax, eax
  0063c	74 07		 je	 SHORT $LN351@inflate

; 817  :                 state->head->comment = Z_NULL;

  0063e	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0
$LN351@inflate:

; 818  :             state->mode = HCRC;

  00645	c7 46 04 3c 3f
	00 00		 mov	 DWORD PTR [esi+4], 16188 ; 00003f3cH
$LN720@inflate:

; 819  :         case HCRC:
; 820  :             if (state->flags & 0x0200) {

  0064c	f7 46 14 00 02
	00 00		 test	 DWORD PTR [esi+20], 512	; 00000200H
  00653	74 4e		 je	 SHORT $LN336@inflate

; 821  :                 NEEDBITS(16);

  00655	83 ff 10	 cmp	 edi, 16			; 00000010H
  00658	73 28		 jae	 SHORT $LN347@inflate
  0065a	8d 9b 00 00 00
	00		 npad	 6
$LL345@inflate:
  00660	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00664	0f 84 95 0d 00
	00		 je	 $inf_leave$3959
  0066a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0066d	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00670	8b cf		 mov	 ecx, edi
  00672	d3 e0		 shl	 eax, cl
  00674	42		 inc	 edx
  00675	83 c7 08	 add	 edi, 8
  00678	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  0067b	03 d8		 add	 ebx, eax
  0067d	83 ff 10	 cmp	 edi, 16			; 00000010H
  00680	72 de		 jb	 SHORT $LL345@inflate
$LN347@inflate:

; 822  :                 if ((state->wrap & 4) && hold != (state->check & 0xffff)) {

  00682	f6 46 0c 04	 test	 BYTE PTR [esi+12], 4
  00686	74 17		 je	 SHORT $LN338@inflate
  00688	0f b7 4e 1c	 movzx	 ecx, WORD PTR [esi+28]
  0068c	3b d9		 cmp	 ebx, ecx
  0068e	74 0f		 je	 SHORT $LN338@inflate

; 823  :                     strm->msg = (char *)"header crc mismatch";

  00690	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00693	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@

; 824  :                     state->mode = BAD;
; 825  :                     break;

  0069a	e9 f8 0c 00 00	 jmp	 $LN788@inflate
$LN338@inflate:

; 826  :                 }
; 827  :                 INITBITS();

  0069f	33 db		 xor	 ebx, ebx
  006a1	33 ff		 xor	 edi, edi
$LN336@inflate:

; 828  :             }
; 829  :             if (state->head != Z_NULL) {

  006a3	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  006a6	85 c0		 test	 eax, eax
  006a8	74 16		 je	 SHORT $LN335@inflate

; 830  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  006aa	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  006ad	c1 f9 09	 sar	 ecx, 9
  006b0	83 e1 01	 and	 ecx, 1
  006b3	89 48 2c	 mov	 DWORD PTR [eax+44], ecx

; 831  :                 state->head->done = 1;

  006b6	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  006b9	c7 42 30 01 00
	00 00		 mov	 DWORD PTR [edx+48], 1
$LN335@inflate:

; 832  :             }
; 833  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  006c0	6a 00		 push	 0
  006c2	6a 00		 push	 0
  006c4	6a 00		 push	 0
  006c6	e8 00 00 00 00	 call	 _crc32
  006cb	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]

; 834  :             state->mode = TYPE;
; 835  :             break;

  006ce	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  006d1	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  006d4	89 41 30	 mov	 DWORD PTR [ecx+48], eax
  006d7	83 c4 0c	 add	 esp, 12			; 0000000cH
  006da	c7 46 04 3f 3f
	00 00		 mov	 DWORD PTR [esi+4], 16191 ; 00003f3fH
  006e1	e9 b8 0c 00 00	 jmp	 $LN491@inflate
$LN333@inflate:

; 836  : #endif
; 837  :         case DICTID:
; 838  :             NEEDBITS(32);

  006e6	83 ff 20	 cmp	 edi, 32			; 00000020H
  006e9	73 27		 jae	 SHORT $LN332@inflate
  006eb	eb 03 8d 49 00	 npad	 5
$LL330@inflate:
  006f0	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  006f4	0f 84 05 0d 00
	00		 je	 $inf_leave$3959
  006fa	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  006fd	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00700	8b cf		 mov	 ecx, edi
  00702	d3 e0		 shl	 eax, cl
  00704	42		 inc	 edx
  00705	83 c7 08	 add	 edi, 8
  00708	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  0070b	03 d8		 add	 ebx, eax
  0070d	83 ff 20	 cmp	 edi, 32			; 00000020H
  00710	72 de		 jb	 SHORT $LL330@inflate
$LN332@inflate:

; 839  :             strm->adler = state->check = ZSWAP32(hold);

  00712	8b cb		 mov	 ecx, ebx
  00714	8b c3		 mov	 eax, ebx
  00716	c1 e0 10	 shl	 eax, 16			; 00000010H
  00719	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  0071f	03 c8		 add	 ecx, eax
  00721	8b c3		 mov	 eax, ebx
  00723	c1 e8 08	 shr	 eax, 8
  00726	c1 e1 08	 shl	 ecx, 8
  00729	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  0072e	03 c1		 add	 eax, ecx
  00730	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00733	c1 eb 18	 shr	 ebx, 24			; 00000018H
  00736	03 c3		 add	 eax, ebx
  00738	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  0073b	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 840  :             INITBITS();

  0073e	33 db		 xor	 ebx, ebx
  00740	33 ff		 xor	 edi, edi

; 841  :             state->mode = DICT;

  00742	c7 46 04 3e 3f
	00 00		 mov	 DWORD PTR [esi+4], 16190 ; 00003f3eH
$LN722@inflate:

; 842  :         case DICT:
; 843  :             if (state->havedict == 0) {

  00749	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  0074d	0f 84 68 0c 00
	00		 je	 $LN580@inflate

; 846  :             }
; 847  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  00753	6a 00		 push	 0
  00755	6a 00		 push	 0
  00757	6a 00		 push	 0
  00759	e8 00 00 00 00	 call	 _adler32
  0075e	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00761	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  00764	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 848  :             state->mode = TYPE;

  00767	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  0076a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0076d	c7 46 04 3f 3f
	00 00		 mov	 DWORD PTR [esi+4], 16191 ; 00003f3fH
$LN316@inflate:

; 849  :         case TYPE:
; 850  :             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;

  00774	83 7d 0c 05	 cmp	 DWORD PTR _flush$[ebp], 5
  00778	0f 84 81 0c 00
	00		 je	 $inf_leave$3959
  0077e	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  00782	0f 84 77 0c 00
	00		 je	 $inf_leave$3959
$LN315@inflate:

; 851  :         case TYPEDO:
; 852  :             if (state->last) {

  00788	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0
  0078c	74 15		 je	 SHORT $LN308@inflate

; 853  :                 BYTEBITS();

  0078e	8b cf		 mov	 ecx, edi
  00790	83 e1 07	 and	 ecx, 7
  00793	d3 eb		 shr	 ebx, cl
  00795	2b f9		 sub	 edi, ecx

; 854  :                 state->mode = CHECK;

  00797	c7 46 04 4e 3f
	00 00		 mov	 DWORD PTR [esi+4], 16206 ; 00003f4eH

; 855  :                 break;

  0079e	e9 fb 0b 00 00	 jmp	 $LN491@inflate
$LN308@inflate:

; 856  :             }
; 857  :             NEEDBITS(3);

  007a3	83 ff 03	 cmp	 edi, 3
  007a6	73 2a		 jae	 SHORT $LN307@inflate
  007a8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL305@inflate:
  007b0	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  007b4	0f 84 45 0c 00
	00		 je	 $inf_leave$3959
  007ba	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  007bd	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  007c0	8b cf		 mov	 ecx, edi
  007c2	d3 e0		 shl	 eax, cl
  007c4	42		 inc	 edx
  007c5	83 c7 08	 add	 edi, 8
  007c8	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  007cb	03 d8		 add	 ebx, eax
  007cd	83 ff 03	 cmp	 edi, 3
  007d0	72 de		 jb	 SHORT $LL305@inflate
$LN307@inflate:

; 858  :             state->last = BITS(1);

  007d2	8b cb		 mov	 ecx, ebx

; 859  :             DROPBITS(1);

  007d4	d1 eb		 shr	 ebx, 1

; 860  :             switch (BITS(2)) {

  007d6	8b c3		 mov	 eax, ebx
  007d8	83 e1 01	 and	 ecx, 1
  007db	83 e0 03	 and	 eax, 3
  007de	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  007e1	83 f8 03	 cmp	 eax, 3
  007e4	77 5b		 ja	 SHORT $LN286@inflate
  007e6	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN790@inflate[eax*4]
$LN294@inflate:

; 884  :             }
; 885  :             DROPBITS(2);

  007ed	c1 eb 02	 shr	 ebx, 2
  007f0	c7 46 04 41 3f
	00 00		 mov	 DWORD PTR [esi+4], 16193 ; 00003f41H
  007f7	83 ef 03	 sub	 edi, 3

; 886  :             break;

  007fa	e9 9f 0b 00 00	 jmp	 $LN491@inflate
$LN293@inflate:

; 861  :             case 0:                             /* stored block */
; 862  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 863  :                         state->last ? " (last)" : ""));
; 864  :                 state->mode = STORED;
; 865  :                 break;
; 866  :             case 1:                             /* fixed block */
; 867  :                 fixedtables(state);

  007ff	8b c6		 mov	 eax, esi
  00801	e8 00 00 00 00	 call	 _fixedtables

; 868  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 869  :                         state->last ? " (last)" : ""));
; 870  :                 state->mode = LEN_;             /* decode codes */
; 871  :                 if (flush == Z_TREES) {

  00806	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  0080a	c7 46 04 47 3f
	00 00		 mov	 DWORD PTR [esi+4], 16199 ; 00003f47H
  00811	75 2e		 jne	 SHORT $LN286@inflate

; 872  :                     DROPBITS(2);

  00813	c1 eb 02	 shr	 ebx, 2
  00816	83 ef 03	 sub	 edi, 3

; 873  :                     goto inf_leave;

  00819	e9 e1 0b 00 00	 jmp	 $inf_leave$3959
$LN288@inflate:

; 884  :             }
; 885  :             DROPBITS(2);

  0081e	c1 eb 02	 shr	 ebx, 2
  00821	c7 46 04 44 3f
	00 00		 mov	 DWORD PTR [esi+4], 16196 ; 00003f44H
  00828	83 ef 03	 sub	 edi, 3

; 886  :             break;

  0082b	e9 6e 0b 00 00	 jmp	 $LN491@inflate
$LN287@inflate:

; 874  :                 }
; 875  :                 break;
; 876  :             case 2:                             /* dynamic block */
; 877  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 878  :                         state->last ? " (last)" : ""));
; 879  :                 state->mode = TABLE;
; 880  :                 break;
; 881  :             case 3:
; 882  :                 strm->msg = (char *)"invalid block type";

  00830	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00833	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@

; 883  :                 state->mode = BAD;

  0083a	c7 46 04 51 3f
	00 00		 mov	 DWORD PTR [esi+4], 16209 ; 00003f51H
$LN286@inflate:

; 884  :             }
; 885  :             DROPBITS(2);

  00841	c1 eb 02	 shr	 ebx, 2
  00844	83 ef 03	 sub	 edi, 3

; 886  :             break;

  00847	e9 52 0b 00 00	 jmp	 $LN491@inflate
$LN282@inflate:

; 887  :         case STORED:
; 888  :             BYTEBITS();                         /* go to byte boundary */

  0084c	8b cf		 mov	 ecx, edi
  0084e	83 e1 07	 and	 ecx, 7
  00851	2b f9		 sub	 edi, ecx
  00853	d3 eb		 shr	 ebx, cl

; 889  :             NEEDBITS(32);

  00855	83 ff 20	 cmp	 edi, 32			; 00000020H
  00858	73 28		 jae	 SHORT $LN278@inflate
  0085a	8d 9b 00 00 00
	00		 npad	 6
$LL276@inflate:
  00860	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00864	0f 84 95 0b 00
	00		 je	 $inf_leave$3959
  0086a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0086d	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00870	8b cf		 mov	 ecx, edi
  00872	d3 e0		 shl	 eax, cl
  00874	42		 inc	 edx
  00875	83 c7 08	 add	 edi, 8
  00878	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  0087b	03 d8		 add	 ebx, eax
  0087d	83 ff 20	 cmp	 edi, 32			; 00000020H
  00880	72 de		 jb	 SHORT $LL276@inflate
$LN278@inflate:

; 890  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  00882	8b cb		 mov	 ecx, ebx
  00884	8b c3		 mov	 eax, ebx
  00886	f7 d1		 not	 ecx
  00888	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0088d	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00890	3b c1		 cmp	 eax, ecx
  00892	74 0f		 je	 SHORT $LN270@inflate

; 891  :                 strm->msg = (char *)"invalid stored block lengths";

  00894	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00897	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@

; 892  :                 state->mode = BAD;
; 893  :                 break;

  0089e	e9 f4 0a 00 00	 jmp	 $LN788@inflate
$LN270@inflate:

; 894  :             }
; 895  :             state->length = (unsigned)hold & 0xffff;
; 896  :             Tracev((stderr, "inflate:       stored length %u\n",
; 897  :                     state->length));
; 898  :             INITBITS();

  008a3	33 db		 xor	 ebx, ebx
  008a5	33 ff		 xor	 edi, edi

; 899  :             state->mode = COPY_;
; 900  :             if (flush == Z_TREES) goto inf_leave;

  008a7	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  008ab	89 46 44	 mov	 DWORD PTR [esi+68], eax
  008ae	c7 46 04 42 3f
	00 00		 mov	 DWORD PTR [esi+4], 16194 ; 00003f42H
  008b5	0f 84 44 0b 00
	00		 je	 $inf_leave$3959
$LN266@inflate:

; 901  :         case COPY_:
; 902  :             state->mode = COPY;

  008bb	c7 46 04 43 3f
	00 00		 mov	 DWORD PTR [esi+4], 16195 ; 00003f43H
$LN264@inflate:

; 903  :         case COPY:
; 904  :             copy = state->length;

  008c2	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  008c5	89 45 f4	 mov	 DWORD PTR _copy$[ebp], eax

; 905  :             if (copy) {

  008c8	85 c0		 test	 eax, eax
  008ca	0f 84 82 06 00
	00		 je	 $LN263@inflate

; 906  :                 if (copy > have) copy = have;

  008d0	8b 4d fc	 mov	 ecx, DWORD PTR _have$[ebp]
  008d3	3b c1		 cmp	 eax, ecx
  008d5	76 05		 jbe	 SHORT $LN262@inflate
  008d7	8b c1		 mov	 eax, ecx
  008d9	89 4d f4	 mov	 DWORD PTR _copy$[ebp], ecx
$LN262@inflate:

; 907  :                 if (copy > left) copy = left;

  008dc	8b 4d f0	 mov	 ecx, DWORD PTR _left$[ebp]
  008df	3b c1		 cmp	 eax, ecx
  008e1	76 05		 jbe	 SHORT $LN261@inflate
  008e3	8b c1		 mov	 eax, ecx
  008e5	89 45 f4	 mov	 DWORD PTR _copy$[ebp], eax
$LN261@inflate:

; 908  :                 if (copy == 0) goto inf_leave;

  008e8	85 c0		 test	 eax, eax
  008ea	0f 84 0f 0b 00
	00		 je	 $inf_leave$3959

; 909  :                 zmemcpy(put, next, copy);

  008f0	8b 4d f4	 mov	 ecx, DWORD PTR _copy$[ebp]
  008f3	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  008f6	8b 45 e8	 mov	 eax, DWORD PTR _put$[ebp]
  008f9	51		 push	 ecx
  008fa	52		 push	 edx
  008fb	50		 push	 eax
  008fc	e8 00 00 00 00	 call	 _memcpy

; 910  :                 have -= copy;

  00901	8b 45 f4	 mov	 eax, DWORD PTR _copy$[ebp]

; 911  :                 next += copy;

  00904	01 45 f8	 add	 DWORD PTR _next$[ebp], eax
  00907	29 45 fc	 sub	 DWORD PTR _have$[ebp], eax

; 912  :                 left -= copy;

  0090a	29 45 f0	 sub	 DWORD PTR _left$[ebp], eax

; 913  :                 put += copy;

  0090d	01 45 e8	 add	 DWORD PTR _put$[ebp], eax

; 914  :                 state->length -= copy;
; 915  :                 break;

  00910	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  00913	83 c4 0c	 add	 esp, 12			; 0000000cH
  00916	29 46 44	 sub	 DWORD PTR [esi+68], eax
  00919	e9 80 0a 00 00	 jmp	 $LN491@inflate
$LN258@inflate:

; 916  :             }
; 917  :             Tracev((stderr, "inflate:       stored end\n"));
; 918  :             state->mode = TYPE;
; 919  :             break;
; 920  :         case TABLE:
; 921  :             NEEDBITS(14);

  0091e	83 ff 0e	 cmp	 edi, 14			; 0000000eH
  00921	73 22		 jae	 SHORT $LN257@inflate
$LL255@inflate:
  00923	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00927	0f 84 d2 0a 00
	00		 je	 $inf_leave$3959
  0092d	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00930	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00933	8b cf		 mov	 ecx, edi
  00935	d3 e0		 shl	 eax, cl
  00937	42		 inc	 edx
  00938	83 c7 08	 add	 edi, 8
  0093b	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  0093e	03 d8		 add	 ebx, eax
  00940	83 ff 0e	 cmp	 edi, 14			; 0000000eH
  00943	72 de		 jb	 SHORT $LL255@inflate
$LN257@inflate:

; 922  :             state->nlen = BITS(5) + 257;

  00945	8b cb		 mov	 ecx, ebx
  00947	83 e1 1f	 and	 ecx, 31			; 0000001fH

; 923  :             DROPBITS(5);

  0094a	c1 eb 05	 shr	 ebx, 5
  0094d	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H

; 924  :             state->ndist = BITS(5) + 1;

  00953	8b c3		 mov	 eax, ebx
  00955	89 4e 64	 mov	 DWORD PTR [esi+100], ecx

; 925  :             DROPBITS(5);

  00958	c1 eb 05	 shr	 ebx, 5

; 926  :             state->ncode = BITS(4) + 4;

  0095b	8b cb		 mov	 ecx, ebx
  0095d	83 e0 1f	 and	 eax, 31			; 0000001fH
  00960	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00963	40		 inc	 eax
  00964	83 c1 04	 add	 ecx, 4

; 927  :             DROPBITS(4);

  00967	c1 eb 04	 shr	 ebx, 4
  0096a	83 ef 0e	 sub	 edi, 14			; 0000000eH

; 928  : #ifndef PKZIP_BUG_WORKAROUND
; 929  :             if (state->nlen > 286 || state->ndist > 30) {

  0096d	81 7e 64 1e 01
	00 00		 cmp	 DWORD PTR [esi+100], 286 ; 0000011eH
  00974	89 46 68	 mov	 DWORD PTR [esi+104], eax
  00977	89 4e 60	 mov	 DWORD PTR [esi+96], ecx
  0097a	0f 87 e3 00 00
	00		 ja	 $LN239@inflate
  00980	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  00983	0f 87 da 00 00
	00		 ja	 $LN239@inflate

; 933  :             }
; 934  : #endif
; 935  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 936  :             state->have = 0;

  00989	c7 46 6c 00 00
	00 00		 mov	 DWORD PTR [esi+108], 0

; 937  :             state->mode = LENLENS;

  00990	c7 46 04 45 3f
	00 00		 mov	 DWORD PTR [esi+4], 16197 ; 00003f45H
$LN726@inflate:

; 938  :         case LENLENS:
; 939  :             while (state->have < state->ncode) {

  00997	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  0099a	3b 4e 60	 cmp	 ecx, DWORD PTR [esi+96]
  0099d	73 4e		 jae	 SHORT $LN528@inflate
  0099f	90		 npad	 1
$LL237@inflate:

; 940  :                 NEEDBITS(3);

  009a0	83 ff 03	 cmp	 edi, 3
  009a3	73 22		 jae	 SHORT $LN234@inflate
$LL232@inflate:
  009a5	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  009a9	0f 84 50 0a 00
	00		 je	 $inf_leave$3959
  009af	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  009b2	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  009b5	8b cf		 mov	 ecx, edi
  009b7	d3 e0		 shl	 eax, cl
  009b9	42		 inc	 edx
  009ba	83 c7 08	 add	 edi, 8
  009bd	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  009c0	03 d8		 add	 ebx, eax
  009c2	83 ff 03	 cmp	 edi, 3
  009c5	72 de		 jb	 SHORT $LL232@inflate
$LN234@inflate:

; 941  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  009c7	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  009ca	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  009d2	8b cb		 mov	 ecx, ebx
  009d4	83 e1 07	 and	 ecx, 7
  009d7	66 89 4c 46 74	 mov	 WORD PTR [esi+eax*2+116], cx
  009dc	ff 46 6c	 inc	 DWORD PTR [esi+108]
  009df	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]

; 942  :                 DROPBITS(3);

  009e2	c1 eb 03	 shr	 ebx, 3
  009e5	83 ef 03	 sub	 edi, 3
  009e8	3b 4e 60	 cmp	 ecx, DWORD PTR [esi+96]
  009eb	72 b3		 jb	 SHORT $LL237@inflate
$LN528@inflate:

; 943  :             }
; 944  :             while (state->have < 19)

  009ed	b8 13 00 00 00	 mov	 eax, 19			; 00000013H
  009f2	39 46 6c	 cmp	 DWORD PTR [esi+108], eax
  009f5	73 23		 jae	 SHORT $LN222@inflate
  009f7	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL223@inflate:

; 945  :                 state->lens[order[state->have++]] = 0;

  00a00	8b 56 6c	 mov	 edx, DWORD PTR [esi+108]
  00a03	0f b7 0c 55 00
	00 00 00	 movzx	 ecx, WORD PTR ?order@?1??inflate@@9@9[edx*2]
  00a0b	33 d2		 xor	 edx, edx
  00a0d	66 89 54 4e 74	 mov	 WORD PTR [esi+ecx*2+116], dx
  00a12	ff 46 6c	 inc	 DWORD PTR [esi+108]
  00a15	39 46 6c	 cmp	 DWORD PTR [esi+108], eax
  00a18	72 e6		 jb	 SHORT $LL223@inflate
$LN222@inflate:

; 946  :             state->next = state->codes;

  00a1a	8d 86 34 05 00
	00		 lea	 eax, DWORD PTR [esi+1332]
  00a20	8d 4e 70	 lea	 ecx, DWORD PTR [esi+112]
  00a23	89 01		 mov	 DWORD PTR [ecx], eax

; 947  :             state->lencode = (const code FAR *)(state->next);

  00a25	89 46 50	 mov	 DWORD PTR [esi+80], eax

; 948  :             state->lenbits = 7;
; 949  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),
; 950  :                                 &(state->lenbits), state->work);

  00a28	8d 96 f4 02 00
	00		 lea	 edx, DWORD PTR [esi+756]
  00a2e	52		 push	 edx
  00a2f	8d 46 58	 lea	 eax, DWORD PTR [esi+88]
  00a32	50		 push	 eax
  00a33	51		 push	 ecx
  00a34	c7 00 07 00 00
	00		 mov	 DWORD PTR [eax], 7
  00a3a	6a 13		 push	 19			; 00000013H
  00a3c	8d 46 74	 lea	 eax, DWORD PTR [esi+116]
  00a3f	50		 push	 eax
  00a40	6a 00		 push	 0
  00a42	e8 00 00 00 00	 call	 _inflate_table

; 953  :                 state->mode = BAD;
; 954  :                 break;

  00a47	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  00a4a	83 c4 18	 add	 esp, 24			; 00000018H
  00a4d	89 45 d8	 mov	 DWORD PTR _ret$[ebp], eax
  00a50	85 c0		 test	 eax, eax
  00a52	74 1e		 je	 SHORT $LN221@inflate

; 951  :             if (ret) {
; 952  :                 strm->msg = (char *)"invalid code lengths set";

  00a54	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00a57	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@

; 953  :                 state->mode = BAD;
; 954  :                 break;

  00a5e	e9 34 09 00 00	 jmp	 $LN788@inflate
$LN239@inflate:

; 930  :                 strm->msg = (char *)"too many length or distance symbols";

  00a63	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00a66	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@

; 931  :                 state->mode = BAD;
; 932  :                 break;

  00a6d	e9 25 09 00 00	 jmp	 $LN788@inflate
$LN221@inflate:

; 955  :             }
; 956  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 957  :             state->have = 0;

  00a72	c7 46 6c 00 00
	00 00		 mov	 DWORD PTR [esi+108], 0

; 958  :             state->mode = CODELENS;

  00a79	c7 46 04 46 3f
	00 00		 mov	 DWORD PTR [esi+4], 16198 ; 00003f46H
$LN529@inflate:

; 959  :         case CODELENS:
; 960  :             while (state->have < state->nlen + state->ndist) {

  00a80	8b 46 68	 mov	 eax, DWORD PTR [esi+104]
  00a83	03 46 64	 add	 eax, DWORD PTR [esi+100]
  00a86	39 46 6c	 cmp	 DWORD PTR [esi+108], eax
  00a89	0f 83 e4 01 00
	00		 jae	 $LN218@inflate
  00a8f	90		 npad	 1
$LL219@inflate:

; 961  :                 for (;;) {
; 962  :                     here = state->lencode[BITS(state->lenbits)];

  00a90	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  00a93	b8 01 00 00 00	 mov	 eax, 1
  00a98	d3 e0		 shl	 eax, cl
  00a9a	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  00a9d	48		 dec	 eax
  00a9e	23 c3		 and	 eax, ebx
  00aa0	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]

; 963  :                     if ((unsigned)(here.bits) <= bits) break;

  00aa3	8b c1		 mov	 eax, ecx
  00aa5	c1 e8 08	 shr	 eax, 8
  00aa8	0f b6 c0	 movzx	 eax, al
  00aab	89 4d f4	 mov	 DWORD PTR _here$[ebp], ecx
  00aae	3b c7		 cmp	 eax, edi
  00ab0	76 3f		 jbe	 SHORT $LN556@inflate
$LL217@inflate:

; 964  :                     PULLBYTE();

  00ab2	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00ab6	0f 84 43 09 00
	00		 je	 $inf_leave$3959
  00abc	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00abf	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00ac2	8b cf		 mov	 ecx, edi
  00ac4	d3 e0		 shl	 eax, cl
  00ac6	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  00ac9	42		 inc	 edx
  00aca	83 c7 08	 add	 edi, 8
  00acd	03 d8		 add	 ebx, eax
  00acf	b8 01 00 00 00	 mov	 eax, 1
  00ad4	d3 e0		 shl	 eax, cl
  00ad6	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  00ad9	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  00adc	48		 dec	 eax
  00add	23 c3		 and	 eax, ebx
  00adf	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  00ae2	8b c1		 mov	 eax, ecx
  00ae4	c1 e8 08	 shr	 eax, 8
  00ae7	0f b6 c0	 movzx	 eax, al
  00aea	89 4d f4	 mov	 DWORD PTR _here$[ebp], ecx
  00aed	3b c7		 cmp	 eax, edi
  00aef	77 c1		 ja	 SHORT $LL217@inflate
$LN556@inflate:

; 965  :                 }
; 966  :                 if (here.val < 16) {

  00af1	8b c1		 mov	 eax, ecx
  00af3	c1 e8 10	 shr	 eax, 16			; 00000010H
  00af6	89 45 d4	 mov	 DWORD PTR tv2435[ebp], eax
  00af9	66 83 f8 10	 cmp	 ax, 16			; 00000010H
  00afd	73 1a		 jae	 SHORT $LN782@inflate

; 967  :                     DROPBITS(here.bits);

  00aff	c1 e9 08	 shr	 ecx, 8
  00b02	0f b6 c9	 movzx	 ecx, cl
  00b05	d3 eb		 shr	 ebx, cl
  00b07	2b f9		 sub	 edi, ecx

; 968  :                     state->lens[state->have++] = here.val;

  00b09	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  00b0c	66 89 44 4e 74	 mov	 WORD PTR [esi+ecx*2+116], ax
  00b11	ff 46 6c	 inc	 DWORD PTR [esi+108]

; 969  :                 }
; 970  :                 else {

  00b14	e9 4b 01 00 00	 jmp	 $LN729@inflate
$LN782@inflate:

; 971  :                     if (here.val == 16) {

  00b19	75 6f		 jne	 SHORT $LN205@inflate

; 972  :                         NEEDBITS(here.bits + 2);

  00b1b	8b c1		 mov	 eax, ecx
  00b1d	c1 e8 08	 shr	 eax, 8
  00b20	0f b6 c0	 movzx	 eax, al
  00b23	83 c0 02	 add	 eax, 2
  00b26	3b f8		 cmp	 edi, eax
  00b28	73 30		 jae	 SHORT $LN203@inflate
  00b2a	8d 9b 00 00 00
	00		 npad	 6
$LL201@inflate:
  00b30	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00b34	0f 84 c5 08 00
	00		 je	 $inf_leave$3959
  00b3a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00b3d	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00b40	8b cf		 mov	 ecx, edi
  00b42	d3 e0		 shl	 eax, cl
  00b44	8b 4d f4	 mov	 ecx, DWORD PTR _here$[ebp]
  00b47	42		 inc	 edx
  00b48	83 c7 08	 add	 edi, 8
  00b4b	03 d8		 add	 ebx, eax
  00b4d	0f b6 c5	 movzx	 eax, ch
  00b50	83 c0 02	 add	 eax, 2
  00b53	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  00b56	3b f8		 cmp	 edi, eax
  00b58	72 d6		 jb	 SHORT $LL201@inflate
$LN203@inflate:

; 973  :                         DROPBITS(here.bits);
; 974  :                         if (state->have == 0) {

  00b5a	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00b5d	0f b6 cd	 movzx	 ecx, ch
  00b60	d3 eb		 shr	 ebx, cl
  00b62	2b f9		 sub	 edi, ecx
  00b64	85 c0		 test	 eax, eax
  00b66	0f 84 2d 01 00
	00		 je	 $LN561@inflate

; 978  :                         }
; 979  :                         len = state->lens[state->have - 1];

  00b6c	0f b7 4c 46 72	 movzx	 ecx, WORD PTR [esi+eax*2+114]

; 980  :                         copy = 3 + BITS(2);

  00b71	8b c3		 mov	 eax, ebx
  00b73	83 e0 03	 and	 eax, 3
  00b76	83 c0 03	 add	 eax, 3

; 981  :                         DROPBITS(2);

  00b79	c1 eb 02	 shr	 ebx, 2
  00b7c	89 4d e4	 mov	 DWORD PTR _len$[ebp], ecx
  00b7f	89 45 f4	 mov	 DWORD PTR _copy$[ebp], eax
  00b82	83 ef 02	 sub	 edi, 2

; 982  :                     }
; 983  :                     else if (here.val == 17) {

  00b85	e9 a5 00 00 00	 jmp	 $LN156@inflate
$LN205@inflate:
  00b8a	66 83 7d f6 11	 cmp	 WORD PTR _here$[ebp+2], 17 ; 00000011H

; 984  :                         NEEDBITS(here.bits + 3);

  00b8f	0f b6 cd	 movzx	 ecx, ch
  00b92	89 4d dc	 mov	 DWORD PTR tv2446[ebp], ecx
  00b95	75 47		 jne	 SHORT $LN170@inflate
  00b97	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
  00b9a	3b f8		 cmp	 edi, eax
  00b9c	73 29		 jae	 SHORT $LN185@inflate
  00b9e	8b ff		 npad	 2
$LL183@inflate:
  00ba0	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00ba4	0f 84 55 08 00
	00		 je	 $inf_leave$3959
  00baa	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00bad	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00bb0	8b cf		 mov	 ecx, edi
  00bb2	d3 e0		 shl	 eax, cl
  00bb4	8b 4d dc	 mov	 ecx, DWORD PTR tv2446[ebp]
  00bb7	42		 inc	 edx
  00bb8	83 c7 08	 add	 edi, 8
  00bbb	03 d8		 add	 ebx, eax
  00bbd	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
  00bc0	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  00bc3	3b f8		 cmp	 edi, eax
  00bc5	72 d9		 jb	 SHORT $LL183@inflate
$LN185@inflate:

; 985  :                         DROPBITS(here.bits);

  00bc7	d3 eb		 shr	 ebx, cl

; 986  :                         len = 0;
; 987  :                         copy = 3 + BITS(3);

  00bc9	8b c3		 mov	 eax, ebx
  00bcb	83 e0 07	 and	 eax, 7
  00bce	83 c0 03	 add	 eax, 3
  00bd1	89 45 f4	 mov	 DWORD PTR _copy$[ebp], eax

; 988  :                         DROPBITS(3);

  00bd4	c1 eb 03	 shr	 ebx, 3
  00bd7	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 989  :                     }
; 990  :                     else {

  00bdc	eb 43		 jmp	 SHORT $LN783@inflate
$LN170@inflate:

; 991  :                         NEEDBITS(here.bits + 7);

  00bde	8d 41 07	 lea	 eax, DWORD PTR [ecx+7]
  00be1	3b f8		 cmp	 edi, eax
  00be3	73 27		 jae	 SHORT $LN169@inflate
$LL167@inflate:
  00be5	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00be9	0f 84 10 08 00
	00		 je	 $inf_leave$3959
  00bef	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00bf2	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00bf5	8b cf		 mov	 ecx, edi
  00bf7	d3 e0		 shl	 eax, cl
  00bf9	8b 4d dc	 mov	 ecx, DWORD PTR tv2446[ebp]
  00bfc	42		 inc	 edx
  00bfd	83 c7 08	 add	 edi, 8
  00c00	03 d8		 add	 ebx, eax
  00c02	8d 41 07	 lea	 eax, DWORD PTR [ecx+7]
  00c05	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  00c08	3b f8		 cmp	 edi, eax
  00c0a	72 d9		 jb	 SHORT $LL167@inflate
$LN169@inflate:

; 992  :                         DROPBITS(here.bits);

  00c0c	d3 eb		 shr	 ebx, cl

; 993  :                         len = 0;
; 994  :                         copy = 11 + BITS(7);

  00c0e	8b c3		 mov	 eax, ebx
  00c10	83 e0 7f	 and	 eax, 127		; 0000007fH
  00c13	83 c0 0b	 add	 eax, 11			; 0000000bH
  00c16	89 45 f4	 mov	 DWORD PTR _copy$[ebp], eax

; 995  :                         DROPBITS(7);

  00c19	c1 eb 07	 shr	 ebx, 7
  00c1c	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
$LN783@inflate:
  00c21	2b c1		 sub	 eax, ecx
  00c23	03 f8		 add	 edi, eax
  00c25	8b 45 f4	 mov	 eax, DWORD PTR _copy$[ebp]
  00c28	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0
$LN156@inflate:

; 996  :                     }
; 997  :                     if (state->have + copy > state->nlen + state->ndist) {

  00c2f	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  00c32	03 c8		 add	 ecx, eax
  00c34	8b 46 68	 mov	 eax, DWORD PTR [esi+104]
  00c37	03 46 64	 add	 eax, DWORD PTR [esi+100]
  00c3a	3b c8		 cmp	 ecx, eax
  00c3c	77 6a		 ja	 SHORT $LN562@inflate

; 999  :                         state->mode = BAD;
; 1000 :                         break;
; 1001 :                     }
; 1002 :                     while (copy--)

  00c3e	83 7d f4 00	 cmp	 DWORD PTR _copy$[ebp], 0
  00c42	74 20		 je	 SHORT $LN729@inflate
  00c44	8b 45 e4	 mov	 eax, DWORD PTR _len$[ebp]
  00c47	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL154@inflate:

; 1003 :                         state->lens[state->have++] = (unsigned short)len;

  00c50	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  00c53	ff 4d f4	 dec	 DWORD PTR _copy$[ebp]
  00c56	66 89 44 4e 74	 mov	 WORD PTR [esi+ecx*2+116], ax
  00c5b	ff 46 6c	 inc	 DWORD PTR [esi+108]
  00c5e	83 7d f4 00	 cmp	 DWORD PTR _copy$[ebp], 0
  00c62	75 ec		 jne	 SHORT $LL154@inflate
$LN729@inflate:

; 959  :         case CODELENS:
; 960  :             while (state->have < state->nlen + state->ndist) {

  00c64	8b 46 68	 mov	 eax, DWORD PTR [esi+104]
  00c67	03 46 64	 add	 eax, DWORD PTR [esi+100]
  00c6a	39 46 6c	 cmp	 DWORD PTR [esi+108], eax
  00c6d	0f 82 1d fe ff
	ff		 jb	 $LL219@inflate
$LN218@inflate:

; 1004 :                 }
; 1005 :             }
; 1006 : 
; 1007 :             /* handle error breaks in while */
; 1008 :             if (state->mode == BAD) break;

  00c73	81 7e 04 51 3f
	00 00		 cmp	 DWORD PTR [esi+4], 16209 ; 00003f51H
  00c7a	0f 84 1e 07 00
	00		 je	 $LN491@inflate

; 1009 : 
; 1010 :             /* check for end-of-block code (better have one) */
; 1011 :             if (state->lens[256] == 0) {

  00c80	66 83 be 74 02
	00 00 00	 cmp	 WORD PTR [esi+628], 0
  00c88	75 2d		 jne	 SHORT $LN151@inflate

; 1012 :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00c8a	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00c8d	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@

; 1013 :                 state->mode = BAD;
; 1014 :                 break;

  00c94	e9 fe 06 00 00	 jmp	 $LN788@inflate
$LN561@inflate:

; 975  :                             strm->msg = (char *)"invalid bit length repeat";

  00c99	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00c9c	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@

; 976  :                             state->mode = BAD;
; 977  :                             break;

  00ca3	e9 ef 06 00 00	 jmp	 $LN788@inflate
$LN562@inflate:

; 998  :                         strm->msg = (char *)"invalid bit length repeat";

  00ca8	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00cab	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@

; 1004 :                 }
; 1005 :             }
; 1006 : 
; 1007 :             /* handle error breaks in while */
; 1008 :             if (state->mode == BAD) break;

  00cb2	e9 e0 06 00 00	 jmp	 $LN788@inflate
$LN151@inflate:

; 1015 :             }
; 1016 : 
; 1017 :             /* build code tables -- note: do not change the lenbits or distbits
; 1018 :                values here (9 and 6) without reading the comments in inftrees.h
; 1019 :                concerning the ENOUGH constants, which depend on those values */
; 1020 :             state->next = state->codes;

  00cb7	8d 86 34 05 00
	00		 lea	 eax, DWORD PTR [esi+1332]
  00cbd	8d 4e 70	 lea	 ecx, DWORD PTR [esi+112]
  00cc0	89 01		 mov	 DWORD PTR [ecx], eax

; 1021 :             state->lencode = (const code FAR *)(state->next);

  00cc2	89 46 50	 mov	 DWORD PTR [esi+80], eax

; 1022 :             state->lenbits = 9;
; 1023 :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
; 1024 :                                 &(state->lenbits), state->work);

  00cc5	8d 96 f4 02 00
	00		 lea	 edx, DWORD PTR [esi+756]
  00ccb	52		 push	 edx
  00ccc	8b 56 64	 mov	 edx, DWORD PTR [esi+100]
  00ccf	8d 46 58	 lea	 eax, DWORD PTR [esi+88]
  00cd2	50		 push	 eax
  00cd3	51		 push	 ecx
  00cd4	c7 00 09 00 00
	00		 mov	 DWORD PTR [eax], 9
  00cda	52		 push	 edx
  00cdb	8d 46 74	 lea	 eax, DWORD PTR [esi+116]
  00cde	50		 push	 eax
  00cdf	6a 01		 push	 1
  00ce1	e8 00 00 00 00	 call	 _inflate_table
  00ce6	83 c4 18	 add	 esp, 24			; 00000018H
  00ce9	89 45 d8	 mov	 DWORD PTR _ret$[ebp], eax

; 1025 :             if (ret) {

  00cec	85 c0		 test	 eax, eax
  00cee	74 12		 je	 SHORT $LN150@inflate

; 1026 :                 strm->msg = (char *)"invalid literal/lengths set";

  00cf0	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]

; 1027 :                 state->mode = BAD;
; 1028 :                 break;

  00cf3	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  00cf6	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
  00cfd	e9 95 06 00 00	 jmp	 $LN788@inflate
$LN150@inflate:

; 1029 :             }
; 1030 :             state->distcode = (const code FAR *)(state->next);

  00d02	8b 56 70	 mov	 edx, DWORD PTR [esi+112]
  00d05	8d 4e 70	 lea	 ecx, DWORD PTR [esi+112]
  00d08	89 56 54	 mov	 DWORD PTR [esi+84], edx

; 1031 :             state->distbits = 6;
; 1032 :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 1033 :                             &(state->next), &(state->distbits), state->work);

  00d0b	8d 96 f4 02 00
	00		 lea	 edx, DWORD PTR [esi+756]
  00d11	52		 push	 edx
  00d12	8d 46 5c	 lea	 eax, DWORD PTR [esi+92]
  00d15	50		 push	 eax
  00d16	51		 push	 ecx
  00d17	8b 4e 64	 mov	 ecx, DWORD PTR [esi+100]
  00d1a	c7 00 06 00 00
	00		 mov	 DWORD PTR [eax], 6
  00d20	8b 46 68	 mov	 eax, DWORD PTR [esi+104]
  00d23	50		 push	 eax
  00d24	8d 54 4e 74	 lea	 edx, DWORD PTR [esi+ecx*2+116]
  00d28	52		 push	 edx
  00d29	6a 02		 push	 2
  00d2b	e8 00 00 00 00	 call	 _inflate_table

; 1036 :                 state->mode = BAD;
; 1037 :                 break;

  00d30	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  00d33	83 c4 18	 add	 esp, 24			; 00000018H
  00d36	89 45 d8	 mov	 DWORD PTR _ret$[ebp], eax
  00d39	85 c0		 test	 eax, eax
  00d3b	74 0f		 je	 SHORT $LN149@inflate

; 1034 :             if (ret) {
; 1035 :                 strm->msg = (char *)"invalid distances set";

  00d3d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00d40	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@

; 1036 :                 state->mode = BAD;
; 1037 :                 break;

  00d47	e9 4b 06 00 00	 jmp	 $LN788@inflate
$LN149@inflate:

; 1038 :             }
; 1039 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1040 :             state->mode = LEN_;
; 1041 :             if (flush == Z_TREES) goto inf_leave;

  00d4c	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  00d50	c7 46 04 47 3f
	00 00		 mov	 DWORD PTR [esi+4], 16199 ; 00003f47H
  00d57	0f 84 a2 06 00
	00		 je	 $inf_leave$3959
$LN148@inflate:

; 1042 :         case LEN_:
; 1043 :             state->mode = LEN;

  00d5d	c7 46 04 48 3f
	00 00		 mov	 DWORD PTR [esi+4], 16200 ; 00003f48H
$LN146@inflate:

; 1044 :         case LEN:
; 1045 :             if (have >= 6 && left >= 258) {

  00d64	83 7d fc 06	 cmp	 DWORD PTR _have$[ebp], 6
  00d68	72 72		 jb	 SHORT $LN145@inflate
  00d6a	81 7d f0 02 01
	00 00		 cmp	 DWORD PTR _left$[ebp], 258 ; 00000102H
  00d71	72 69		 jb	 SHORT $LN145@inflate

; 1046 :                 RESTORE();

  00d73	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00d76	8b 4d e8	 mov	 ecx, DWORD PTR _put$[ebp]
  00d79	8b 55 f0	 mov	 edx, DWORD PTR _left$[ebp]
  00d7c	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00d7f	8b 4d f8	 mov	 ecx, DWORD PTR _next$[ebp]
  00d82	89 08		 mov	 DWORD PTR [eax], ecx

; 1047 :                 inflate_fast(strm, out);

  00d84	8b 4d e0	 mov	 ecx, DWORD PTR _out$[ebp]
  00d87	89 50 10	 mov	 DWORD PTR [eax+16], edx
  00d8a	8b 55 fc	 mov	 edx, DWORD PTR _have$[ebp]
  00d8d	51		 push	 ecx
  00d8e	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00d91	50		 push	 eax
  00d92	89 5e 3c	 mov	 DWORD PTR [esi+60], ebx
  00d95	89 7e 40	 mov	 DWORD PTR [esi+64], edi
  00d98	e8 00 00 00 00	 call	 _inflate_fast

; 1048 :                 LOAD();

  00d9d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00da0	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00da3	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00da6	8b 5e 3c	 mov	 ebx, DWORD PTR [esi+60]
  00da9	8b 7e 40	 mov	 edi, DWORD PTR [esi+64]
  00dac	89 55 e8	 mov	 DWORD PTR _put$[ebp], edx
  00daf	8b 10		 mov	 edx, DWORD PTR [eax]
  00db1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00db4	83 c4 08	 add	 esp, 8

; 1049 :                 if (state->mode == TYPE)

  00db7	81 7e 04 3f 3f
	00 00		 cmp	 DWORD PTR [esi+4], 16191 ; 00003f3fH
  00dbe	89 4d f0	 mov	 DWORD PTR _left$[ebp], ecx
  00dc1	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  00dc4	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  00dc7	0f 85 d1 05 00
	00		 jne	 $LN491@inflate

; 1050 :                     state->back = -1;

  00dcd	c7 86 c8 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+7112], -1

; 1051 :                 break;

  00dd7	e9 c2 05 00 00	 jmp	 $LN491@inflate
$LN145@inflate:

; 1052 :             }
; 1053 :             state->back = 0;
; 1054 :             for (;;) {
; 1055 :                 here = state->lencode[BITS(state->lenbits)];

  00ddc	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  00ddf	b8 01 00 00 00	 mov	 eax, 1
  00de4	d3 e0		 shl	 eax, cl
  00de6	c7 86 c8 1b 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+7112], 0
  00df0	48		 dec	 eax
  00df1	23 c3		 and	 eax, ebx
  00df3	8b c8		 mov	 ecx, eax
  00df5	8b 46 50	 mov	 eax, DWORD PTR [esi+80]
  00df8	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]

; 1056 :                 if ((unsigned)(here.bits) <= bits) break;

  00dfb	8b c8		 mov	 ecx, eax
  00dfd	c1 e9 08	 shr	 ecx, 8
  00e00	0f b6 c9	 movzx	 ecx, cl
  00e03	89 45 f4	 mov	 DWORD PTR _here$[ebp], eax
  00e06	3b cf		 cmp	 ecx, edi
  00e08	76 45		 jbe	 SHORT $LN563@inflate
  00e0a	8d 9b 00 00 00
	00		 npad	 6
$LL137@inflate:

; 1057 :                 PULLBYTE();

  00e10	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00e14	0f 84 e5 05 00
	00		 je	 $inf_leave$3959
  00e1a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00e1d	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00e20	8b cf		 mov	 ecx, edi
  00e22	d3 e0		 shl	 eax, cl
  00e24	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  00e27	42		 inc	 edx
  00e28	83 c7 08	 add	 edi, 8
  00e2b	03 d8		 add	 ebx, eax
  00e2d	b8 01 00 00 00	 mov	 eax, 1
  00e32	d3 e0		 shl	 eax, cl
  00e34	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  00e37	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  00e3a	48		 dec	 eax
  00e3b	23 c3		 and	 eax, ebx
  00e3d	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00e40	8b c8		 mov	 ecx, eax
  00e42	c1 e9 08	 shr	 ecx, 8
  00e45	0f b6 c9	 movzx	 ecx, cl
  00e48	89 45 f4	 mov	 DWORD PTR _here$[ebp], eax
  00e4b	3b cf		 cmp	 ecx, edi
  00e4d	77 c1		 ja	 SHORT $LL137@inflate
$LN563@inflate:

; 1058 :             }
; 1059 :             if (here.op && (here.op & 0xf0) == 0) {

  00e4f	84 c0		 test	 al, al
  00e51	0f 84 c0 00 00
	00		 je	 $LN119@inflate
  00e57	a8 f0		 test	 al, 240			; 000000f0H
  00e59	0f 85 b8 00 00
	00		 jne	 $LN119@inflate

; 1060 :                 last = here;
; 1061 :                 for (;;) {
; 1062 :                     here = state->lencode[last.val +
; 1063 :                             (BITS(last.bits + last.op) >> last.bits)];

  00e5f	8b c8		 mov	 ecx, eax
  00e61	c1 e9 08	 shr	 ecx, 8
  00e64	89 4d d4	 mov	 DWORD PTR tv2420[ebp], ecx
  00e67	0f b6 c9	 movzx	 ecx, cl
  00e6a	89 4d e4	 mov	 DWORD PTR tv2421[ebp], ecx
  00e6d	0f b6 c8	 movzx	 ecx, al
  00e70	03 4d e4	 add	 ecx, DWORD PTR tv2421[ebp]
  00e73	89 45 dc	 mov	 DWORD PTR _last$[ebp], eax
  00e76	b8 01 00 00 00	 mov	 eax, 1
  00e7b	d3 e0		 shl	 eax, cl
  00e7d	8b 4d e4	 mov	 ecx, DWORD PTR tv2421[ebp]
  00e80	48		 dec	 eax
  00e81	23 c3		 and	 eax, ebx
  00e83	d3 e8		 shr	 eax, cl
  00e85	8b 4d f4	 mov	 ecx, DWORD PTR _here$[ebp]
  00e88	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00e8b	03 c1		 add	 eax, ecx
  00e8d	8b c8		 mov	 ecx, eax
  00e8f	8b 46 50	 mov	 eax, DWORD PTR [esi+80]
  00e92	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]

; 1064 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00e95	0f b6 4d d4	 movzx	 ecx, BYTE PTR tv2420[ebp]
  00e99	89 45 f4	 mov	 DWORD PTR _here$[ebp], eax
  00e9c	c1 e8 08	 shr	 eax, 8
  00e9f	0f b6 c0	 movzx	 eax, al
  00ea2	03 c1		 add	 eax, ecx
  00ea4	3b c7		 cmp	 eax, edi
  00ea6	76 5e		 jbe	 SHORT $LN122@inflate
  00ea8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL129@inflate:

; 1065 :                     PULLBYTE();

  00eb0	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00eb4	0f 84 45 05 00
	00		 je	 $inf_leave$3959
  00eba	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00ebd	8b cf		 mov	 ecx, edi
  00ebf	d3 e0		 shl	 eax, cl
  00ec1	8b 4d dc	 mov	 ecx, DWORD PTR _last$[ebp]
  00ec4	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00ec7	42		 inc	 edx
  00ec8	03 d8		 add	 ebx, eax
  00eca	0f b6 c5	 movzx	 eax, ch
  00ecd	89 45 e4	 mov	 DWORD PTR tv2519[ebp], eax
  00ed0	0f b6 c9	 movzx	 ecx, cl
  00ed3	03 c8		 add	 ecx, eax
  00ed5	b8 01 00 00 00	 mov	 eax, 1
  00eda	d3 e0		 shl	 eax, cl
  00edc	8b 4d e4	 mov	 ecx, DWORD PTR tv2519[ebp]
  00edf	83 c7 08	 add	 edi, 8
  00ee2	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  00ee5	48		 dec	 eax
  00ee6	23 c3		 and	 eax, ebx
  00ee8	d3 e8		 shr	 eax, cl
  00eea	0f b7 4d de	 movzx	 ecx, WORD PTR _last$[ebp+2]
  00eee	03 c1		 add	 eax, ecx
  00ef0	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  00ef3	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00ef6	89 45 f4	 mov	 DWORD PTR _here$[ebp], eax
  00ef9	c1 e8 08	 shr	 eax, 8
  00efc	0f b6 c0	 movzx	 eax, al
  00eff	03 45 e4	 add	 eax, DWORD PTR tv2519[ebp]
  00f02	3b c7		 cmp	 eax, edi
  00f04	77 aa		 ja	 SHORT $LL129@inflate
$LN122@inflate:

; 1066 :                 }
; 1067 :                 DROPBITS(last.bits);

  00f06	0f b6 4d dd	 movzx	 ecx, BYTE PTR _last$[ebp+1]

; 1068 :                 state->back += last.bits;

  00f0a	8b 45 f4	 mov	 eax, DWORD PTR _here$[ebp]
  00f0d	d3 eb		 shr	 ebx, cl
  00f0f	2b f9		 sub	 edi, ecx
  00f11	89 8e c8 1b 00
	00		 mov	 DWORD PTR [esi+7112], ecx
$LN119@inflate:

; 1069 :             }
; 1070 :             DROPBITS(here.bits);

  00f17	8b c8		 mov	 ecx, eax
  00f19	c1 e9 08	 shr	 ecx, 8
  00f1c	0f b6 c9	 movzx	 ecx, cl

; 1071 :             state->back += here.bits;

  00f1f	01 8e c8 1b 00
	00		 add	 DWORD PTR [esi+7112], ecx
  00f25	d3 eb		 shr	 ebx, cl
  00f27	2b f9		 sub	 edi, ecx
  00f29	89 4d e4	 mov	 DWORD PTR tv2421[ebp], ecx

; 1072 :             state->length = (unsigned)here.val;

  00f2c	8b c8		 mov	 ecx, eax
  00f2e	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00f31	89 4e 44	 mov	 DWORD PTR [esi+68], ecx

; 1073 :             if ((int)(here.op) == 0) {

  00f34	84 c0		 test	 al, al
  00f36	75 0c		 jne	 SHORT $LN116@inflate

; 1074 :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 1075 :                         "inflate:         literal '%c'\n" :
; 1076 :                         "inflate:         literal 0x%02x\n", here.val));
; 1077 :                 state->mode = LIT;

  00f38	c7 46 04 4d 3f
	00 00		 mov	 DWORD PTR [esi+4], 16205 ; 00003f4dH

; 1078 :                 break;

  00f3f	e9 5a 04 00 00	 jmp	 $LN491@inflate
$LN116@inflate:

; 1079 :             }
; 1080 :             if (here.op & 32) {

  00f44	a8 20		 test	 al, 32			; 00000020H
  00f46	74 16		 je	 SHORT $LN115@inflate

; 1081 :                 Tracevv((stderr, "inflate:         end of block\n"));
; 1082 :                 state->back = -1;

  00f48	c7 86 c8 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+7112], -1
$LN263@inflate:

; 1083 :                 state->mode = TYPE;

  00f52	c7 46 04 3f 3f
	00 00		 mov	 DWORD PTR [esi+4], 16191 ; 00003f3fH

; 1084 :                 break;

  00f59	e9 40 04 00 00	 jmp	 $LN491@inflate
$LN115@inflate:

; 1085 :             }
; 1086 :             if (here.op & 64) {

  00f5e	a8 40		 test	 al, 64			; 00000040H
  00f60	74 0f		 je	 SHORT $LN114@inflate

; 1087 :                 strm->msg = (char *)"invalid literal/length code";

  00f62	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00f65	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@

; 1088 :                 state->mode = BAD;
; 1089 :                 break;

  00f6c	e9 26 04 00 00	 jmp	 $LN788@inflate
$LN114@inflate:

; 1090 :             }
; 1091 :             state->extra = (unsigned)(here.op) & 15;

  00f71	0f b6 c8	 movzx	 ecx, al
  00f74	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00f77	89 4e 4c	 mov	 DWORD PTR [esi+76], ecx

; 1092 :             state->mode = LENEXT;

  00f7a	c7 46 04 49 3f
	00 00		 mov	 DWORD PTR [esi+4], 16201 ; 00003f49H
$LN113@inflate:

; 1093 :         case LENEXT:
; 1094 :             if (state->extra) {

  00f81	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  00f84	85 c0		 test	 eax, eax
  00f86	74 44		 je	 SHORT $LN732@inflate

; 1095 :                 NEEDBITS(state->extra);

  00f88	3b f8		 cmp	 edi, eax
  00f8a	73 26		 jae	 SHORT $LN110@inflate
  00f8c	8d 64 24 00	 npad	 4
$LL108@inflate:
  00f90	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00f94	0f 84 65 04 00
	00		 je	 $inf_leave$3959
  00f9a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00f9d	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00fa0	8b cf		 mov	 ecx, edi
  00fa2	d3 e0		 shl	 eax, cl
  00fa4	42		 inc	 edx
  00fa5	83 c7 08	 add	 edi, 8
  00fa8	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  00fab	03 d8		 add	 ebx, eax
  00fad	3b 7e 4c	 cmp	 edi, DWORD PTR [esi+76]
  00fb0	72 de		 jb	 SHORT $LL108@inflate
$LN110@inflate:

; 1096 :                 state->length += BITS(state->extra);

  00fb2	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  00fb5	b8 01 00 00 00	 mov	 eax, 1
  00fba	d3 e0		 shl	 eax, cl

; 1097 :                 DROPBITS(state->extra);

  00fbc	2b f9		 sub	 edi, ecx
  00fbe	48		 dec	 eax
  00fbf	23 c3		 and	 eax, ebx
  00fc1	01 46 44	 add	 DWORD PTR [esi+68], eax
  00fc4	d3 eb		 shr	 ebx, cl

; 1098 :                 state->back += state->extra;

  00fc6	01 8e c8 1b 00
	00		 add	 DWORD PTR [esi+7112], ecx
$LN732@inflate:

; 1099 :             }
; 1100 :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1101 :             state->was = state->length;

  00fcc	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  00fcf	89 8e cc 1b 00
	00		 mov	 DWORD PTR [esi+7116], ecx

; 1102 :             state->mode = DIST;

  00fd5	c7 46 04 4a 3f
	00 00		 mov	 DWORD PTR [esi+4], 16202 ; 00003f4aH
$LN733@inflate:

; 1103 :         case DIST:
; 1104 :             for (;;) {
; 1105 :                 here = state->distcode[BITS(state->distbits)];

  00fdc	8b 4e 5c	 mov	 ecx, DWORD PTR [esi+92]
  00fdf	b8 01 00 00 00	 mov	 eax, 1
  00fe4	d3 e0		 shl	 eax, cl
  00fe6	48		 dec	 eax
  00fe7	23 c3		 and	 eax, ebx
  00fe9	8b c8		 mov	 ecx, eax
  00feb	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  00fee	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]

; 1106 :                 if ((unsigned)(here.bits) <= bits) break;

  00ff1	8b c8		 mov	 ecx, eax
  00ff3	c1 e9 08	 shr	 ecx, 8
  00ff6	0f b6 c9	 movzx	 ecx, cl
  00ff9	89 45 f4	 mov	 DWORD PTR _here$[ebp], eax
  00ffc	3b cf		 cmp	 ecx, edi
  00ffe	76 3f		 jbe	 SHORT $LN568@inflate
$LL98@inflate:

; 1107 :                 PULLBYTE();

  01000	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  01004	0f 84 f5 03 00
	00		 je	 $inf_leave$3959
  0100a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0100d	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  01010	8b cf		 mov	 ecx, edi
  01012	d3 e0		 shl	 eax, cl
  01014	8b 4e 5c	 mov	 ecx, DWORD PTR [esi+92]
  01017	42		 inc	 edx
  01018	83 c7 08	 add	 edi, 8
  0101b	03 d8		 add	 ebx, eax
  0101d	b8 01 00 00 00	 mov	 eax, 1
  01022	d3 e0		 shl	 eax, cl
  01024	8b 4e 54	 mov	 ecx, DWORD PTR [esi+84]
  01027	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  0102a	48		 dec	 eax
  0102b	23 c3		 and	 eax, ebx
  0102d	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  01030	8b c8		 mov	 ecx, eax
  01032	c1 e9 08	 shr	 ecx, 8
  01035	0f b6 c9	 movzx	 ecx, cl
  01038	89 45 f4	 mov	 DWORD PTR _here$[ebp], eax
  0103b	3b cf		 cmp	 ecx, edi
  0103d	77 c1		 ja	 SHORT $LL98@inflate
$LN568@inflate:

; 1108 :             }
; 1109 :             if ((here.op & 0xf0) == 0) {

  0103f	a8 f0		 test	 al, 240			; 000000f0H
  01041	0f 85 b0 00 00
	00		 jne	 $LN80@inflate

; 1110 :                 last = here;
; 1111 :                 for (;;) {
; 1112 :                     here = state->distcode[last.val +
; 1113 :                             (BITS(last.bits + last.op) >> last.bits)];

  01047	8b c8		 mov	 ecx, eax
  01049	c1 e9 08	 shr	 ecx, 8
  0104c	89 4d d4	 mov	 DWORD PTR tv2420[ebp], ecx
  0104f	0f b6 c9	 movzx	 ecx, cl
  01052	89 4d e4	 mov	 DWORD PTR tv2421[ebp], ecx
  01055	0f b6 c8	 movzx	 ecx, al
  01058	03 4d e4	 add	 ecx, DWORD PTR tv2421[ebp]
  0105b	89 45 dc	 mov	 DWORD PTR _last$[ebp], eax
  0105e	b8 01 00 00 00	 mov	 eax, 1
  01063	d3 e0		 shl	 eax, cl
  01065	8b 4d e4	 mov	 ecx, DWORD PTR tv2421[ebp]
  01068	48		 dec	 eax
  01069	23 c3		 and	 eax, ebx
  0106b	d3 e8		 shr	 eax, cl
  0106d	8b 4d f4	 mov	 ecx, DWORD PTR _here$[ebp]
  01070	c1 e9 10	 shr	 ecx, 16			; 00000010H
  01073	03 c1		 add	 eax, ecx
  01075	8b c8		 mov	 ecx, eax
  01077	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  0107a	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]

; 1114 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  0107d	0f b6 4d d4	 movzx	 ecx, BYTE PTR tv2420[ebp]
  01081	89 45 f4	 mov	 DWORD PTR _here$[ebp], eax
  01084	c1 e8 08	 shr	 eax, 8
  01087	0f b6 c0	 movzx	 eax, al
  0108a	03 c1		 add	 eax, ecx
  0108c	3b c7		 cmp	 eax, edi
  0108e	76 56		 jbe	 SHORT $LN83@inflate
$LL90@inflate:

; 1115 :                     PULLBYTE();

  01090	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  01094	0f 84 65 03 00
	00		 je	 $inf_leave$3959
  0109a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0109d	8b cf		 mov	 ecx, edi
  0109f	d3 e0		 shl	 eax, cl
  010a1	8b 4d dc	 mov	 ecx, DWORD PTR _last$[ebp]
  010a4	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  010a7	42		 inc	 edx
  010a8	03 d8		 add	 ebx, eax
  010aa	0f b6 c5	 movzx	 eax, ch
  010ad	89 45 e4	 mov	 DWORD PTR tv2519[ebp], eax
  010b0	0f b6 c9	 movzx	 ecx, cl
  010b3	03 c8		 add	 ecx, eax
  010b5	b8 01 00 00 00	 mov	 eax, 1
  010ba	d3 e0		 shl	 eax, cl
  010bc	8b 4d e4	 mov	 ecx, DWORD PTR tv2519[ebp]
  010bf	83 c7 08	 add	 edi, 8
  010c2	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  010c5	48		 dec	 eax
  010c6	23 c3		 and	 eax, ebx
  010c8	d3 e8		 shr	 eax, cl
  010ca	0f b7 4d de	 movzx	 ecx, WORD PTR _last$[ebp+2]
  010ce	03 c1		 add	 eax, ecx
  010d0	8b 4e 54	 mov	 ecx, DWORD PTR [esi+84]
  010d3	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  010d6	89 45 f4	 mov	 DWORD PTR _here$[ebp], eax
  010d9	c1 e8 08	 shr	 eax, 8
  010dc	0f b6 c0	 movzx	 eax, al
  010df	03 45 e4	 add	 eax, DWORD PTR tv2519[ebp]
  010e2	3b c7		 cmp	 eax, edi
  010e4	77 aa		 ja	 SHORT $LL90@inflate
$LN83@inflate:

; 1116 :                 }
; 1117 :                 DROPBITS(last.bits);

  010e6	0f b6 4d dd	 movzx	 ecx, BYTE PTR _last$[ebp+1]

; 1118 :                 state->back += last.bits;

  010ea	8b 45 f4	 mov	 eax, DWORD PTR _here$[ebp]
  010ed	d3 eb		 shr	 ebx, cl
  010ef	2b f9		 sub	 edi, ecx
  010f1	01 8e c8 1b 00
	00		 add	 DWORD PTR [esi+7112], ecx
$LN80@inflate:

; 1119 :             }
; 1120 :             DROPBITS(here.bits);

  010f7	8b c8		 mov	 ecx, eax
  010f9	c1 e9 08	 shr	 ecx, 8
  010fc	0f b6 c9	 movzx	 ecx, cl

; 1121 :             state->back += here.bits;

  010ff	01 8e c8 1b 00
	00		 add	 DWORD PTR [esi+7112], ecx
  01105	d3 eb		 shr	 ebx, cl
  01107	2b f9		 sub	 edi, ecx
  01109	89 4d e4	 mov	 DWORD PTR tv2421[ebp], ecx

; 1122 :             if (here.op & 64) {

  0110c	a8 40		 test	 al, 64			; 00000040H
  0110e	74 0f		 je	 SHORT $LN77@inflate

; 1123 :                 strm->msg = (char *)"invalid distance code";

  01110	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01113	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@

; 1124 :                 state->mode = BAD;
; 1125 :                 break;

  0111a	e9 78 02 00 00	 jmp	 $LN788@inflate
$LN77@inflate:

; 1126 :             }
; 1127 :             state->offset = (unsigned)here.val;

  0111f	8b c8		 mov	 ecx, eax

; 1128 :             state->extra = (unsigned)(here.op) & 15;

  01121	0f b6 c0	 movzx	 eax, al
  01124	c1 e9 10	 shr	 ecx, 16			; 00000010H
  01127	83 e0 0f	 and	 eax, 15			; 0000000fH
  0112a	89 4e 48	 mov	 DWORD PTR [esi+72], ecx
  0112d	89 46 4c	 mov	 DWORD PTR [esi+76], eax

; 1129 :             state->mode = DISTEXT;

  01130	c7 46 04 4b 3f
	00 00		 mov	 DWORD PTR [esi+4], 16203 ; 00003f4bH
$LN76@inflate:

; 1130 :         case DISTEXT:
; 1131 :             if (state->extra) {

  01137	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  0113a	85 c0		 test	 eax, eax
  0113c	74 40		 je	 SHORT $LN75@inflate

; 1132 :                 NEEDBITS(state->extra);

  0113e	3b f8		 cmp	 edi, eax
  01140	73 22		 jae	 SHORT $LN73@inflate
$LL71@inflate:
  01142	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  01146	0f 84 b3 02 00
	00		 je	 $inf_leave$3959
  0114c	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0114f	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  01152	8b cf		 mov	 ecx, edi
  01154	d3 e0		 shl	 eax, cl
  01156	42		 inc	 edx
  01157	83 c7 08	 add	 edi, 8
  0115a	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  0115d	03 d8		 add	 ebx, eax
  0115f	3b 7e 4c	 cmp	 edi, DWORD PTR [esi+76]
  01162	72 de		 jb	 SHORT $LL71@inflate
$LN73@inflate:

; 1133 :                 state->offset += BITS(state->extra);

  01164	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  01167	b8 01 00 00 00	 mov	 eax, 1
  0116c	d3 e0		 shl	 eax, cl

; 1134 :                 DROPBITS(state->extra);

  0116e	2b f9		 sub	 edi, ecx
  01170	48		 dec	 eax
  01171	23 c3		 and	 eax, ebx
  01173	01 46 48	 add	 DWORD PTR [esi+72], eax
  01176	d3 eb		 shr	 ebx, cl

; 1135 :                 state->back += state->extra;

  01178	01 8e c8 1b 00
	00		 add	 DWORD PTR [esi+7112], ecx
$LN75@inflate:

; 1136 :             }
; 1137 : #ifdef INFLATE_STRICT
; 1138 :             if (state->offset > state->dmax) {
; 1139 :                 strm->msg = (char *)"invalid distance too far back";
; 1140 :                 state->mode = BAD;
; 1141 :                 break;
; 1142 :             }
; 1143 : #endif
; 1144 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1145 :             state->mode = MATCH;

  0117e	c7 46 04 4c 3f
	00 00		 mov	 DWORD PTR [esi+4], 16204 ; 00003f4cH
$LN736@inflate:

; 1146 :         case MATCH:
; 1147 :             if (left == 0) goto inf_leave;

  01185	83 7d f0 00	 cmp	 DWORD PTR _left$[ebp], 0
  01189	0f 84 70 02 00
	00		 je	 $inf_leave$3959

; 1148 :             copy = out - left;

  0118f	8b 4d e0	 mov	 ecx, DWORD PTR _out$[ebp]
  01192	2b 4d f0	 sub	 ecx, DWORD PTR _left$[ebp]

; 1149 :             if (state->offset > copy) {         /* copy from window */

  01195	8b 46 48	 mov	 eax, DWORD PTR [esi+72]
  01198	3b c1		 cmp	 eax, ecx
  0119a	76 54		 jbe	 SHORT $LN60@inflate

; 1150 :                 copy = state->offset - copy;

  0119c	2b c1		 sub	 eax, ecx
  0119e	89 45 f4	 mov	 DWORD PTR _copy$[ebp], eax

; 1151 :                 if (copy > state->whave) {

  011a1	3b 46 30	 cmp	 eax, DWORD PTR [esi+48]
  011a4	76 18		 jbe	 SHORT $LN58@inflate

; 1152 :                     if (state->sane) {

  011a6	83 be c4 1b 00
	00 00		 cmp	 DWORD PTR [esi+7108], 0
  011ad	74 0f		 je	 SHORT $LN58@inflate

; 1153 :                         strm->msg = (char *)"invalid distance too far back";

  011af	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  011b2	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@

; 1154 :                         state->mode = BAD;
; 1155 :                         break;

  011b9	e9 d9 01 00 00	 jmp	 $LN788@inflate
$LN58@inflate:

; 1156 :                     }
; 1157 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1158 :                     Trace((stderr, "inflate.c too far\n"));
; 1159 :                     copy -= state->whave;
; 1160 :                     if (copy > state->length) copy = state->length;
; 1161 :                     if (copy > left) copy = left;
; 1162 :                     left -= copy;
; 1163 :                     state->length -= copy;
; 1164 :                     do {
; 1165 :                         *put++ = 0;
; 1166 :                     } while (--copy);
; 1167 :                     if (state->length == 0) state->mode = LEN;
; 1168 :                     break;
; 1169 : #endif
; 1170 :                 }
; 1171 :                 if (copy > state->wnext) {

  011be	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  011c1	3b c1		 cmp	 eax, ecx
  011c3	76 0f		 jbe	 SHORT $LN57@inflate

; 1172 :                     copy -= state->wnext;

  011c5	2b c1		 sub	 eax, ecx

; 1173 :                     from = state->window + (state->wsize - copy);

  011c7	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  011ca	03 4e 2c	 add	 ecx, DWORD PTR [esi+44]
  011cd	89 45 f4	 mov	 DWORD PTR _copy$[ebp], eax
  011d0	2b c8		 sub	 ecx, eax

; 1174 :                 }
; 1175 :                 else

  011d2	eb 0b		 jmp	 SHORT $LN784@inflate
$LN57@inflate:

; 1176 :                     from = state->window + (state->wnext - copy);

  011d4	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  011d7	2b c8		 sub	 ecx, eax
  011d9	03 4e 34	 add	 ecx, DWORD PTR [esi+52]
  011dc	8b 45 f4	 mov	 eax, DWORD PTR _copy$[ebp]
$LN784@inflate:
  011df	89 4d d4	 mov	 DWORD PTR _from$[ebp], ecx

; 1177 :                 if (copy > state->length) copy = state->length;

  011e2	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  011e5	89 4d dc	 mov	 DWORD PTR tv2263[ebp], ecx
  011e8	3b c1		 cmp	 eax, ecx
  011ea	76 15		 jbe	 SHORT $LN54@inflate
  011ec	8b c1		 mov	 eax, ecx

; 1178 :             }
; 1179 :             else {                              /* copy from output */

  011ee	eb 0e		 jmp	 SHORT $LN785@inflate
$LN60@inflate:

; 1180 :                 from = put - state->offset;

  011f0	8b 4d e8	 mov	 ecx, DWORD PTR _put$[ebp]
  011f3	2b c8		 sub	 ecx, eax

; 1181 :                 copy = state->length;

  011f5	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  011f8	89 4d d4	 mov	 DWORD PTR _from$[ebp], ecx
  011fb	89 45 dc	 mov	 DWORD PTR tv2263[ebp], eax
$LN785@inflate:
  011fe	89 45 f4	 mov	 DWORD PTR _copy$[ebp], eax
$LN54@inflate:

; 1182 :             }
; 1183 :             if (copy > left) copy = left;

  01201	8b 4d f0	 mov	 ecx, DWORD PTR _left$[ebp]
  01204	3b c1		 cmp	 eax, ecx
  01206	76 05		 jbe	 SHORT $LN53@inflate
  01208	8b c1		 mov	 eax, ecx
  0120a	89 45 f4	 mov	 DWORD PTR _copy$[ebp], eax
$LN53@inflate:

; 1184 :             left -= copy;

  0120d	2b c8		 sub	 ecx, eax
  0120f	89 4d f0	 mov	 DWORD PTR _left$[ebp], ecx

; 1185 :             state->length -= copy;

  01212	8b 4d dc	 mov	 ecx, DWORD PTR tv2263[ebp]
  01215	2b c8		 sub	 ecx, eax

; 1188 :             } while (--copy);

  01217	8b 45 e8	 mov	 eax, DWORD PTR _put$[ebp]
  0121a	89 4e 44	 mov	 DWORD PTR [esi+68], ecx
  0121d	8b 4d d4	 mov	 ecx, DWORD PTR _from$[ebp]
  01220	2b 4d e8	 sub	 ecx, DWORD PTR _put$[ebp]
  01223	89 4d d4	 mov	 DWORD PTR tv3179[ebp], ecx
  01226	eb 0b		 jmp	 SHORT $LN52@inflate
  01228	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL737@inflate:
  01230	8b 4d d4	 mov	 ecx, DWORD PTR tv3179[ebp]
$LN52@inflate:

; 1186 :             do {
; 1187 :                 *put++ = *from++;

  01233	8a 0c 01	 mov	 cl, BYTE PTR [ecx+eax]
  01236	8b 45 e8	 mov	 eax, DWORD PTR _put$[ebp]
  01239	88 08		 mov	 BYTE PTR [eax], cl
  0123b	40		 inc	 eax

; 1188 :             } while (--copy);

  0123c	ff 4d f4	 dec	 DWORD PTR _copy$[ebp]
  0123f	89 45 e8	 mov	 DWORD PTR _put$[ebp], eax
  01242	75 ec		 jne	 SHORT $LL737@inflate

; 1189 :             if (state->length == 0) state->mode = LEN;

  01244	83 7e 44 00	 cmp	 DWORD PTR [esi+68], 0
  01248	0f 85 50 01 00
	00		 jne	 $LN491@inflate
  0124e	c7 46 04 48 3f
	00 00		 mov	 DWORD PTR [esi+4], 16200 ; 00003f48H

; 1190 :             break;

  01255	e9 44 01 00 00	 jmp	 $LN491@inflate
$LN48@inflate:

; 1191 :         case LIT:
; 1192 :             if (left == 0) goto inf_leave;

  0125a	83 7d f0 00	 cmp	 DWORD PTR _left$[ebp], 0
  0125e	0f 84 9b 01 00
	00		 je	 $inf_leave$3959

; 1193 :             *put++ = (unsigned char)(state->length);

  01264	8b 45 e8	 mov	 eax, DWORD PTR _put$[ebp]
  01267	8a 4e 44	 mov	 cl, BYTE PTR [esi+68]
  0126a	88 08		 mov	 BYTE PTR [eax], cl
  0126c	40		 inc	 eax

; 1194 :             left--;

  0126d	ff 4d f0	 dec	 DWORD PTR _left$[ebp]
  01270	89 45 e8	 mov	 DWORD PTR _put$[ebp], eax

; 1195 :             state->mode = LEN;

  01273	c7 46 04 48 3f
	00 00		 mov	 DWORD PTR [esi+4], 16200 ; 00003f48H

; 1196 :             break;

  0127a	e9 1f 01 00 00	 jmp	 $LN491@inflate
$LN46@inflate:

; 1197 :         case CHECK:
; 1198 :             if (state->wrap) {

  0127f	83 7e 0c 00	 cmp	 DWORD PTR [esi+12], 0
  01283	0f 84 bd 00 00
	00		 je	 $LN31@inflate

; 1199 :                 NEEDBITS(32);

  01289	83 ff 20	 cmp	 edi, 32			; 00000020H
  0128c	73 24		 jae	 SHORT $LN43@inflate
  0128e	8b ff		 npad	 2
$LL41@inflate:
  01290	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  01294	0f 84 65 01 00
	00		 je	 $inf_leave$3959
  0129a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0129d	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  012a0	8b cf		 mov	 ecx, edi
  012a2	d3 e0		 shl	 eax, cl
  012a4	42		 inc	 edx
  012a5	83 c7 08	 add	 edi, 8
  012a8	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  012ab	03 d8		 add	 ebx, eax
  012ad	83 ff 20	 cmp	 edi, 32			; 00000020H
  012b0	72 de		 jb	 SHORT $LL41@inflate
$LN43@inflate:

; 1200 :                 out -= left;

  012b2	8b 45 e0	 mov	 eax, DWORD PTR _out$[ebp]
  012b5	2b 45 f0	 sub	 eax, DWORD PTR _left$[ebp]

; 1201 :                 strm->total_out += out;

  012b8	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  012bb	01 41 14	 add	 DWORD PTR [ecx+20], eax

; 1202 :                 state->total += out;

  012be	01 46 20	 add	 DWORD PTR [esi+32], eax

; 1203 :                 if ((state->wrap & 4) && out)

  012c1	f6 46 0c 04	 test	 BYTE PTR [esi+12], 4
  012c5	89 45 e0	 mov	 DWORD PTR _out$[ebp], eax
  012c8	74 30		 je	 SHORT $LN739@inflate
  012ca	85 c0		 test	 eax, eax
  012cc	74 2c		 je	 SHORT $LN739@inflate

; 1204 :                     strm->adler = state->check =
; 1205 :                         UPDATE(state->check, put - out, out);

  012ce	8b 4d e8	 mov	 ecx, DWORD PTR _put$[ebp]
  012d1	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  012d4	50		 push	 eax
  012d5	2b c8		 sub	 ecx, eax
  012d7	83 7e 14 00	 cmp	 DWORD PTR [esi+20], 0
  012db	51		 push	 ecx
  012dc	52		 push	 edx
  012dd	74 07		 je	 SHORT $LN505@inflate
  012df	e8 00 00 00 00	 call	 _crc32
  012e4	eb 05		 jmp	 SHORT $LN786@inflate
$LN505@inflate:
  012e6	e8 00 00 00 00	 call	 _adler32
$LN786@inflate:
  012eb	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  012ee	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  012f1	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  012f4	83 c4 0c	 add	 esp, 12			; 0000000cH
  012f7	89 41 30	 mov	 DWORD PTR [ecx+48], eax
$LN739@inflate:

; 1206 :                 out = left;
; 1207 :                 if ((state->wrap & 4) && (
; 1208 : #ifdef GUNZIP
; 1209 :                      state->flags ? hold :
; 1210 : #endif
; 1211 :                      ZSWAP32(hold)) != state->check) {

  012fa	f6 46 0c 04	 test	 BYTE PTR [esi+12], 4
  012fe	8b 45 f0	 mov	 eax, DWORD PTR _left$[ebp]
  01301	89 45 e0	 mov	 DWORD PTR _out$[ebp], eax
  01304	74 3c		 je	 SHORT $LN33@inflate
  01306	83 7e 14 00	 cmp	 DWORD PTR [esi+20], 0
  0130a	8b c3		 mov	 eax, ebx
  0130c	75 23		 jne	 SHORT $LN508@inflate
  0130e	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  01313	8b cb		 mov	 ecx, ebx
  01315	c1 e1 10	 shl	 ecx, 16			; 00000010H
  01318	03 c1		 add	 eax, ecx
  0131a	8b cb		 mov	 ecx, ebx
  0131c	c1 e9 08	 shr	 ecx, 8
  0131f	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  01325	c1 e0 08	 shl	 eax, 8
  01328	03 c1		 add	 eax, ecx
  0132a	8b cb		 mov	 ecx, ebx
  0132c	c1 e9 18	 shr	 ecx, 24			; 00000018H
  0132f	03 c1		 add	 eax, ecx
$LN508@inflate:
  01331	3b 46 1c	 cmp	 eax, DWORD PTR [esi+28]
  01334	74 0c		 je	 SHORT $LN33@inflate

; 1212 :                     strm->msg = (char *)"incorrect data check";

  01336	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01339	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@

; 1213 :                     state->mode = BAD;
; 1214 :                     break;

  01340	eb 55		 jmp	 SHORT $LN788@inflate
$LN33@inflate:

; 1215 :                 }
; 1216 :                 INITBITS();

  01342	33 db		 xor	 ebx, ebx
  01344	33 ff		 xor	 edi, edi
$LN31@inflate:

; 1217 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1218 :             }
; 1219 : #ifdef GUNZIP
; 1220 :             state->mode = LENGTH;

  01346	c7 46 04 4f 3f
	00 00		 mov	 DWORD PTR [esi+4], 16207 ; 00003f4fH
$LN741@inflate:

; 1221 :         case LENGTH:
; 1222 :             if (state->wrap && state->flags) {

  0134d	83 7e 0c 00	 cmp	 DWORD PTR [esi+12], 0
  01351	0f 84 91 00 00
	00		 je	 $LN16@inflate
  01357	83 7e 14 00	 cmp	 DWORD PTR [esi+20], 0
  0135b	0f 84 87 00 00
	00		 je	 $LN16@inflate

; 1223 :                 NEEDBITS(32);

  01361	83 ff 20	 cmp	 edi, 32			; 00000020H
  01364	73 22		 jae	 SHORT $LN27@inflate
$LL25@inflate:
  01366	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  0136a	0f 84 8f 00 00
	00		 je	 $inf_leave$3959
  01370	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  01373	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  01376	8b cf		 mov	 ecx, edi
  01378	d3 e0		 shl	 eax, cl
  0137a	42		 inc	 edx
  0137b	83 c7 08	 add	 edi, 8
  0137e	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  01381	03 d8		 add	 ebx, eax
  01383	83 ff 20	 cmp	 edi, 32			; 00000020H
  01386	72 de		 jb	 SHORT $LL25@inflate
$LN27@inflate:

; 1224 :                 if (hold != (state->total & 0xffffffffUL)) {

  01388	3b 5e 20	 cmp	 ebx, DWORD PTR [esi+32]
  0138b	74 57		 je	 SHORT $LN18@inflate

; 1225 :                     strm->msg = (char *)"incorrect length check";

  0138d	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01390	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
$LN788@inflate:

; 1226 :                     state->mode = BAD;

  01397	c7 46 04 51 3f
	00 00		 mov	 DWORD PTR [esi+4], 16209 ; 00003f51H
$LN491@inflate:

; 653  :     out = left;
; 654  :     ret = Z_OK;
; 655  :     for (;;)
; 656  :         switch (state->mode) {

  0139e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  013a1	2d 34 3f 00 00	 sub	 eax, 16180		; 00003f34H
  013a6	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  013a9	0f 86 d2 ec ff
	ff		 jbe	 $LL494@inflate
$LN12@inflate:

; 1239 :             goto inf_leave;
; 1240 :         case MEM:
; 1241 :             return Z_MEM_ERROR;
; 1242 :         case SYNC:
; 1243 :         default:
; 1244 :             return Z_STREAM_ERROR;

  013af	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
$LN780@inflate:
  013b4	5f		 pop	 edi
  013b5	5b		 pop	 ebx
  013b6	5e		 pop	 esi

; 1274 :     return ret;
; 1275 : }

  013b7	8b e5		 mov	 esp, ebp
  013b9	5d		 pop	 ebp
  013ba	c3		 ret	 0
$LN580@inflate:

; 844  :                 RESTORE();

  013bb	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  013be	8b 4d e8	 mov	 ecx, DWORD PTR _put$[ebp]
  013c1	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  013c4	8b 4d f0	 mov	 ecx, DWORD PTR _left$[ebp]
  013c7	89 10		 mov	 DWORD PTR [eax], edx
  013c9	8b 55 fc	 mov	 edx, DWORD PTR _have$[ebp]
  013cc	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  013cf	89 50 04	 mov	 DWORD PTR [eax+4], edx
  013d2	89 7e 40	 mov	 DWORD PTR [esi+64], edi
  013d5	5f		 pop	 edi
  013d6	89 5e 3c	 mov	 DWORD PTR [esi+60], ebx
  013d9	5b		 pop	 ebx

; 845  :                 return Z_NEED_DICT;

  013da	b8 02 00 00 00	 mov	 eax, 2
  013df	5e		 pop	 esi

; 1274 :     return ret;
; 1275 : }

  013e0	8b e5		 mov	 esp, ebp
  013e2	5d		 pop	 ebp
  013e3	c3		 ret	 0
$LN18@inflate:

; 1227 :                     break;
; 1228 :                 }
; 1229 :                 INITBITS();

  013e4	33 db		 xor	 ebx, ebx
  013e6	33 ff		 xor	 edi, edi
$LN16@inflate:

; 1230 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1231 :             }
; 1232 : #endif
; 1233 :             state->mode = DONE;

  013e8	c7 46 04 50 3f
	00 00		 mov	 DWORD PTR [esi+4], 16208 ; 00003f50H
$LN746@inflate:

; 1234 :         case DONE:
; 1235 :             ret = Z_STREAM_END;

  013ef	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 1

; 1236 :             goto inf_leave;

  013f6	eb 07		 jmp	 SHORT $inf_leave$3959
$LN14@inflate:

; 1237 :         case BAD:
; 1238 :             ret = Z_DATA_ERROR;

  013f8	c7 45 d8 fd ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -3 ; fffffffdH
$inf_leave$3959:

; 1245 :         }
; 1246 : 
; 1247 :     /*
; 1248 :        Return from inflate(), updating the total counts and the check value.
; 1249 :        If there was no progress during the inflate() call, return a buffer
; 1250 :        error.  Call updatewindow() to create and/or update the window state.
; 1251 :        Note: a memory error from inflate() is non-recoverable.
; 1252 :      */
; 1253 :   inf_leave:
; 1254 :     RESTORE();

  013ff	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01402	8b 4d e8	 mov	 ecx, DWORD PTR _put$[ebp]
  01405	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  01408	8b 4d f0	 mov	 ecx, DWORD PTR _left$[ebp]
  0140b	89 10		 mov	 DWORD PTR [eax], edx
  0140d	8b 55 fc	 mov	 edx, DWORD PTR _have$[ebp]
  01410	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  01413	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1255 :     if (state->wsize || (out != strm->avail_out && state->mode < BAD &&
; 1256 :             (state->mode < CHECK || flush != Z_FINISH)))

  01416	83 7e 2c 00	 cmp	 DWORD PTR [esi+44], 0
  0141a	89 5e 3c	 mov	 DWORD PTR [esi+60], ebx
  0141d	89 7e 40	 mov	 DWORD PTR [esi+64], edi
  01420	75 1f		 jne	 SHORT $LN6@inflate
  01422	8b 4d e0	 mov	 ecx, DWORD PTR _out$[ebp]
  01425	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  01428	74 43		 je	 SHORT $LN5@inflate
  0142a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0142d	3d 51 3f 00 00	 cmp	 eax, 16209		; 00003f51H
  01432	7d 39		 jge	 SHORT $LN5@inflate
  01434	3d 4e 3f 00 00	 cmp	 eax, 16206		; 00003f4eH
  01439	7c 06		 jl	 SHORT $LN6@inflate
  0143b	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  0143f	74 2c		 je	 SHORT $LN5@inflate
$LN6@inflate:

; 1257 :         if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {

  01441	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01444	8b 4d e0	 mov	 ecx, DWORD PTR _out$[ebp]
  01447	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0144a	2b 48 10	 sub	 ecx, DWORD PTR [eax+16]
  0144d	52		 push	 edx
  0144e	e8 00 00 00 00	 call	 _updatewindow
  01453	83 c4 04	 add	 esp, 4
  01456	85 c0		 test	 eax, eax
  01458	74 13		 je	 SHORT $LN5@inflate

; 1258 :             state->mode = MEM;

  0145a	c7 46 04 52 3f
	00 00		 mov	 DWORD PTR [esi+4], 16210 ; 00003f52H
$LN13@inflate:
  01461	5f		 pop	 edi
  01462	5b		 pop	 ebx

; 1259 :             return Z_MEM_ERROR;

  01463	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  01468	5e		 pop	 esi

; 1274 :     return ret;
; 1275 : }

  01469	8b e5		 mov	 esp, ebp
  0146b	5d		 pop	 ebp
  0146c	c3		 ret	 0
$LN5@inflate:

; 1260 :         }
; 1261 :     in -= strm->avail_in;

  0146d	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
  01470	8b 45 d0	 mov	 eax, DWORD PTR _in$[ebp]
  01473	2b 47 04	 sub	 eax, DWORD PTR [edi+4]

; 1262 :     out -= strm->avail_out;

  01476	8b 5d e0	 mov	 ebx, DWORD PTR _out$[ebp]
  01479	2b 5f 10	 sub	 ebx, DWORD PTR [edi+16]

; 1263 :     strm->total_in += in;

  0147c	01 47 08	 add	 DWORD PTR [edi+8], eax

; 1264 :     strm->total_out += out;

  0147f	01 5f 14	 add	 DWORD PTR [edi+20], ebx

; 1265 :     state->total += out;

  01482	01 5e 20	 add	 DWORD PTR [esi+32], ebx

; 1266 :     if ((state->wrap & 4) && out)

  01485	f6 46 0c 04	 test	 BYTE PTR [esi+12], 4
  01489	89 45 d0	 mov	 DWORD PTR _in$[ebp], eax
  0148c	74 34		 je	 SHORT $LN702@inflate
  0148e	85 db		 test	 ebx, ebx
  01490	74 30		 je	 SHORT $LN702@inflate

; 1267 :         strm->adler = state->check =
; 1268 :             UPDATE(state->check, strm->next_out - out, out);

  01492	83 7e 14 00	 cmp	 DWORD PTR [esi+20], 0
  01496	53		 push	 ebx
  01497	74 11		 je	 SHORT $LN509@inflate
  01499	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0149c	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  0149f	2b c3		 sub	 eax, ebx
  014a1	50		 push	 eax
  014a2	51		 push	 ecx
  014a3	e8 00 00 00 00	 call	 _crc32
  014a8	eb 0f		 jmp	 SHORT $LN787@inflate
$LN509@inflate:
  014aa	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  014ad	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  014b0	2b d3		 sub	 edx, ebx
  014b2	52		 push	 edx
  014b3	50		 push	 eax
  014b4	e8 00 00 00 00	 call	 _adler32
$LN787@inflate:
  014b9	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  014bc	83 c4 0c	 add	 esp, 12			; 0000000cH
  014bf	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN702@inflate:

; 1269 :     strm->data_type = (int)state->bits + (state->last ? 64 : 0) +
; 1270 :                       (state->mode == TYPE ? 128 : 0) +
; 1271 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);

  014c2	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  014c5	3d 47 3f 00 00	 cmp	 eax, 16199		; 00003f47H
  014ca	74 0e		 je	 SHORT $LN511@inflate
  014cc	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR tv1426[ebp], 0
  014d3	3d 42 3f 00 00	 cmp	 eax, 16194		; 00003f42H
  014d8	75 07		 jne	 SHORT $LN512@inflate
$LN511@inflate:
  014da	c7 45 d4 00 01
	00 00		 mov	 DWORD PTR tv1426[ebp], 256 ; 00000100H
$LN512@inflate:
  014e1	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  014e4	f7 d9		 neg	 ecx
  014e6	1b c9		 sbb	 ecx, ecx
  014e8	33 d2		 xor	 edx, edx
  014ea	83 e1 40	 and	 ecx, 64			; 00000040H
  014ed	3d 3f 3f 00 00	 cmp	 eax, 16191		; 00003f3fH
  014f2	0f 95 c2	 setne	 dl
  014f5	03 4d d4	 add	 ecx, DWORD PTR tv1426[ebp]
  014f8	4a		 dec	 edx
  014f9	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  014ff	03 d1		 add	 edx, ecx
  01501	03 56 40	 add	 edx, DWORD PTR [esi+64]

; 1272 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  01504	83 7d d0 00	 cmp	 DWORD PTR _in$[ebp], 0
  01508	89 57 2c	 mov	 DWORD PTR [edi+44], edx
  0150b	75 04		 jne	 SHORT $LN1@inflate
  0150d	85 db		 test	 ebx, ebx
  0150f	74 06		 je	 SHORT $LN2@inflate
$LN1@inflate:
  01511	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  01515	75 17		 jne	 SHORT $LN703@inflate
$LN2@inflate:
  01517	8b 45 d8	 mov	 eax, DWORD PTR _ret$[ebp]
  0151a	85 c0		 test	 eax, eax
  0151c	0f 85 92 fe ff
	ff		 jne	 $LN780@inflate

; 1273 :         ret = Z_BUF_ERROR;

  01522	5f		 pop	 edi
  01523	5b		 pop	 ebx
  01524	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  01529	5e		 pop	 esi

; 1274 :     return ret;
; 1275 : }

  0152a	8b e5		 mov	 esp, ebp
  0152c	5d		 pop	 ebp
  0152d	c3		 ret	 0
$LN703@inflate:

; 1273 :         ret = Z_BUF_ERROR;

  0152e	8b 45 d8	 mov	 eax, DWORD PTR _ret$[ebp]
  01531	5f		 pop	 edi
  01532	5b		 pop	 ebx
  01533	5e		 pop	 esi

; 1274 :     return ret;
; 1275 : }

  01534	8b e5		 mov	 esp, ebp
  01536	5d		 pop	 ebp
  01537	c3		 ret	 0
$LN499@inflate:

; 647  :         return Z_STREAM_ERROR;

  01538	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1274 :     return ret;
; 1275 : }

  0153d	8b e5		 mov	 esp, ebp
  0153f	5d		 pop	 ebp
  01540	c3		 ret	 0
  01541	8d 49 00	 npad	 3
$LN789@inflate:
  01544	00 00 00 00	 DD	 $LN490@inflate
  01548	00 00 00 00	 DD	 $LN457@inflate
  0154c	00 00 00 00	 DD	 $LN437@inflate
  01550	00 00 00 00	 DD	 $LN419@inflate
  01554	00 00 00 00	 DD	 $LN709@inflate
  01558	00 00 00 00	 DD	 $LN711@inflate
  0155c	00 00 00 00	 DD	 $LN712@inflate
  01560	00 00 00 00	 DD	 $LN716@inflate
  01564	00 00 00 00	 DD	 $LN720@inflate
  01568	00 00 00 00	 DD	 $LN333@inflate
  0156c	00 00 00 00	 DD	 $LN722@inflate
  01570	00 00 00 00	 DD	 $LN316@inflate
  01574	00 00 00 00	 DD	 $LN315@inflate
  01578	00 00 00 00	 DD	 $LN282@inflate
  0157c	00 00 00 00	 DD	 $LN266@inflate
  01580	00 00 00 00	 DD	 $LN264@inflate
  01584	00 00 00 00	 DD	 $LN258@inflate
  01588	00 00 00 00	 DD	 $LN726@inflate
  0158c	00 00 00 00	 DD	 $LN529@inflate
  01590	00 00 00 00	 DD	 $LN148@inflate
  01594	00 00 00 00	 DD	 $LN146@inflate
  01598	00 00 00 00	 DD	 $LN113@inflate
  0159c	00 00 00 00	 DD	 $LN733@inflate
  015a0	00 00 00 00	 DD	 $LN76@inflate
  015a4	00 00 00 00	 DD	 $LN736@inflate
  015a8	00 00 00 00	 DD	 $LN48@inflate
  015ac	00 00 00 00	 DD	 $LN46@inflate
  015b0	00 00 00 00	 DD	 $LN741@inflate
  015b4	00 00 00 00	 DD	 $LN746@inflate
  015b8	00 00 00 00	 DD	 $LN14@inflate
  015bc	00 00 00 00	 DD	 $LN13@inflate
$LN790@inflate:
  015c0	00 00 00 00	 DD	 $LN294@inflate
  015c4	00 00 00 00	 DD	 $LN293@inflate
  015c8	00 00 00 00	 DD	 $LN288@inflate
  015cc	00 00 00 00	 DD	 $LN287@inflate
_inflate ENDP
_TEXT	ENDS
PUBLIC	_inflateReset
; Function compile flags: /Ogtp
;	COMDAT _inflateReset
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateReset PROC					; COMDAT

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 147  :     struct inflate_state FAR *state;
; 148  : 
; 149  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	8b c2		 mov	 eax, edx
  00008	e8 00 00 00 00	 call	 _inflateStateCheck
  0000d	85 c0		 test	 eax, eax
  0000f	74 07		 je	 SHORT $LN1@inflateRes@2
  00011	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 155  : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
$LN1@inflateRes@2:

; 150  :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]

; 151  :     state->wsize = 0;

  0001b	33 c9		 xor	 ecx, ecx

; 152  :     state->whave = 0;
; 153  :     state->wnext = 0;
; 154  :     return inflateResetKeep(strm);

  0001d	52		 push	 edx
  0001e	89 48 2c	 mov	 DWORD PTR [eax+44], ecx
  00021	89 48 30	 mov	 DWORD PTR [eax+48], ecx
  00024	89 48 34	 mov	 DWORD PTR [eax+52], ecx
  00027	e8 00 00 00 00	 call	 _inflateResetKeep
  0002c	83 c4 04	 add	 esp, 4

; 155  : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_inflateReset ENDP
PUBLIC	_inflateSync
; Function compile flags: /Ogtp
;	COMDAT _inflateSync
_TEXT	SEGMENT
_out$ = -4						; size = 4
_buf$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateSync PROC					; COMDAT

; 1402 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 1403 :     unsigned len;               /* number of bytes to look at or looked at */
; 1404 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1405 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1406 :     struct inflate_state FAR *state;
; 1407 : 
; 1408 :     /* check parameters */
; 1409 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _strm$[ebp]
  00008	8b c3		 mov	 eax, ebx
  0000a	e8 00 00 00 00	 call	 _inflateStateCheck
  0000f	85 c0		 test	 eax, eax
  00011	74 0a		 je	 SHORT $LN6@inflateSyn@2
  00013	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00018	5b		 pop	 ebx

; 1441 : }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
$LN6@inflateSyn@2:

; 1410 :     state = (struct inflate_state FAR *)strm->state;
; 1411 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  0001d	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  00021	57		 push	 edi
  00022	8b 7b 1c	 mov	 edi, DWORD PTR [ebx+28]
  00025	75 11		 jne	 SHORT $LN5@inflateSyn@2
  00027	83 7f 40 08	 cmp	 DWORD PTR [edi+64], 8
  0002b	73 0b		 jae	 SHORT $LN5@inflateSyn@2
  0002d	5f		 pop	 edi
  0002e	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  00033	5b		 pop	 ebx

; 1441 : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
$LN5@inflateSyn@2:

; 1412 : 
; 1413 :     /* if first time, start search in bit buffer */
; 1414 :     if (state->mode != SYNC) {

  00038	b8 53 3f 00 00	 mov	 eax, 16211		; 00003f53H
  0003d	56		 push	 esi
  0003e	39 47 04	 cmp	 DWORD PTR [edi+4], eax
  00041	74 4c		 je	 SHORT $LN4@inflateSyn@2

; 1415 :         state->mode = SYNC;

  00043	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1416 :         state->hold <<= state->bits & 7;

  00046	8b 47 40	 mov	 eax, DWORD PTR [edi+64]
  00049	8b c8		 mov	 ecx, eax
  0004b	83 e1 07	 and	 ecx, 7
  0004e	d3 67 3c	 shl	 DWORD PTR [edi+60], cl

; 1417 :         state->bits -= state->bits & 7;

  00051	2b c1		 sub	 eax, ecx

; 1418 :         len = 0;

  00053	33 c9		 xor	 ecx, ecx
  00055	89 47 40	 mov	 DWORD PTR [edi+64], eax

; 1419 :         while (state->bits >= 8) {

  00058	83 f8 08	 cmp	 eax, 8
  0005b	72 1c		 jb	 SHORT $LN2@inflateSyn@2
  0005d	8b 77 3c	 mov	 esi, DWORD PTR [edi+60]
$LL3@inflateSyn@2:

; 1420 :             buf[len++] = (unsigned char)(state->hold);

  00060	8a 57 3c	 mov	 dl, BYTE PTR [edi+60]

; 1421 :             state->hold >>= 8;
; 1422 :             state->bits -= 8;

  00063	83 e8 08	 sub	 eax, 8
  00066	88 54 0d fc	 mov	 BYTE PTR _buf$[ebp+ecx], dl
  0006a	c1 ee 08	 shr	 esi, 8
  0006d	41		 inc	 ecx
  0006e	89 77 3c	 mov	 DWORD PTR [edi+60], esi
  00071	89 47 40	 mov	 DWORD PTR [edi+64], eax
  00074	83 f8 08	 cmp	 eax, 8
  00077	73 e7		 jae	 SHORT $LL3@inflateSyn@2
$LN2@inflateSyn@2:

; 1423 :         }
; 1424 :         state->have = 0;

  00079	8d 47 6c	 lea	 eax, DWORD PTR [edi+108]

; 1425 :         syncsearch(&(state->have), buf, len);

  0007c	51		 push	 ecx
  0007d	50		 push	 eax
  0007e	8d 75 fc	 lea	 esi, DWORD PTR _buf$[ebp]
  00081	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00087	e8 00 00 00 00	 call	 _syncsearch
  0008c	83 c4 08	 add	 esp, 8
$LN4@inflateSyn@2:

; 1426 :     }
; 1427 : 
; 1428 :     /* search available input */
; 1429 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  0008f	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00092	8b 33		 mov	 esi, DWORD PTR [ebx]
  00094	8d 47 6c	 lea	 eax, DWORD PTR [edi+108]
  00097	51		 push	 ecx
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 _syncsearch

; 1430 :     strm->avail_in -= len;
; 1431 :     strm->next_in += len;
; 1432 :     strm->total_in += len;

  0009e	01 43 08	 add	 DWORD PTR [ebx+8], eax
  000a1	29 43 04	 sub	 DWORD PTR [ebx+4], eax
  000a4	01 03		 add	 DWORD PTR [ebx], eax
  000a6	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]
  000a9	83 c4 08	 add	 esp, 8

; 1433 : 
; 1434 :     /* return no joy or set up to restart inflate() on a new block */
; 1435 :     if (state->have != 4) return Z_DATA_ERROR;

  000ac	83 7f 6c 04	 cmp	 DWORD PTR [edi+108], 4
  000b0	74 0c		 je	 SHORT $LN1@inflateSyn@2
  000b2	5e		 pop	 esi
  000b3	5f		 pop	 edi
  000b4	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  000b9	5b		 pop	 ebx

; 1441 : }

  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
$LN1@inflateSyn@2:

; 1436 :     in = strm->total_in;  out = strm->total_out;

  000be	8b 53 14	 mov	 edx, DWORD PTR [ebx+20]

; 1437 :     inflateReset(strm);

  000c1	53		 push	 ebx
  000c2	89 55 fc	 mov	 DWORD PTR _out$[ebp], edx
  000c5	e8 00 00 00 00	 call	 _inflateReset

; 1438 :     strm->total_in = in;  strm->total_out = out;

  000ca	8b 45 fc	 mov	 eax, DWORD PTR _out$[ebp]
  000cd	83 c4 04	 add	 esp, 4
  000d0	89 73 08	 mov	 DWORD PTR [ebx+8], esi
  000d3	89 43 14	 mov	 DWORD PTR [ebx+20], eax
  000d6	5e		 pop	 esi

; 1439 :     state->mode = TYPE;

  000d7	c7 47 04 3f 3f
	00 00		 mov	 DWORD PTR [edi+4], 16191 ; 00003f3fH
  000de	5f		 pop	 edi

; 1440 :     return Z_OK;

  000df	33 c0		 xor	 eax, eax
  000e1	5b		 pop	 ebx

; 1441 : }

  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c3		 ret	 0
_inflateSync ENDP
_TEXT	ENDS
PUBLIC	_inflateReset2
; Function compile flags: /Ogtp
;	COMDAT _inflateReset2
_TEXT	SEGMENT
_wrap$ = -4						; size = 4
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_inflateReset2 PROC					; COMDAT

; 160  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 161  :     int wrap;
; 162  :     struct inflate_state FAR *state;
; 163  : 
; 164  :     /* get the state */
; 165  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _strm$[ebp]
  00008	8b c3		 mov	 eax, ebx
  0000a	e8 00 00 00 00	 call	 _inflateStateCheck
  0000f	85 c0		 test	 eax, eax
  00011	74 0a		 je	 SHORT $LN7@inflateRes@3
  00013	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00018	5b		 pop	 ebx

; 193  : }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
$LN7@inflateRes@3:
  0001d	56		 push	 esi

; 166  :     state = (struct inflate_state FAR *)strm->state;
; 167  : 
; 168  :     /* extract wrap request from windowBits parameter */
; 169  :     if (windowBits < 0) {

  0001e	8b 75 0c	 mov	 esi, DWORD PTR _windowBits$[ebp]
  00021	57		 push	 edi
  00022	8b 7b 1c	 mov	 edi, DWORD PTR [ebx+28]
  00025	85 f6		 test	 esi, esi
  00027	79 0b		 jns	 SHORT $LN6@inflateRes@3

; 170  :         wrap = 0;

  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _wrap$[ebp], 0

; 171  :         windowBits = -windowBits;

  00030	f7 de		 neg	 esi

; 172  :     }
; 173  :     else {

  00032	eb 13		 jmp	 SHORT $LN10@inflateRes@3
$LN6@inflateRes@3:

; 174  :         wrap = (windowBits >> 4) + 5;

  00034	8b c6		 mov	 eax, esi
  00036	c1 f8 04	 sar	 eax, 4
  00039	83 c0 05	 add	 eax, 5
  0003c	89 45 fc	 mov	 DWORD PTR _wrap$[ebp], eax

; 175  : #ifdef GUNZIP
; 176  :         if (windowBits < 48)

  0003f	83 fe 30	 cmp	 esi, 48			; 00000030H
  00042	7d 03		 jge	 SHORT $LN10@inflateRes@3

; 177  :             windowBits &= 15;

  00044	83 e6 0f	 and	 esi, 15			; 0000000fH
$LN10@inflateRes@3:

; 178  : #endif
; 179  :     }
; 180  : 
; 181  :     /* set number of window bits, free window if different */
; 182  :     if (windowBits && (windowBits < 8 || windowBits > 15))

  00047	85 f6		 test	 esi, esi
  00049	74 16		 je	 SHORT $LN3@inflateRes@3
  0004b	83 fe 08	 cmp	 esi, 8
  0004e	7c 05		 jl	 SHORT $LN2@inflateRes@3
  00050	83 fe 0f	 cmp	 esi, 15			; 0000000fH
  00053	7e 0c		 jle	 SHORT $LN3@inflateRes@3
$LN2@inflateRes@3:
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi

; 183  :         return Z_STREAM_ERROR;

  00057	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0005c	5b		 pop	 ebx

; 193  : }

  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
$LN3@inflateRes@3:

; 184  :     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {

  00061	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  00064	85 c0		 test	 eax, eax
  00066	74 19		 je	 SHORT $LN1@inflateRes@3
  00068	39 77 28	 cmp	 DWORD PTR [edi+40], esi
  0006b	74 14		 je	 SHORT $LN1@inflateRes@3

; 185  :         ZFREE(strm, state->window);

  0006d	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  00070	50		 push	 eax
  00071	8b 43 28	 mov	 eax, DWORD PTR [ebx+40]
  00074	50		 push	 eax
  00075	ff d1		 call	 ecx
  00077	83 c4 08	 add	 esp, 8

; 186  :         state->window = Z_NULL;

  0007a	c7 47 38 00 00
	00 00		 mov	 DWORD PTR [edi+56], 0
$LN1@inflateRes@3:

; 187  :     }
; 188  : 
; 189  :     /* update state and reset the rest of it */
; 190  :     state->wrap = wrap;

  00081	8b 55 fc	 mov	 edx, DWORD PTR _wrap$[ebp]

; 191  :     state->wbits = (unsigned)windowBits;
; 192  :     return inflateReset(strm);

  00084	53		 push	 ebx
  00085	89 57 0c	 mov	 DWORD PTR [edi+12], edx
  00088	89 77 28	 mov	 DWORD PTR [edi+40], esi
  0008b	e8 00 00 00 00	 call	 _inflateReset
  00090	83 c4 04	 add	 esp, 4
  00093	5f		 pop	 edi
  00094	5e		 pop	 esi
  00095	5b		 pop	 ebx

; 193  : }

  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
_inflateReset2 ENDP
PUBLIC	_inflateInit2_
; Function compile flags: /Ogtp
;	COMDAT _inflateInit2_
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_version$ = 16						; size = 4
_stream_size$ = 20					; size = 4
_inflateInit2_ PROC					; COMDAT

; 200  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 201  :     int ret;
; 202  :     struct inflate_state FAR *state;
; 203  : 
; 204  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
; 205  :         stream_size != (int)(sizeof(z_stream)))

  00003	8b 45 10	 mov	 eax, DWORD PTR _version$[ebp]
  00006	53		 push	 ebx
  00007	33 db		 xor	 ebx, ebx
  00009	3b c3		 cmp	 eax, ebx
  0000b	0f 84 a1 00 00
	00		 je	 $LN6@inflateIni
  00011	80 38 31	 cmp	 BYTE PTR [eax], 49	; 00000031H
  00014	0f 85 98 00 00
	00		 jne	 $LN6@inflateIni
  0001a	83 7d 14 38	 cmp	 DWORD PTR _stream_size$[ebp], 56 ; 00000038H
  0001e	0f 85 8e 00 00
	00		 jne	 $LN6@inflateIni

; 207  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  00024	56		 push	 esi
  00025	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00028	3b f3		 cmp	 esi, ebx
  0002a	75 07		 jne	 SHORT $LN5@inflateIni
  0002c	5e		 pop	 esi
  0002d	8d 43 fe	 lea	 eax, DWORD PTR [ebx-2]
  00030	5b		 pop	 ebx

; 237  : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
$LN5@inflateIni:

; 208  :     strm->msg = Z_NULL;                 /* in case we return an error */

  00033	89 5e 18	 mov	 DWORD PTR [esi+24], ebx

; 209  :     if (strm->zalloc == (alloc_func)0) {

  00036	39 5e 20	 cmp	 DWORD PTR [esi+32], ebx
  00039	75 0a		 jne	 SHORT $LN4@inflateIni

; 210  : #ifdef Z_SOLO
; 211  :         return Z_STREAM_ERROR;
; 212  : #else
; 213  :         strm->zalloc = zcalloc;

  0003b	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], OFFSET _zcalloc

; 214  :         strm->opaque = (voidpf)0;

  00042	89 5e 28	 mov	 DWORD PTR [esi+40], ebx
$LN4@inflateIni:

; 215  : #endif
; 216  :     }
; 217  :     if (strm->zfree == (free_func)0)

  00045	39 5e 24	 cmp	 DWORD PTR [esi+36], ebx
  00048	75 07		 jne	 SHORT $LN3@inflateIni

; 218  : #ifdef Z_SOLO
; 219  :         return Z_STREAM_ERROR;
; 220  : #else
; 221  :         strm->zfree = zcfree;

  0004a	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], OFFSET _zcfree
$LN3@inflateIni:

; 222  : #endif
; 223  :     state = (struct inflate_state FAR *)
; 224  :             ZALLOC(strm, 1, sizeof(struct inflate_state));

  00051	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00054	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00057	57		 push	 edi
  00058	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  0005d	6a 01		 push	 1
  0005f	50		 push	 eax
  00060	ff d1		 call	 ecx
  00062	8b f8		 mov	 edi, eax
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 225  :     if (state == Z_NULL) return Z_MEM_ERROR;

  00067	3b fb		 cmp	 edi, ebx
  00069	75 0a		 jne	 SHORT $LN2@inflateIni
  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi
  0006d	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00072	5b		 pop	 ebx

; 237  : }

  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
$LN2@inflateIni:

; 226  :     Tracev((stderr, "inflate: allocated\n"));
; 227  :     strm->state = (struct internal_state FAR *)state;
; 228  :     state->strm = strm;
; 229  :     state->window = Z_NULL;
; 230  :     state->mode = HEAD;     /* to pass state test in inflateReset2() */
; 231  :     ret = inflateReset2(strm, windowBits);

  00075	8b 55 0c	 mov	 edx, DWORD PTR _windowBits$[ebp]
  00078	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  0007b	52		 push	 edx
  0007c	56		 push	 esi
  0007d	89 37		 mov	 DWORD PTR [edi], esi
  0007f	89 5f 38	 mov	 DWORD PTR [edi+56], ebx
  00082	c7 47 04 34 3f
	00 00		 mov	 DWORD PTR [edi+4], 16180 ; 00003f34H
  00089	e8 00 00 00 00	 call	 _inflateReset2
  0008e	8b d8		 mov	 ebx, eax
  00090	83 c4 08	 add	 esp, 8

; 232  :     if (ret != Z_OK) {

  00093	85 db		 test	 ebx, ebx
  00095	74 14		 je	 SHORT $LN1@inflateIni

; 233  :         ZFREE(strm, state);

  00097	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  0009a	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  0009d	57		 push	 edi
  0009e	50		 push	 eax
  0009f	ff d1		 call	 ecx
  000a1	83 c4 08	 add	 esp, 8

; 234  :         strm->state = Z_NULL;

  000a4	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
$LN1@inflateIni:

; 235  :     }
; 236  :     return ret;

  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	8b c3		 mov	 eax, ebx
  000af	5b		 pop	 ebx

; 237  : }

  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
$LN6@inflateIni:

; 206  :         return Z_VERSION_ERROR;

  000b2	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH
  000b7	5b		 pop	 ebx

; 237  : }

  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
_inflateInit2_ ENDP
PUBLIC	_inflateInit_
; Function compile flags: /Ogtp
;	COMDAT _inflateInit_
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_version$ = 12						; size = 4
_stream_size$ = 16					; size = 4
_inflateInit_ PROC					; COMDAT

; 243  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 244  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  00003	8b 45 10	 mov	 eax, DWORD PTR _stream_size$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _version$[ebp]
  00009	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0000c	50		 push	 eax
  0000d	51		 push	 ecx
  0000e	6a 0f		 push	 15			; 0000000fH
  00010	52		 push	 edx
  00011	e8 00 00 00 00	 call	 _inflateInit2_
  00016	83 c4 10	 add	 esp, 16			; 00000010H

; 245  : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
_inflateInit_ ENDP
END
