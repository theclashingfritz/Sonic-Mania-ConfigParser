; Listing generated by Microsoft (R) Optimizing Compiler Version 19.11.25508.2 

	TITLE	c:\users\theclashingfritz\source\repos\inifileparser\zlib\adler32.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_adler32_combine
PUBLIC	_adler32
PUBLIC	_adler32_z
EXTRN	__alldiv:PROC
EXTRN	__chkstk:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\adler32.c
;	COMDAT _adler32_z
_TEXT	SEGMENT
tv1657 = 8						; size = 4
_adler$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_adler32_z PROC						; COMDAT

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   :     unsigned long sum2;
; 69   :     unsigned n;
; 70   : 
; 71   :     /* split Adler-32 into component sums */
; 72   :     sum2 = (adler >> 16) & 0xffff;

  00003	8b 45 08	 mov	 eax, DWORD PTR _adler$[ebp]
  00006	53		 push	 ebx

; 73   :     adler &= 0xffff;
; 74   : 
; 75   :     /* in case user likes doing a byte at a time, keep it fast */
; 76   :     if (len == 1) {

  00007	8b 5d 10	 mov	 ebx, DWORD PTR _len$[ebp]
  0000a	57		 push	 edi
  0000b	8b f8		 mov	 edi, eax
  0000d	0f b7 c8	 movzx	 ecx, ax
  00010	c1 ef 10	 shr	 edi, 16			; 00000010H
  00013	83 fb 01	 cmp	 ebx, 1
  00016	75 32		 jne	 SHORT $LN13@adler32_z

; 77   :         adler += buf[0];

  00018	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0001b	0f b6 00	 movzx	 eax, BYTE PTR [eax]

; 78   :         if (adler >= BASE)

  0001e	03 c1		 add	 eax, ecx
  00020	3d f1 ff 00 00	 cmp	 eax, 65521		; 0000fff1H
  00025	8d 90 0f 00 ff
	ff		 lea	 edx, DWORD PTR [eax-65521]
  0002b	0f 42 d0	 cmovb	 edx, eax

; 79   :             adler -= BASE;
; 80   :         sum2 += adler;
; 81   :         if (sum2 >= BASE)

  0002e	8d 04 3a	 lea	 eax, DWORD PTR [edx+edi]
  00031	3d f1 ff 00 00	 cmp	 eax, 65521		; 0000fff1H
  00036	8d 88 0f 00 ff
	ff		 lea	 ecx, DWORD PTR [eax-65521]

; 131  : }

  0003c	5f		 pop	 edi
  0003d	0f 42 c8	 cmovb	 ecx, eax
  00040	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00043	0b ca		 or	 ecx, edx
  00045	8b c1		 mov	 eax, ecx
  00047	5b		 pop	 ebx
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
$LN13@adler32_z:

; 82   :             sum2 -= BASE;
; 83   :         return adler | (sum2 << 16);
; 84   :     }
; 85   : 
; 86   :     /* initial Adler-32 value (deferred check for len == 1 speed) */
; 87   :     if (buf == Z_NULL)

  0004a	56		 push	 esi
  0004b	8b 75 0c	 mov	 esi, DWORD PTR _buf$[ebp]
  0004e	85 f6		 test	 esi, esi
  00050	75 08		 jne	 SHORT $LN16@adler32_z

; 88   :         return 1L;

  00052	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00055	5e		 pop	 esi

; 131  : }

  00056	5f		 pop	 edi
  00057	5b		 pop	 ebx
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
$LN16@adler32_z:

; 89   : 
; 90   :     /* in case short lengths are provided, keep it somewhat fast */
; 91   :     if (len < 16) {

  0005a	83 fb 10	 cmp	 ebx, 16			; 00000010H
  0005d	73 3f		 jae	 SHORT $LN22@adler32_z

; 92   :         while (len--) {

  0005f	85 db		 test	 ebx, ebx
  00061	74 0f		 je	 SHORT $LN26@adler32_z
$LL2@adler32_z:

; 93   :             adler += *buf++;

  00063	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00066	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  00069	03 c8		 add	 ecx, eax

; 94   :             sum2 += adler;

  0006b	03 f9		 add	 edi, ecx
  0006d	83 eb 01	 sub	 ebx, 1
  00070	75 f1		 jne	 SHORT $LL2@adler32_z
$LN26@adler32_z:

; 95   :         }
; 96   :         if (adler >= BASE)

  00072	81 f9 f1 ff 00
	00		 cmp	 ecx, 65521		; 0000fff1H
  00078	8d b1 0f 00 ff
	ff		 lea	 esi, DWORD PTR [ecx-65521]

; 97   :             adler -= BASE;
; 98   :         MOD28(sum2);            /* only added so many BASE's */

  0007e	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  00083	0f 42 f1	 cmovb	 esi, ecx
  00086	f7 e7		 mul	 edi
  00088	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  0008b	8b c2		 mov	 eax, edx
  0008d	c1 e0 04	 shl	 eax, 4
  00090	2b c2		 sub	 eax, edx

; 99   :         return adler | (sum2 << 16);

  00092	03 c7		 add	 eax, edi
  00094	c1 e0 10	 shl	 eax, 16			; 00000010H
  00097	0b c6		 or	 eax, esi
  00099	5e		 pop	 esi

; 131  : }

  0009a	5f		 pop	 edi
  0009b	5b		 pop	 ebx
  0009c	5d		 pop	 ebp
  0009d	c3		 ret	 0
$LN22@adler32_z:

; 100  :     }
; 101  : 
; 102  :     /* do length NMAX blocks -- requires just one modulo operation */
; 103  :     while (len >= NMAX) {

  0009e	81 fb b0 15 00
	00		 cmp	 ebx, 5552		; 000015b0H
  000a4	0f 82 df 00 00
	00		 jb	 $LN5@adler32_z
  000aa	b8 af a9 6e 5e	 mov	 eax, 1584310703		; 5e6ea9afH
  000af	f7 e3		 mul	 ebx
  000b1	c1 ea 0b	 shr	 edx, 11			; 0000000bH
  000b4	89 55 08	 mov	 DWORD PTR tv1657[ebp], edx
  000b7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL4@adler32_z:

; 104  :         len -= NMAX;

  000c0	81 eb b0 15 00
	00		 sub	 ebx, 5552		; 000015b0H

; 105  :         n = NMAX / 16;          /* NMAX is divisible by 16 */

  000c6	ba 5b 01 00 00	 mov	 edx, 347		; 0000015bH
  000cb	0f 1f 44 00 00	 npad	 5
$LL8@adler32_z:

; 106  :         do {
; 107  :             DO16(buf);          /* 16 sums unrolled */

  000d0	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  000d3	03 c8		 add	 ecx, eax
  000d5	0f b6 46 01	 movzx	 eax, BYTE PTR [esi+1]
  000d9	03 f9		 add	 edi, ecx
  000db	03 c8		 add	 ecx, eax
  000dd	0f b6 46 02	 movzx	 eax, BYTE PTR [esi+2]
  000e1	03 f9		 add	 edi, ecx
  000e3	03 c8		 add	 ecx, eax
  000e5	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  000e9	03 f9		 add	 edi, ecx
  000eb	03 c8		 add	 ecx, eax
  000ed	0f b6 46 04	 movzx	 eax, BYTE PTR [esi+4]
  000f1	03 f9		 add	 edi, ecx
  000f3	03 c8		 add	 ecx, eax
  000f5	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]
  000f9	03 f9		 add	 edi, ecx
  000fb	03 c8		 add	 ecx, eax
  000fd	0f b6 46 06	 movzx	 eax, BYTE PTR [esi+6]
  00101	03 f9		 add	 edi, ecx
  00103	03 c8		 add	 ecx, eax
  00105	0f b6 46 07	 movzx	 eax, BYTE PTR [esi+7]
  00109	03 f9		 add	 edi, ecx
  0010b	03 c8		 add	 ecx, eax
  0010d	0f b6 46 08	 movzx	 eax, BYTE PTR [esi+8]
  00111	03 f9		 add	 edi, ecx
  00113	03 c8		 add	 ecx, eax
  00115	0f b6 46 09	 movzx	 eax, BYTE PTR [esi+9]
  00119	03 f9		 add	 edi, ecx
  0011b	03 c8		 add	 ecx, eax
  0011d	0f b6 46 0a	 movzx	 eax, BYTE PTR [esi+10]
  00121	03 f9		 add	 edi, ecx
  00123	03 c8		 add	 ecx, eax
  00125	0f b6 46 0b	 movzx	 eax, BYTE PTR [esi+11]
  00129	03 f9		 add	 edi, ecx
  0012b	03 c8		 add	 ecx, eax
  0012d	0f b6 46 0c	 movzx	 eax, BYTE PTR [esi+12]
  00131	03 f9		 add	 edi, ecx
  00133	03 c8		 add	 ecx, eax
  00135	0f b6 46 0d	 movzx	 eax, BYTE PTR [esi+13]
  00139	03 f9		 add	 edi, ecx
  0013b	03 c8		 add	 ecx, eax
  0013d	0f b6 46 0e	 movzx	 eax, BYTE PTR [esi+14]
  00141	03 f9		 add	 edi, ecx
  00143	03 c8		 add	 ecx, eax
  00145	0f b6 46 0f	 movzx	 eax, BYTE PTR [esi+15]
  00149	03 f9		 add	 edi, ecx

; 108  :             buf += 16;

  0014b	83 c6 10	 add	 esi, 16			; 00000010H
  0014e	03 c8		 add	 ecx, eax
  00150	03 f9		 add	 edi, ecx

; 109  :         } while (--n);

  00152	83 ea 01	 sub	 edx, 1
  00155	0f 85 75 ff ff
	ff		 jne	 $LL8@adler32_z

; 110  :         MOD(adler);

  0015b	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  00160	f7 e1		 mul	 ecx
  00162	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  00165	69 c2 0f 00 ff
	ff		 imul	 eax, edx, -65521
  0016b	03 c8		 add	 ecx, eax

; 111  :         MOD(sum2);

  0016d	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  00172	f7 e7		 mul	 edi
  00174	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  00177	69 c2 0f 00 ff
	ff		 imul	 eax, edx, -65521
  0017d	03 f8		 add	 edi, eax
  0017f	83 6d 08 01	 sub	 DWORD PTR tv1657[ebp], 1
  00183	0f 85 37 ff ff
	ff		 jne	 $LL4@adler32_z
$LN5@adler32_z:

; 112  :     }
; 113  : 
; 114  :     /* do remaining bytes (less than NMAX, still just one modulo) */
; 115  :     if (len) {                  /* avoid modulos if none remaining */

  00189	85 db		 test	 ebx, ebx
  0018b	0f 84 d4 00 00
	00		 je	 $LN19@adler32_z

; 116  :         while (len >= 16) {

  00191	83 fb 10	 cmp	 ebx, 16			; 00000010H
  00194	0f 82 94 00 00
	00		 jb	 $LN25@adler32_z
  0019a	8b d3		 mov	 edx, ebx
  0019c	c1 ea 04	 shr	 edx, 4
  0019f	90		 npad	 1
$LL9@adler32_z:

; 117  :             len -= 16;
; 118  :             DO16(buf);

  001a0	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  001a3	83 eb 10	 sub	 ebx, 16			; 00000010H
  001a6	03 c8		 add	 ecx, eax
  001a8	0f b6 46 01	 movzx	 eax, BYTE PTR [esi+1]
  001ac	03 f9		 add	 edi, ecx
  001ae	03 c8		 add	 ecx, eax
  001b0	0f b6 46 02	 movzx	 eax, BYTE PTR [esi+2]
  001b4	03 f9		 add	 edi, ecx
  001b6	03 c8		 add	 ecx, eax
  001b8	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  001bc	03 f9		 add	 edi, ecx
  001be	03 c8		 add	 ecx, eax
  001c0	0f b6 46 04	 movzx	 eax, BYTE PTR [esi+4]
  001c4	03 f9		 add	 edi, ecx
  001c6	03 c8		 add	 ecx, eax
  001c8	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]
  001cc	03 f9		 add	 edi, ecx
  001ce	03 c8		 add	 ecx, eax
  001d0	0f b6 46 06	 movzx	 eax, BYTE PTR [esi+6]
  001d4	03 f9		 add	 edi, ecx
  001d6	03 c8		 add	 ecx, eax
  001d8	0f b6 46 07	 movzx	 eax, BYTE PTR [esi+7]
  001dc	03 f9		 add	 edi, ecx
  001de	03 c8		 add	 ecx, eax
  001e0	0f b6 46 08	 movzx	 eax, BYTE PTR [esi+8]
  001e4	03 f9		 add	 edi, ecx
  001e6	03 c8		 add	 ecx, eax
  001e8	0f b6 46 09	 movzx	 eax, BYTE PTR [esi+9]
  001ec	03 f9		 add	 edi, ecx
  001ee	03 c8		 add	 ecx, eax
  001f0	0f b6 46 0a	 movzx	 eax, BYTE PTR [esi+10]
  001f4	03 f9		 add	 edi, ecx
  001f6	03 c8		 add	 ecx, eax
  001f8	0f b6 46 0b	 movzx	 eax, BYTE PTR [esi+11]
  001fc	03 f9		 add	 edi, ecx
  001fe	03 c8		 add	 ecx, eax
  00200	0f b6 46 0c	 movzx	 eax, BYTE PTR [esi+12]
  00204	03 f9		 add	 edi, ecx
  00206	03 c8		 add	 ecx, eax
  00208	0f b6 46 0d	 movzx	 eax, BYTE PTR [esi+13]
  0020c	03 f9		 add	 edi, ecx
  0020e	03 c8		 add	 ecx, eax
  00210	0f b6 46 0e	 movzx	 eax, BYTE PTR [esi+14]
  00214	03 f9		 add	 edi, ecx
  00216	03 c8		 add	 ecx, eax
  00218	0f b6 46 0f	 movzx	 eax, BYTE PTR [esi+15]
  0021c	03 f9		 add	 edi, ecx

; 119  :             buf += 16;

  0021e	83 c6 10	 add	 esi, 16			; 00000010H
  00221	03 c8		 add	 ecx, eax
  00223	03 f9		 add	 edi, ecx
  00225	83 ea 01	 sub	 edx, 1
  00228	0f 85 72 ff ff
	ff		 jne	 $LL9@adler32_z
$LN25@adler32_z:

; 120  :         }
; 121  :         while (len--) {

  0022e	85 db		 test	 ebx, ebx
  00230	74 0f		 je	 SHORT $LN30@adler32_z
$LL11@adler32_z:

; 122  :             adler += *buf++;

  00232	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00235	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  00238	03 c8		 add	 ecx, eax

; 123  :             sum2 += adler;

  0023a	03 f9		 add	 edi, ecx
  0023c	83 eb 01	 sub	 ebx, 1
  0023f	75 f1		 jne	 SHORT $LL11@adler32_z
$LN30@adler32_z:

; 124  :         }
; 125  :         MOD(adler);

  00241	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  00246	f7 e1		 mul	 ecx
  00248	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  0024b	69 c2 0f 00 ff
	ff		 imul	 eax, edx, -65521
  00251	03 c8		 add	 ecx, eax

; 126  :         MOD(sum2);

  00253	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  00258	f7 e7		 mul	 edi
  0025a	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  0025d	69 d2 0f 00 ff
	ff		 imul	 edx, edx, -65521
  00263	03 fa		 add	 edi, edx
$LN19@adler32_z:

; 127  :     }
; 128  : 
; 129  :     /* return recombined sums */
; 130  :     return adler | (sum2 << 16);

  00265	c1 e7 10	 shl	 edi, 16			; 00000010H
  00268	0b f9		 or	 edi, ecx
  0026a	5e		 pop	 esi
  0026b	8b c7		 mov	 eax, edi

; 131  : }

  0026d	5f		 pop	 edi
  0026e	5b		 pop	 ebx
  0026f	5d		 pop	 ebp
  00270	c3		 ret	 0
_adler32_z ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\adler32.c
;	COMDAT _adler32
_TEXT	SEGMENT
_adler$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_adler32 PROC						; COMDAT

; 138  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 140  : }

  00003	5d		 pop	 ebp

; 139  :     return adler32_z(adler, buf, len);

  00004	e9 00 00 00 00	 jmp	 _adler32_z
_adler32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\adler32.c
;	COMDAT _adler32_combine_
_TEXT	SEGMENT
_adler1$1$ = -4						; size = 4
_len2$ = 8						; size = 8
_adler32_combine_ PROC					; COMDAT
; _adler1$ = ecx
; _adler2$ = edx

; 147  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 148  :     unsigned long sum1;
; 149  :     unsigned long sum2;
; 150  :     unsigned rem;
; 151  : 
; 152  :     /* for negative len, return invalid adler32 as a clue for debugging */
; 153  :     if (len2 < 0)

  00004	8b 45 0c	 mov	 eax, DWORD PTR _len2$[ebp+4]
  00007	53		 push	 ebx
  00008	8b da		 mov	 ebx, edx
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	89 75 fc	 mov	 DWORD PTR _adler1$1$[ebp], esi
  00010	57		 push	 edi
  00011	8b 7d 08	 mov	 edi, DWORD PTR _len2$[ebp]
  00014	85 c0		 test	 eax, eax
  00016	7f 10		 jg	 SHORT $LN2@adler32_co
  00018	7c 04		 jl	 SHORT $LN8@adler32_co
  0001a	85 ff		 test	 edi, edi
  0001c	73 0a		 jae	 SHORT $LN2@adler32_co
$LN8@adler32_co:

; 167  :     if (sum2 >= BASE) sum2 -= BASE;
; 168  :     return sum1 | (sum2 << 16);
; 169  : }

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	83 c8 ff	 or	 eax, -1
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
$LN2@adler32_co:

; 154  :         return 0xffffffffUL;
; 155  : 
; 156  :     /* the derivation of this formula is left as an exercise for the reader */
; 157  :     MOD63(len2);                /* assumes len2 >= 0 */

  00028	6a 00		 push	 0
  0002a	68 f1 ff 00 00	 push	 65521			; 0000fff1H
  0002f	50		 push	 eax
  00030	57		 push	 edi
  00031	e8 00 00 00 00	 call	 __alldiv
  00036	69 c0 f1 ff 00
	00		 imul	 eax, eax, 65521

; 158  :     rem = (unsigned)len2;
; 159  :     sum1 = adler1 & 0xffff;

  0003c	0f b7 ce	 movzx	 ecx, si

; 160  :     sum2 = rem * sum1;

  0003f	8b f1		 mov	 esi, ecx
  00041	2b f8		 sub	 edi, eax

; 161  :     MOD(sum2);
; 162  :     sum1 += (adler2 & 0xffff) + BASE - 1;

  00043	0f b7 c3	 movzx	 eax, bx

; 163  :     sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;
; 164  :     if (sum1 >= BASE) sum1 -= BASE;

  00046	05 f0 ff 00 00	 add	 eax, 65520		; 0000fff0H
  0004b	0f af f7	 imul	 esi, edi
  0004e	03 c8		 add	 ecx, eax
  00050	c1 eb 10	 shr	 ebx, 16			; 00000010H
  00053	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  00058	f7 e6		 mul	 esi

; 165  :     if (sum1 >= BASE) sum1 -= BASE;
; 166  :     if (sum2 >= ((unsigned long)BASE << 1)) sum2 -= ((unsigned long)BASE << 1);

  0005a	b8 01 00 00 00	 mov	 eax, 1
  0005f	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  00062	2b c2		 sub	 eax, edx
  00064	8b 55 fc	 mov	 edx, DWORD PTR _adler1$1$[ebp]
  00067	69 c0 f1 ff 00
	00		 imul	 eax, eax, 65521
  0006d	c1 ea 10	 shr	 edx, 16			; 00000010H
  00070	03 c2		 add	 eax, edx
  00072	8d 91 0f 00 ff
	ff		 lea	 edx, DWORD PTR [ecx-65521]
  00078	03 c3		 add	 eax, ebx
  0007a	2b c7		 sub	 eax, edi
  0007c	03 c6		 add	 eax, esi
  0007e	81 f9 f1 ff 00
	00		 cmp	 ecx, 65521		; 0000fff1H

; 167  :     if (sum2 >= BASE) sum2 -= BASE;
; 168  :     return sum1 | (sum2 << 16);
; 169  : }

  00084	5f		 pop	 edi
  00085	0f 42 d1	 cmovb	 edx, ecx
  00088	3d e2 ff 01 00	 cmp	 eax, 131042		; 0001ffe2H
  0008d	5e		 pop	 esi
  0008e	8d 88 1e 00 fe
	ff		 lea	 ecx, DWORD PTR [eax-131042]
  00094	0f 42 c8	 cmovb	 ecx, eax
  00097	81 f9 f1 ff 00
	00		 cmp	 ecx, 65521		; 0000fff1H
  0009d	5b		 pop	 ebx
  0009e	8d 81 0f 00 ff
	ff		 lea	 eax, DWORD PTR [ecx-65521]
  000a4	0f 42 c1	 cmovb	 eax, ecx
  000a7	8d 8a 0f 00 ff
	ff		 lea	 ecx, DWORD PTR [edx-65521]
  000ad	c1 e0 10	 shl	 eax, 16			; 00000010H
  000b0	81 fa f1 ff 00
	00		 cmp	 edx, 65521		; 0000fff1H
  000b6	0f 42 ca	 cmovb	 ecx, edx
  000b9	0b c1		 or	 eax, ecx
  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
_adler32_combine_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\adler32.c
;	COMDAT _adler32_combine
_TEXT	SEGMENT
_adler1$ = 8						; size = 4
_adler2$ = 12						; size = 4
_len2$ = 16						; size = 4
_adler32_combine PROC					; COMDAT

; 176  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 177  :     return adler32_combine_(adler1, adler2, len2);

  00003	8b 45 10	 mov	 eax, DWORD PTR _len2$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _adler1$[ebp]
  00009	99		 cdq
  0000a	52		 push	 edx
  0000b	8b 55 0c	 mov	 edx, DWORD PTR _adler2$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _adler32_combine_
  00014	83 c4 08	 add	 esp, 8

; 178  : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
_adler32_combine ENDP
_TEXT	ENDS
END
