; Listing generated by Microsoft (R) Optimizing Compiler Version 19.11.25508.2 

	TITLE	c:\users\theclashingfritz\source\repos\inifileparser\zlib\inffast.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_inflate_fast
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\inffast.c
;	COMDAT _inflate_fast
_TEXT	SEGMENT
_whave$1$ = -68						; size = 4
_beg$1$ = -64						; size = 4
_last$1$ = -60						; size = 4
_wnext$1$ = -56						; size = 4
_wsize$1$ = -52						; size = 4
_dcode$1$ = -48						; size = 4
_lcode$1$ = -44						; size = 4
_bits$1$ = -40						; size = 4
_dmask$1$ = -36						; size = 4
_window$1$ = -32					; size = 4
_strm$1$ = -28						; size = 4
_lmask$1$ = -24						; size = 4
_state$1$ = -20						; size = 4
_end$1$ = -16						; size = 4
_dist$1$ = -12						; size = 4
_in$1$ = -8						; size = 4
_hold$1$ = -4						; size = 4
_inflate_fast PROC					; COMDAT
; _strm$ = ecx
; _start$ = edx

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	89 7d e4	 mov	 DWORD PTR _strm$1$[ebp], edi

; 54   :     struct inflate_state FAR *state;
; 55   :     z_const unsigned char FAR *in;      /* local strm->next_in */
; 56   :     z_const unsigned char FAR *last;    /* have enough input while in < last */
; 57   :     unsigned char FAR *out;     /* local strm->next_out */
; 58   :     unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
; 59   :     unsigned char FAR *end;     /* while out < end, enough space available */
; 60   : #ifdef INFLATE_STRICT
; 61   :     unsigned dmax;              /* maximum distance from zlib header */
; 62   : #endif
; 63   :     unsigned wsize;             /* window size or zero if not using window */
; 64   :     unsigned whave;             /* valid bytes in the window */
; 65   :     unsigned wnext;             /* window write index */
; 66   :     unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
; 67   :     unsigned long hold;         /* local strm->hold */
; 68   :     unsigned bits;              /* local strm->bits */
; 69   :     code const FAR *lcode;      /* local strm->lencode */
; 70   :     code const FAR *dcode;      /* local strm->distcode */
; 71   :     unsigned lmask;             /* mask for first level of length codes */
; 72   :     unsigned dmask;             /* mask for first level of distance codes */
; 73   :     code here;                  /* retrieved table entry */
; 74   :     unsigned op;                /* code bits, operation, extra bits, or */
; 75   :                                 /*  window position, window bytes to copy */
; 76   :     unsigned len;               /* match length, unused bytes */
; 77   :     unsigned dist;              /* match distance */
; 78   :     unsigned char FAR *from;    /* where to copy match from */
; 79   : 
; 80   :     /* copy state to local variables */
; 81   :     state = (struct inflate_state FAR *)strm->state;

  0000e	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]

; 82   :     in = strm->next_in;
; 83   :     last = in + (strm->avail_in - 5);

  00011	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00014	8b 1f		 mov	 ebx, DWORD PTR [edi]
  00016	83 c0 fb	 add	 eax, -5			; fffffffbH

; 84   :     out = strm->next_out;

  00019	8b 77 0c	 mov	 esi, DWORD PTR [edi+12]
  0001c	03 c3		 add	 eax, ebx
  0001e	89 45 c4	 mov	 DWORD PTR _last$1$[ebp], eax

; 85   :     beg = out - (start - strm->avail_out);

  00021	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00024	8b f8		 mov	 edi, eax

; 86   :     end = out + (strm->avail_out - 257);

  00026	05 ff fe ff ff	 add	 eax, -257		; fffffeffH
  0002b	89 4d ec	 mov	 DWORD PTR _state$1$[ebp], ecx
  0002e	03 c6		 add	 eax, esi
  00030	89 5d f8	 mov	 DWORD PTR _in$1$[ebp], ebx
  00033	89 45 f0	 mov	 DWORD PTR _end$1$[ebp], eax
  00036	2b fa		 sub	 edi, edx

; 87   : #ifdef INFLATE_STRICT
; 88   :     dmax = state->dmax;
; 89   : #endif
; 90   :     wsize = state->wsize;

  00038	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  0003b	03 fe		 add	 edi, esi

; 91   :     whave = state->whave;
; 92   :     wnext = state->wnext;
; 93   :     window = state->window;
; 94   :     hold = state->hold;

  0003d	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00040	89 45 cc	 mov	 DWORD PTR _wsize$1$[ebp], eax
  00043	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00046	89 45 bc	 mov	 DWORD PTR _whave$1$[ebp], eax
  00049	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  0004c	89 45 c8	 mov	 DWORD PTR _wnext$1$[ebp], eax
  0004f	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00052	89 45 e0	 mov	 DWORD PTR _window$1$[ebp], eax

; 95   :     bits = state->bits;
; 96   :     lcode = state->lencode;

  00055	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  00058	89 45 d4	 mov	 DWORD PTR _lcode$1$[ebp], eax

; 97   :     dcode = state->distcode;

  0005b	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  0005e	89 45 d0	 mov	 DWORD PTR _dcode$1$[ebp], eax

; 98   :     lmask = (1U << state->lenbits) - 1;

  00061	b8 01 00 00 00	 mov	 eax, 1
  00066	89 45 e8	 mov	 DWORD PTR _lmask$1$[ebp], eax

; 99   :     dmask = (1U << state->distbits) - 1;

  00069	89 45 dc	 mov	 DWORD PTR _dmask$1$[ebp], eax
  0006c	8b 45 ec	 mov	 eax, DWORD PTR _state$1$[ebp]
  0006f	89 7d c0	 mov	 DWORD PTR _beg$1$[ebp], edi
  00072	8b 79 40	 mov	 edi, DWORD PTR [ecx+64]
  00075	8b 49 58	 mov	 ecx, DWORD PTR [ecx+88]
  00078	d3 65 e8	 shl	 DWORD PTR _lmask$1$[ebp], cl
  0007b	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  0007e	8b 45 dc	 mov	 eax, DWORD PTR _dmask$1$[ebp]
  00081	ff 4d e8	 dec	 DWORD PTR _lmask$1$[ebp]
  00084	d3 e0		 shl	 eax, cl
  00086	48		 dec	 eax
  00087	89 45 dc	 mov	 DWORD PTR _dmask$1$[ebp], eax
  0008a	66 0f 1f 44 00
	00		 npad	 6
$LL4@inflate_fa:

; 100  : 
; 101  :     /* decode literals and length/distances until end-of-block or not enough
; 102  :        input data or output space */
; 103  :     do {
; 104  :         if (bits < 15) {

  00090	83 ff 0f	 cmp	 edi, 15			; 0000000fH
  00093	73 1d		 jae	 SHORT $LN22@inflate_fa

; 105  :             hold += (unsigned long)(*in++) << bits;

  00095	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00098	8b cf		 mov	 ecx, edi
  0009a	d3 e0		 shl	 eax, cl

; 106  :             bits += 8;
; 107  :             hold += (unsigned long)(*in++) << bits;

  0009c	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  0009f	03 d0		 add	 edx, eax
  000a1	0f b6 43 01	 movzx	 eax, BYTE PTR [ebx+1]
  000a5	d3 e0		 shl	 eax, cl
  000a7	83 c3 02	 add	 ebx, 2
  000aa	03 d0		 add	 edx, eax
  000ac	89 5d f8	 mov	 DWORD PTR _in$1$[ebp], ebx

; 108  :             bits += 8;

  000af	83 c7 10	 add	 edi, 16			; 00000010H
$LN22@inflate_fa:

; 109  :         }
; 110  :         here = lcode[hold & lmask];

  000b2	8b 45 e8	 mov	 eax, DWORD PTR _lmask$1$[ebp]
  000b5	8b 4d d4	 mov	 ecx, DWORD PTR _lcode$1$[ebp]
  000b8	23 c2		 and	 eax, edx
  000ba	8b 1c 81	 mov	 ebx, DWORD PTR [ecx+eax*4]

; 111  :       dolen:
; 112  :         op = (unsigned)(here.bits);

  000bd	8b c3		 mov	 eax, ebx
  000bf	c1 e8 08	 shr	 eax, 8
  000c2	0f b6 c8	 movzx	 ecx, al

; 113  :         hold >>= op;

  000c5	d3 ea		 shr	 edx, cl

; 114  :         bits -= op;

  000c7	2b f9		 sub	 edi, ecx
  000c9	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx

; 115  :         op = (unsigned)(here.op);

  000cc	0f b6 d3	 movzx	 edx, bl

; 116  :         if (op == 0) {                          /* literal */

  000cf	84 db		 test	 bl, bl
  000d1	74 3e		 je	 SHORT $LN72@inflate_fa
$dolen$107:

; 121  :         }
; 122  :         else if (op & 16) {                     /* length base */

  000d3	f6 c2 10	 test	 dl, 16			; 00000010H
  000d6	75 44		 jne	 SHORT $LN73@inflate_fa

; 274  :             }
; 275  :         }
; 276  :         else if ((op & 64) == 0) {              /* 2nd level length code */

  000d8	f6 c2 40	 test	 dl, 64			; 00000040H
  000db	0f 85 99 02 00
	00		 jne	 $LN52@inflate_fa

; 277  :             here = lcode[here.val + (hold & ((1U << op) - 1))];

  000e1	8b ca		 mov	 ecx, edx
  000e3	c1 eb 10	 shr	 ebx, 16			; 00000010H
  000e6	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  000e9	b8 01 00 00 00	 mov	 eax, 1
  000ee	d3 e0		 shl	 eax, cl
  000f0	8b 4d d4	 mov	 ecx, DWORD PTR _lcode$1$[ebp]
  000f3	48		 dec	 eax
  000f4	23 c2		 and	 eax, edx
  000f6	03 c3		 add	 eax, ebx
  000f8	8b 1c 81	 mov	 ebx, DWORD PTR [ecx+eax*4]
  000fb	8b c3		 mov	 eax, ebx
  000fd	c1 e8 08	 shr	 eax, 8
  00100	0f b6 c8	 movzx	 ecx, al
  00103	d3 ea		 shr	 edx, cl
  00105	2b f9		 sub	 edi, ecx
  00107	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0010a	0f b6 d3	 movzx	 edx, bl
  0010d	84 db		 test	 bl, bl
  0010f	75 c2		 jne	 SHORT $dolen$107
$LN72@inflate_fa:

; 117  :             Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 118  :                     "inflate:         literal '%c'\n" :
; 119  :                     "inflate:         literal 0x%02x\n", here.val));
; 120  :             *out++ = (unsigned char)(here.val);

  00111	c1 eb 10	 shr	 ebx, 16			; 00000010H
  00114	88 1e		 mov	 BYTE PTR [esi], bl
  00116	46		 inc	 esi

; 244  :                     }
; 245  :                     if (len) {

  00117	e9 04 02 00 00	 jmp	 $LN2@inflate_fa
$LN73@inflate_fa:

; 123  :             len = (unsigned)(here.val);

  0011c	c1 eb 10	 shr	 ebx, 16			; 00000010H

; 124  :             op &= 15;                           /* number of extra bits */

  0011f	83 e2 0f	 and	 edx, 15			; 0000000fH

; 125  :             if (op) {

  00122	74 2b		 je	 SHORT $LN27@inflate_fa

; 126  :                 if (bits < op) {

  00124	3b fa		 cmp	 edi, edx
  00126	73 13		 jae	 SHORT $LN28@inflate_fa

; 127  :                     hold += (unsigned long)(*in++) << bits;

  00128	8b 45 f8	 mov	 eax, DWORD PTR _in$1$[ebp]
  0012b	8b cf		 mov	 ecx, edi
  0012d	ff 45 f8	 inc	 DWORD PTR _in$1$[ebp]
  00130	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00133	d3 e0		 shl	 eax, cl
  00135	01 45 fc	 add	 DWORD PTR _hold$1$[ebp], eax

; 128  :                     bits += 8;

  00138	83 c7 08	 add	 edi, 8
$LN28@inflate_fa:

; 129  :                 }
; 130  :                 len += (unsigned)hold & ((1U << op) - 1);

  0013b	8b ca		 mov	 ecx, edx
  0013d	b8 01 00 00 00	 mov	 eax, 1
  00142	d3 e0		 shl	 eax, cl
  00144	48		 dec	 eax
  00145	23 45 fc	 and	 eax, DWORD PTR _hold$1$[ebp]

; 131  :                 hold >>= op;

  00148	d3 6d fc	 shr	 DWORD PTR _hold$1$[ebp], cl
  0014b	03 d8		 add	 ebx, eax

; 132  :                 bits -= op;

  0014d	2b fa		 sub	 edi, edx
$LN27@inflate_fa:

; 133  :             }
; 134  :             Tracevv((stderr, "inflate:         length %u\n", len));
; 135  :             if (bits < 15) {
; 136  :                 hold += (unsigned long)(*in++) << bits;

  0014f	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00152	83 ff 0f	 cmp	 edi, 15			; 0000000fH
  00155	73 23		 jae	 SHORT $LN29@inflate_fa
  00157	8b 45 f8	 mov	 eax, DWORD PTR _in$1$[ebp]
  0015a	8b cf		 mov	 ecx, edi
  0015c	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0015f	d3 e0		 shl	 eax, cl

; 137  :                 bits += 8;
; 138  :                 hold += (unsigned long)(*in++) << bits;

  00161	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00164	03 d0		 add	 edx, eax
  00166	8b 45 f8	 mov	 eax, DWORD PTR _in$1$[ebp]
  00169	40		 inc	 eax
  0016a	89 45 f8	 mov	 DWORD PTR _in$1$[ebp], eax
  0016d	ff 45 f8	 inc	 DWORD PTR _in$1$[ebp]
  00170	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00173	d3 e0		 shl	 eax, cl
  00175	03 d0		 add	 edx, eax

; 139  :                 bits += 8;

  00177	83 c7 10	 add	 edi, 16			; 00000010H
$LN29@inflate_fa:

; 140  :             }
; 141  :             here = dcode[hold & dmask];

  0017a	8b 45 dc	 mov	 eax, DWORD PTR _dmask$1$[ebp]
  0017d	8b 4d d0	 mov	 ecx, DWORD PTR _dcode$1$[ebp]
  00180	23 c2		 and	 eax, edx
  00182	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00185	89 45 f4	 mov	 DWORD PTR _dist$1$[ebp], eax

; 142  :           dodist:
; 143  :             op = (unsigned)(here.bits);

  00188	c1 e8 08	 shr	 eax, 8
  0018b	0f b6 c8	 movzx	 ecx, al

; 144  :             hold >>= op;
; 145  :             bits -= op;
; 146  :             op = (unsigned)(here.op);

  0018e	8b 45 f4	 mov	 eax, DWORD PTR _dist$1$[ebp]
  00191	2b f9		 sub	 edi, ecx
  00193	d3 ea		 shr	 edx, cl
  00195	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00198	0f b6 d0	 movzx	 edx, al

; 147  :             if (op & 16) {                      /* distance base */

  0019b	f6 c2 10	 test	 dl, 16			; 00000010H
  0019e	75 44		 jne	 SHORT $LN74@inflate_fa
$dodist$108:

; 263  :                     }
; 264  :                 }
; 265  :             }
; 266  :             else if ((op & 64) == 0) {          /* 2nd level distance code */

  001a0	f6 c2 40	 test	 dl, 64			; 00000040H
  001a3	0f 85 f1 01 00
	00		 jne	 $LN50@inflate_fa

; 267  :                 here = dcode[here.val + (hold & ((1U << op) - 1))];

  001a9	8b ca		 mov	 ecx, edx
  001ab	b8 01 00 00 00	 mov	 eax, 1
  001b0	8b 55 d0	 mov	 edx, DWORD PTR _dcode$1$[ebp]
  001b3	d3 e0		 shl	 eax, cl
  001b5	8b 4d f4	 mov	 ecx, DWORD PTR _dist$1$[ebp]
  001b8	48		 dec	 eax
  001b9	23 45 fc	 and	 eax, DWORD PTR _hold$1$[ebp]
  001bc	c1 e9 10	 shr	 ecx, 16			; 00000010H
  001bf	03 c1		 add	 eax, ecx
  001c1	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  001c4	8b c1		 mov	 eax, ecx
  001c6	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  001c9	c1 e8 08	 shr	 eax, 8
  001cc	89 4d f4	 mov	 DWORD PTR _dist$1$[ebp], ecx
  001cf	0f b6 c8	 movzx	 ecx, al
  001d2	8b 45 f4	 mov	 eax, DWORD PTR _dist$1$[ebp]
  001d5	2b f9		 sub	 edi, ecx
  001d7	d3 ea		 shr	 edx, cl
  001d9	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  001dc	0f b6 d0	 movzx	 edx, al
  001df	f6 c2 10	 test	 dl, 16			; 00000010H
  001e2	74 bc		 je	 SHORT $dodist$108
$LN74@inflate_fa:

; 148  :                 dist = (unsigned)(here.val);

  001e4	c1 e8 10	 shr	 eax, 16			; 00000010H

; 149  :                 op &= 15;                       /* number of extra bits */

  001e7	83 e2 0f	 and	 edx, 15			; 0000000fH
  001ea	89 45 f4	 mov	 DWORD PTR _dist$1$[ebp], eax

; 150  :                 if (bits < op) {

  001ed	3b fa		 cmp	 edi, edx
  001ef	73 2b		 jae	 SHORT $LN33@inflate_fa

; 151  :                     hold += (unsigned long)(*in++) << bits;

  001f1	8b 45 f8	 mov	 eax, DWORD PTR _in$1$[ebp]
  001f4	8b cf		 mov	 ecx, edi

; 152  :                     bits += 8;

  001f6	83 c7 08	 add	 edi, 8
  001f9	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  001fc	d3 e0		 shl	 eax, cl
  001fe	01 45 fc	 add	 DWORD PTR _hold$1$[ebp], eax
  00201	8b 45 f8	 mov	 eax, DWORD PTR _in$1$[ebp]
  00204	40		 inc	 eax
  00205	89 45 f8	 mov	 DWORD PTR _in$1$[ebp], eax

; 153  :                     if (bits < op) {

  00208	3b fa		 cmp	 edi, edx
  0020a	73 10		 jae	 SHORT $LN33@inflate_fa

; 154  :                         hold += (unsigned long)(*in++) << bits;

  0020c	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0020f	8b cf		 mov	 ecx, edi
  00211	ff 45 f8	 inc	 DWORD PTR _in$1$[ebp]
  00214	d3 e0		 shl	 eax, cl
  00216	01 45 fc	 add	 DWORD PTR _hold$1$[ebp], eax

; 155  :                         bits += 8;

  00219	83 c7 08	 add	 edi, 8
$LN33@inflate_fa:

; 156  :                     }
; 157  :                 }
; 158  :                 dist += (unsigned)hold & ((1U << op) - 1);

  0021c	8b ca		 mov	 ecx, edx
  0021e	b8 01 00 00 00	 mov	 eax, 1
  00223	d3 e0		 shl	 eax, cl

; 159  : #ifdef INFLATE_STRICT
; 160  :                 if (dist > dmax) {
; 161  :                     strm->msg = (char *)"invalid distance too far back";
; 162  :                     state->mode = BAD;
; 163  :                     break;
; 164  :                 }
; 165  : #endif
; 166  :                 hold >>= op;
; 167  :                 bits -= op;

  00225	2b fa		 sub	 edi, edx
  00227	48		 dec	 eax
  00228	89 7d d8	 mov	 DWORD PTR _bits$1$[ebp], edi
  0022b	23 45 fc	 and	 eax, DWORD PTR _hold$1$[ebp]
  0022e	01 45 f4	 add	 DWORD PTR _dist$1$[ebp], eax

; 168  :                 Tracevv((stderr, "inflate:         distance %u\n", dist));
; 169  :                 op = (unsigned)(out - beg);     /* max distance in output */

  00231	8b c6		 mov	 eax, esi
  00233	2b 45 c0	 sub	 eax, DWORD PTR _beg$1$[ebp]
  00236	d3 6d fc	 shr	 DWORD PTR _hold$1$[ebp], cl

; 170  :                 if (dist > op) {                /* see if copy from window */

  00239	8b 55 f4	 mov	 edx, DWORD PTR _dist$1$[ebp]
  0023c	3b d0		 cmp	 edx, eax
  0023e	0f 86 fb 00 00
	00		 jbe	 $LN34@inflate_fa

; 171  :                     op = dist - op;             /* distance back in window */

  00244	8b ca		 mov	 ecx, edx
  00246	2b c8		 sub	 ecx, eax

; 172  :                     if (op > whave) {

  00248	3b 4d bc	 cmp	 ecx, DWORD PTR _whave$1$[ebp]
  0024b	76 10		 jbe	 SHORT $LN37@inflate_fa

; 173  :                         if (state->sane) {

  0024d	8b 45 ec	 mov	 eax, DWORD PTR _state$1$[ebp]
  00250	83 b8 c4 1b 00
	00 00		 cmp	 DWORD PTR [eax+7108], 0
  00257	0f 85 4c 01 00
	00		 jne	 $LN75@inflate_fa
$LN37@inflate_fa:

; 177  :                             break;
; 178  :                         }
; 179  : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 180  :                         if (len <= op - whave) {
; 181  :                             do {
; 182  :                                 *out++ = 0;
; 183  :                             } while (--len);
; 184  :                             continue;
; 185  :                         }
; 186  :                         len -= op - whave;
; 187  :                         do {
; 188  :                             *out++ = 0;
; 189  :                         } while (--op > whave);
; 190  :                         if (op == 0) {
; 191  :                             from = out - dist;
; 192  :                             do {
; 193  :                                 *out++ = *from++;
; 194  :                             } while (--len);
; 195  :                             continue;
; 196  :                         }
; 197  : #endif
; 198  :                     }
; 199  :                     from = window;
; 200  :                     if (wnext == 0) {           /* very common case */
; 201  :                         from += wsize - op;

  0025d	8b 7d e0	 mov	 edi, DWORD PTR _window$1$[ebp]
  00260	8b 45 c8	 mov	 eax, DWORD PTR _wnext$1$[ebp]
  00263	2b f9		 sub	 edi, ecx
  00265	85 c0		 test	 eax, eax
  00267	75 18		 jne	 SHORT $LN38@inflate_fa
  00269	03 7d cc	 add	 edi, DWORD PTR _wsize$1$[ebp]

; 202  :                         if (op < len) {         /* some from window */

  0026c	3b cb		 cmp	 ecx, ebx
  0026e	73 66		 jae	 SHORT $LN69@inflate_fa

; 203  :                             len -= op;

  00270	2b d9		 sub	 ebx, ecx
$LL7@inflate_fa:

; 204  :                             do {
; 205  :                                 *out++ = *from++;

  00272	8a 07		 mov	 al, BYTE PTR [edi]
  00274	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  00277	88 06		 mov	 BYTE PTR [esi], al
  00279	46		 inc	 esi

; 206  :                             } while (--op);

  0027a	83 e9 01	 sub	 ecx, 1
  0027d	75 f3		 jne	 SHORT $LL7@inflate_fa

; 207  :                             from = out - dist;  /* rest from output */
; 208  :                         }
; 209  :                     }

  0027f	eb 51		 jmp	 SHORT $LN102@inflate_fa
$LN38@inflate_fa:

; 210  :                     else if (wnext < op) {      /* wrap around window */
; 211  :                         from += wsize + wnext - op;

  00281	03 f8		 add	 edi, eax
  00283	3b c1		 cmp	 eax, ecx
  00285	73 38		 jae	 SHORT $LN41@inflate_fa
  00287	03 7d cc	 add	 edi, DWORD PTR _wsize$1$[ebp]

; 212  :                         op -= wnext;

  0028a	2b c8		 sub	 ecx, eax

; 213  :                         if (op < len) {         /* some from end of window */

  0028c	3b cb		 cmp	 ecx, ebx
  0028e	73 46		 jae	 SHORT $LN69@inflate_fa

; 214  :                             len -= op;

  00290	2b d9		 sub	 ebx, ecx

; 217  :                             } while (--op);

  00292	2b fe		 sub	 edi, esi
$LL10@inflate_fa:

; 215  :                             do {
; 216  :                                 *out++ = *from++;

  00294	8a 04 37	 mov	 al, BYTE PTR [edi+esi]
  00297	88 06		 mov	 BYTE PTR [esi], al
  00299	46		 inc	 esi

; 217  :                             } while (--op);

  0029a	83 e9 01	 sub	 ecx, 1
  0029d	75 f5		 jne	 SHORT $LL10@inflate_fa

; 218  :                             from = window;
; 219  :                             if (wnext < len) {  /* some from start of window */

  0029f	8b 45 c8	 mov	 eax, DWORD PTR _wnext$1$[ebp]
  002a2	8b 7d e0	 mov	 edi, DWORD PTR _window$1$[ebp]
  002a5	3b c3		 cmp	 eax, ebx
  002a7	73 2d		 jae	 SHORT $LN69@inflate_fa

; 220  :                                 op = wnext;

  002a9	8b c8		 mov	 ecx, eax

; 221  :                                 len -= op;

  002ab	2b d8		 sub	 ebx, eax
  002ad	0f 1f 00	 npad	 3
$LL13@inflate_fa:

; 222  :                                 do {
; 223  :                                     *out++ = *from++;

  002b0	8a 07		 mov	 al, BYTE PTR [edi]
  002b2	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  002b5	88 06		 mov	 BYTE PTR [esi], al
  002b7	46		 inc	 esi

; 224  :                                 } while (--op);

  002b8	83 e9 01	 sub	 ecx, 1
  002bb	75 f3		 jne	 SHORT $LL13@inflate_fa

; 225  :                                 from = out - dist;      /* rest from output */
; 226  :                             }
; 227  :                         }
; 228  :                     }

  002bd	eb 13		 jmp	 SHORT $LN102@inflate_fa
$LN41@inflate_fa:

; 229  :                     else {                      /* contiguous in window */
; 230  :                         from += wnext - op;
; 231  :                         if (op < len) {         /* some from window */

  002bf	3b cb		 cmp	 ecx, ebx
  002c1	73 13		 jae	 SHORT $LN69@inflate_fa

; 232  :                             len -= op;

  002c3	2b d9		 sub	 ebx, ecx
$LL16@inflate_fa:

; 233  :                             do {
; 234  :                                 *out++ = *from++;

  002c5	8a 07		 mov	 al, BYTE PTR [edi]
  002c7	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  002ca	88 06		 mov	 BYTE PTR [esi], al
  002cc	46		 inc	 esi

; 235  :                             } while (--op);

  002cd	83 e9 01	 sub	 ecx, 1
  002d0	75 f3		 jne	 SHORT $LL16@inflate_fa
$LN102@inflate_fa:

; 236  :                             from = out - dist;  /* rest from output */

  002d2	8b fe		 mov	 edi, esi
  002d4	2b fa		 sub	 edi, edx
$LN69@inflate_fa:

; 237  :                         }
; 238  :                     }
; 239  :                     while (len > 2) {

  002d6	83 fb 02	 cmp	 ebx, 2
  002d9	76 2e		 jbe	 SHORT $LN18@inflate_fa
  002db	8d 4b fd	 lea	 ecx, DWORD PTR [ebx-3]
  002de	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  002e3	f7 e1		 mul	 ecx
  002e5	d1 ea		 shr	 edx, 1
  002e7	42		 inc	 edx
$LL17@inflate_fa:

; 240  :                         *out++ = *from++;

  002e8	0f b6 07	 movzx	 eax, BYTE PTR [edi]

; 241  :                         *out++ = *from++;
; 242  :                         *out++ = *from++;
; 243  :                         len -= 3;

  002eb	83 eb 03	 sub	 ebx, 3
  002ee	88 06		 mov	 BYTE PTR [esi], al
  002f0	0f b6 47 01	 movzx	 eax, BYTE PTR [edi+1]
  002f4	88 46 01	 mov	 BYTE PTR [esi+1], al
  002f7	0f b6 47 02	 movzx	 eax, BYTE PTR [edi+2]
  002fb	83 c7 03	 add	 edi, 3
  002fe	88 46 02	 mov	 BYTE PTR [esi+2], al
  00301	83 c6 03	 add	 esi, 3
  00304	83 ea 01	 sub	 edx, 1
  00307	75 df		 jne	 SHORT $LL17@inflate_fa
$LN18@inflate_fa:

; 244  :                     }
; 245  :                     if (len) {

  00309	85 db		 test	 ebx, ebx
  0030b	74 10		 je	 SHORT $LN99@inflate_fa

; 246  :                         *out++ = *from++;

  0030d	8a 07		 mov	 al, BYTE PTR [edi]
  0030f	88 06		 mov	 BYTE PTR [esi], al
  00311	46		 inc	 esi

; 247  :                         if (len > 1)

  00312	83 fb 01	 cmp	 ebx, 1
  00315	76 06		 jbe	 SHORT $LN99@inflate_fa

; 248  :                             *out++ = *from++;

  00317	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  0031a	88 06		 mov	 BYTE PTR [esi], al
  0031c	46		 inc	 esi
$LN99@inflate_fa:

; 247  :                         if (len > 1)

  0031d	8b 7d d8	 mov	 edi, DWORD PTR _bits$1$[ebp]
$LN2@inflate_fa:

; 288  :             break;
; 289  :         }
; 290  :     } while (in < last && out < end);

  00320	8b 5d f8	 mov	 ebx, DWORD PTR _in$1$[ebp]
  00323	8b 55 f0	 mov	 edx, DWORD PTR _end$1$[ebp]
  00326	3b 5d c4	 cmp	 ebx, DWORD PTR _last$1$[ebp]
  00329	0f 83 91 00 00
	00		 jae	 $LN3@inflate_fa
  0032f	3b f2		 cmp	 esi, edx
  00331	0f 83 89 00 00
	00		 jae	 $LN3@inflate_fa
  00337	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  0033a	e9 51 fd ff ff	 jmp	 $LL4@inflate_fa
$LN34@inflate_fa:

; 249  :                     }
; 250  :                 }
; 251  :                 else {
; 252  :                     from = out - dist;          /* copy direct from output */

  0033f	8b ce		 mov	 ecx, esi
  00341	2b ca		 sub	 ecx, edx
$LL21@inflate_fa:

; 253  :                     do {                        /* minimum length is three */
; 254  :                         *out++ = *from++;

  00343	0f b6 01	 movzx	 eax, BYTE PTR [ecx]

; 255  :                         *out++ = *from++;
; 256  :                         *out++ = *from++;

  00346	8d 49 03	 lea	 ecx, DWORD PTR [ecx+3]
  00349	88 06		 mov	 BYTE PTR [esi], al

; 257  :                         len -= 3;

  0034b	83 eb 03	 sub	 ebx, 3
  0034e	0f b6 41 fe	 movzx	 eax, BYTE PTR [ecx-2]
  00352	88 46 01	 mov	 BYTE PTR [esi+1], al
  00355	0f b6 41 ff	 movzx	 eax, BYTE PTR [ecx-1]
  00359	88 46 02	 mov	 BYTE PTR [esi+2], al
  0035c	83 c6 03	 add	 esi, 3

; 258  :                     } while (len > 2);

  0035f	83 fb 02	 cmp	 ebx, 2
  00362	77 df		 ja	 SHORT $LL21@inflate_fa

; 259  :                     if (len) {

  00364	85 db		 test	 ebx, ebx
  00366	74 b8		 je	 SHORT $LN2@inflate_fa

; 260  :                         *out++ = *from++;

  00368	8a 01		 mov	 al, BYTE PTR [ecx]
  0036a	88 06		 mov	 BYTE PTR [esi], al
  0036c	46		 inc	 esi

; 261  :                         if (len > 1)

  0036d	83 fb 01	 cmp	 ebx, 1
  00370	76 ae		 jbe	 SHORT $LN2@inflate_fa

; 262  :                             *out++ = *from++;

  00372	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00375	88 06		 mov	 BYTE PTR [esi], al
  00377	46		 inc	 esi
  00378	eb a6		 jmp	 SHORT $LN2@inflate_fa
$LN52@inflate_fa:

; 278  :             goto dolen;
; 279  :         }
; 280  :         else if (op & 32) {                     /* end-of-block */
; 281  :             Tracevv((stderr, "inflate:         end of block\n"));
; 282  :             state->mode = TYPE;

  0037a	8b 45 ec	 mov	 eax, DWORD PTR _state$1$[ebp]
  0037d	f6 c2 20	 test	 dl, 32			; 00000020H

; 283  :             break;

  00380	8b 55 f0	 mov	 edx, DWORD PTR _end$1$[ebp]
  00383	74 09		 je	 SHORT $LN54@inflate_fa

; 278  :             goto dolen;
; 279  :         }
; 280  :         else if (op & 32) {                     /* end-of-block */
; 281  :             Tracevv((stderr, "inflate:         end of block\n"));
; 282  :             state->mode = TYPE;

  00385	c7 40 04 3f 3f
	00 00		 mov	 DWORD PTR [eax+4], 16191 ; 00003f3fH

; 283  :             break;

  0038c	eb 2f		 jmp	 SHORT $LN103@inflate_fa
$LN54@inflate_fa:

; 284  :         }
; 285  :         else {
; 286  :             strm->msg = (char *)"invalid literal/length code";

  0038e	8b 5d e4	 mov	 ebx, DWORD PTR _strm$1$[ebp]
  00391	c7 43 18 00 00
	00 00		 mov	 DWORD PTR [ebx+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@

; 287  :             state->mode = BAD;

  00398	eb 1c		 jmp	 SHORT $LN104@inflate_fa
$LN50@inflate_fa:

; 268  :                 goto dodist;
; 269  :             }
; 270  :             else {
; 271  :                 strm->msg = (char *)"invalid distance code";

  0039a	8b 5d e4	 mov	 ebx, DWORD PTR _strm$1$[ebp]

; 272  :                 state->mode = BAD;

  0039d	8b 45 ec	 mov	 eax, DWORD PTR _state$1$[ebp]
  003a0	c7 43 18 00 00
	00 00		 mov	 DWORD PTR [ebx+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@

; 273  :                 break;

  003a7	eb 0a		 jmp	 SHORT $LN105@inflate_fa
$LN75@inflate_fa:

; 174  :                             strm->msg =

  003a9	8b 5d e4	 mov	 ebx, DWORD PTR _strm$1$[ebp]
  003ac	c7 43 18 00 00
	00 00		 mov	 DWORD PTR [ebx+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
$LN105@inflate_fa:

; 288  :             break;
; 289  :         }
; 290  :     } while (in < last && out < end);

  003b3	8b 55 f0	 mov	 edx, DWORD PTR _end$1$[ebp]
$LN104@inflate_fa:

; 175  :                                 (char *)"invalid distance too far back";
; 176  :                             state->mode = BAD;

  003b6	c7 40 04 51 3f
	00 00		 mov	 DWORD PTR [eax+4], 16209 ; 00003f51H
$LN103@inflate_fa:
  003bd	8b 5d f8	 mov	 ebx, DWORD PTR _in$1$[ebp]
$LN3@inflate_fa:

; 291  : 
; 292  :     /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
; 293  :     len = bits >> 3;

  003c0	8b c7		 mov	 eax, edi
  003c2	c1 e8 03	 shr	 eax, 3

; 294  :     in -= len;

  003c5	2b d8		 sub	 ebx, eax

; 295  :     bits -= len << 3;

  003c7	c1 e0 03	 shl	 eax, 3
  003ca	2b f8		 sub	 edi, eax

; 296  :     hold &= (1U << bits) - 1;

  003cc	b8 01 00 00 00	 mov	 eax, 1
  003d1	8b cf		 mov	 ecx, edi
  003d3	d3 e0		 shl	 eax, cl
  003d5	8b 4d fc	 mov	 ecx, DWORD PTR _hold$1$[ebp]
  003d8	48		 dec	 eax
  003d9	23 c8		 and	 ecx, eax

; 297  : 
; 298  :     /* update state and return */
; 299  :     strm->next_in = in;

  003db	8b 45 e4	 mov	 eax, DWORD PTR _strm$1$[ebp]
  003de	89 18		 mov	 DWORD PTR [eax], ebx

; 300  :     strm->next_out = out;

  003e0	89 70 0c	 mov	 DWORD PTR [eax+12], esi

; 301  :     strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));

  003e3	8b 45 c4	 mov	 eax, DWORD PTR _last$1$[ebp]
  003e6	2b c3		 sub	 eax, ebx
  003e8	8b 5d e4	 mov	 ebx, DWORD PTR _strm$1$[ebp]
  003eb	83 c0 05	 add	 eax, 5

; 302  :     strm->avail_out = (unsigned)(out < end ?

  003ee	2b d6		 sub	 edx, esi
  003f0	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  003f3	8d 82 01 01 00
	00		 lea	 eax, DWORD PTR [edx+257]
  003f9	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 303  :                                  257 + (end - out) : 257 - (out - end));
; 304  :     state->hold = hold;

  003fc	8b 45 ec	 mov	 eax, DWORD PTR _state$1$[ebp]

; 305  :     state->bits = bits;

  003ff	89 78 40	 mov	 DWORD PTR [eax+64], edi
  00402	5f		 pop	 edi
  00403	5e		 pop	 esi
  00404	89 48 3c	 mov	 DWORD PTR [eax+60], ecx
  00407	5b		 pop	 ebx

; 306  :     return;
; 307  : }

  00408	8b e5		 mov	 esp, ebp
  0040a	5d		 pop	 ebp
  0040b	c3		 ret	 0
_inflate_fast ENDP
_TEXT	ENDS
END
