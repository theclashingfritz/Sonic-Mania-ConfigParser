; Listing generated by Microsoft (R) Optimizing Compiler Version 19.11.25508.2 

	TITLE	c:\users\theclashingfritz\source\repos\inifileparser\zlib\uncompr.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_uncompress
PUBLIC	_uncompress2
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\uncompr.c
;	COMDAT _uncompress2
_TEXT	SEGMENT
_buf$ = -57						; size = 1
_stream$ = -56						; size = 56
_dest$ = 8						; size = 4
_destLen$ = 12						; size = 4
_source$ = 16						; size = 4
_sourceLen$ = 20					; size = 4
_uncompress2 PROC					; COMDAT

; 32   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H

; 33   :     z_stream stream;
; 34   :     int err;
; 35   :     const uInt max = (uInt)-1;
; 36   :     uLong len, left;
; 37   :     Byte buf[1];    /* for detection of incomplete stream when *destLen == 0 */
; 38   : 
; 39   :     len = *sourceLen;
; 40   :     if (*destLen) {

  00006	8b 45 0c	 mov	 eax, DWORD PTR _destLen$[ebp]
  00009	83 ec 3c	 sub	 esp, 60			; 0000003cH
  0000c	53		 push	 ebx
  0000d	8b 5d 14	 mov	 ebx, DWORD PTR _sourceLen$[ebp]
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	8b 38		 mov	 edi, DWORD PTR [eax]
  00014	8b 1b		 mov	 ebx, DWORD PTR [ebx]
  00016	85 ff		 test	 edi, edi
  00018	74 0b		 je	 SHORT $LN5@uncompress

; 41   :         left = *destLen;
; 42   :         *destLen = 0;
; 43   :     }

  0001a	8b 75 08	 mov	 esi, DWORD PTR _dest$[ebp]
  0001d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00023	eb 0c		 jmp	 SHORT $LN6@uncompress
$LN5@uncompress:

; 44   :     else {
; 45   :         left = 1;
; 46   :         dest = buf;

  00025	8d 74 24 0f	 lea	 esi, DWORD PTR _buf$[esp+72]
  00029	bf 01 00 00 00	 mov	 edi, 1
  0002e	89 75 08	 mov	 DWORD PTR _dest$[ebp], esi
$LN6@uncompress:

; 47   :     }
; 48   : 
; 49   :     stream.next_in = (z_const Bytef *)source;

  00031	8b 45 10	 mov	 eax, DWORD PTR _source$[ebp]

; 50   :     stream.avail_in = 0;
; 51   :     stream.zalloc = (alloc_func)0;
; 52   :     stream.zfree = (free_func)0;
; 53   :     stream.opaque = (voidpf)0;
; 54   : 
; 55   :     err = inflateInit(&stream);

  00034	6a 38		 push	 56			; 00000038H
  00036	89 44 24 14	 mov	 DWORD PTR _stream$[esp+76], eax
  0003a	8d 44 24 14	 lea	 eax, DWORD PTR _stream$[esp+76]
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_06CJNJFBNP@1?42?411?$AA@
  00043	50		 push	 eax
  00044	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _stream$[esp+88], 0
  0004c	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR _stream$[esp+116], 0
  00054	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR _stream$[esp+120], 0
  0005c	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR _stream$[esp+124], 0
  00064	e8 00 00 00 00	 call	 _inflateInit_
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 56   :     if (err != Z_OK) return err;

  0006c	85 c0		 test	 eax, eax
  0006e	0f 85 b3 00 00
	00		 jne	 $LN1@uncompress

; 57   : 
; 58   :     stream.next_out = dest;

  00074	89 74 24 1c	 mov	 DWORD PTR _stream$[esp+84], esi

; 59   :     stream.avail_out = 0;

  00078	89 44 24 20	 mov	 DWORD PTR _stream$[esp+88], eax
$LN27@uncompress:
  0007c	83 c9 ff	 or	 ecx, -1

; 60   : 
; 61   :     do {
; 62   :         if (stream.avail_out == 0) {

  0007f	85 c0		 test	 eax, eax
  00081	75 0d		 jne	 SHORT $LN8@uncompress

; 63   :             stream.avail_out = left > (uLong)max ? max : (uInt)left;

  00083	3b f9		 cmp	 edi, ecx
  00085	8b c7		 mov	 eax, edi
  00087	0f 47 c1	 cmova	 eax, ecx
  0008a	89 44 24 20	 mov	 DWORD PTR _stream$[esp+88], eax

; 64   :             left -= stream.avail_out;

  0008e	2b f8		 sub	 edi, eax
$LN8@uncompress:

; 65   :         }
; 66   :         if (stream.avail_in == 0) {

  00090	83 7c 24 14 00	 cmp	 DWORD PTR _stream$[esp+76], 0
  00095	75 0e		 jne	 SHORT $LN9@uncompress

; 67   :             stream.avail_in = len > (uLong)max ? max : (uInt)len;

  00097	83 fb ff	 cmp	 ebx, -1
  0009a	8b c3		 mov	 eax, ebx
  0009c	0f 47 c1	 cmova	 eax, ecx
  0009f	89 44 24 14	 mov	 DWORD PTR _stream$[esp+76], eax

; 68   :             len -= stream.avail_in;

  000a3	2b d8		 sub	 ebx, eax
$LN9@uncompress:

; 69   :         }
; 70   :         err = inflate(&stream, Z_NO_FLUSH);

  000a5	8d 44 24 10	 lea	 eax, DWORD PTR _stream$[esp+72]
  000a9	6a 00		 push	 0
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 _inflate
  000b1	8b f0		 mov	 esi, eax
  000b3	83 c4 08	 add	 esp, 8

; 71   :     } while (err == Z_OK);

  000b6	85 f6		 test	 esi, esi
  000b8	75 06		 jne	 SHORT $LN26@uncompress
  000ba	8b 44 24 20	 mov	 eax, DWORD PTR _stream$[esp+88]
  000be	eb bc		 jmp	 SHORT $LN27@uncompress
$LN26@uncompress:

; 72   : 
; 73   :     *sourceLen -= len + stream.avail_in;

  000c0	8b 4d 14	 mov	 ecx, DWORD PTR _sourceLen$[ebp]
  000c3	8b 44 24 14	 mov	 eax, DWORD PTR _stream$[esp+76]
  000c7	03 c3		 add	 eax, ebx
  000c9	29 01		 sub	 DWORD PTR [ecx], eax

; 74   :     if (dest != buf)

  000cb	8d 44 24 0f	 lea	 eax, DWORD PTR _buf$[esp+72]
  000cf	39 45 08	 cmp	 DWORD PTR _dest$[ebp], eax
  000d2	74 0b		 je	 SHORT $LN10@uncompress

; 75   :         *destLen = stream.total_out;

  000d4	8b 4d 0c	 mov	 ecx, DWORD PTR _destLen$[ebp]
  000d7	8b 44 24 24	 mov	 eax, DWORD PTR _stream$[esp+92]
  000db	89 01		 mov	 DWORD PTR [ecx], eax
  000dd	eb 12		 jmp	 SHORT $LN12@uncompress
$LN10@uncompress:

; 76   :     else if (stream.total_out && err == Z_BUF_ERROR)

  000df	83 7c 24 24 00	 cmp	 DWORD PTR _stream$[esp+92], 0
  000e4	74 0b		 je	 SHORT $LN12@uncompress
  000e6	83 fe fb	 cmp	 esi, -5			; fffffffbH
  000e9	b8 01 00 00 00	 mov	 eax, 1
  000ee	0f 44 f8	 cmove	 edi, eax
$LN12@uncompress:

; 77   :         left = 1;
; 78   : 
; 79   :     inflateEnd(&stream);

  000f1	8d 44 24 10	 lea	 eax, DWORD PTR _stream$[esp+72]
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 _inflateEnd
  000fb	83 c4 04	 add	 esp, 4

; 80   :     return err == Z_STREAM_END ? Z_OK :

  000fe	83 fe 01	 cmp	 esi, 1
  00101	75 0b		 jne	 SHORT $LN18@uncompress
  00103	33 f6		 xor	 esi, esi
  00105	8b c6		 mov	 eax, esi

; 81   :            err == Z_NEED_DICT ? Z_DATA_ERROR  :
; 82   :            err == Z_BUF_ERROR && left + stream.avail_out ? Z_DATA_ERROR :
; 83   :            err;
; 84   : }

  00107	5f		 pop	 edi
  00108	5e		 pop	 esi
  00109	5b		 pop	 ebx
  0010a	8b e5		 mov	 esp, ebp
  0010c	5d		 pop	 ebp
  0010d	c3		 ret	 0
$LN18@uncompress:

; 80   :     return err == Z_STREAM_END ? Z_OK :

  0010e	83 fe 02	 cmp	 esi, 2
  00111	74 0d		 je	 SHORT $LN28@uncompress
  00113	83 fe fb	 cmp	 esi, -5			; fffffffbH
  00116	75 0d		 jne	 SHORT $LN15@uncompress
  00118	8b 44 24 20	 mov	 eax, DWORD PTR _stream$[esp+88]
  0011c	03 c7		 add	 eax, edi
  0011e	74 05		 je	 SHORT $LN15@uncompress
$LN28@uncompress:
  00120	be fd ff ff ff	 mov	 esi, -3			; fffffffdH
$LN15@uncompress:
  00125	8b c6		 mov	 eax, esi
$LN1@uncompress:

; 81   :            err == Z_NEED_DICT ? Z_DATA_ERROR  :
; 82   :            err == Z_BUF_ERROR && left + stream.avail_out ? Z_DATA_ERROR :
; 83   :            err;
; 84   : }

  00127	5f		 pop	 edi
  00128	5e		 pop	 esi
  00129	5b		 pop	 ebx
  0012a	8b e5		 mov	 esp, ebp
  0012c	5d		 pop	 ebp
  0012d	c3		 ret	 0
_uncompress2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\uncompr.c
;	COMDAT _uncompress
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_destLen$ = 12						; size = 4
_source$ = 16						; size = 4
_sourceLen$ = 20					; size = 4
_uncompress PROC					; COMDAT

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 92   :     return uncompress2(dest, destLen, source, &sourceLen);

  00003	8d 45 14	 lea	 eax, DWORD PTR _sourceLen$[ebp]
  00006	50		 push	 eax
  00007	ff 75 10	 push	 DWORD PTR _source$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR _destLen$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR _dest$[ebp]
  00010	e8 00 00 00 00	 call	 _uncompress2
  00015	83 c4 10	 add	 esp, 16			; 00000010H

; 93   : }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
_uncompress ENDP
_TEXT	ENDS
END
