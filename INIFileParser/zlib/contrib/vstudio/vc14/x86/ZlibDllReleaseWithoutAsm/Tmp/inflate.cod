; Listing generated by Microsoft (R) Optimizing Compiler Version 19.11.25508.2 

	TITLE	c:\users\theclashingfritz\source\repos\inifileparser\zlib\inflate.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ ; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@	; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ ; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@	; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ ; `string'
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ DB 'incorrect length che'
	DB	'ck', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ DB 'unknown header fl'
	DB	'ags set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ DB 'unknown compress'
	DB	'ion method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ DB 'incorrect header che'
	DB	'ck', 00H					; `string'
	ORG $+2
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	_inflateCodesUsed
PUBLIC	_inflateMark
PUBLIC	_inflateValidate
PUBLIC	_inflateUndermine
PUBLIC	_inflateCopy
PUBLIC	_inflateSyncPoint
PUBLIC	_inflateSync
PUBLIC	_inflateGetHeader
PUBLIC	_inflateSetDictionary
PUBLIC	_inflateGetDictionary
PUBLIC	_inflatePrime
PUBLIC	_inflateInit_
PUBLIC	_inflateReset2
PUBLIC	_inflateResetKeep
PUBLIC	_inflateEnd
PUBLIC	_inflate
PUBLIC	_inflateInit2_
PUBLIC	_inflateReset
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\inflate.c
;	COMDAT _inflateReset
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateReset PROC					; COMDAT

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 147  :     struct inflate_state FAR *state;
; 148  : 
; 149  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 07		 je	 SHORT $LN2@inflateRes
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 155  : }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
$LN2@inflateRes:

; 150  :     state = (struct inflate_state FAR *)strm->state;

  00016	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 151  :     state->wsize = 0;
; 152  :     state->whave = 0;
; 153  :     state->wnext = 0;
; 154  :     return inflateResetKeep(strm);

  00019	89 4d 08	 mov	 DWORD PTR _strm$[ebp], ecx
  0001c	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0
  00023	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0
  0002a	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0

; 155  : }

  00031	5d		 pop	 ebp

; 151  :     state->wsize = 0;
; 152  :     state->whave = 0;
; 153  :     state->wnext = 0;
; 154  :     return inflateResetKeep(strm);

  00032	e9 00 00 00 00	 jmp	 _inflateResetKeep
_inflateReset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\inflate.c
;	COMDAT _inflateInit2_
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_version$ = 16						; size = 4
_stream_size$ = 20					; size = 4
_inflateInit2_ PROC					; COMDAT

; 200  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 201  :     int ret;
; 202  :     struct inflate_state FAR *state;
; 203  : 
; 204  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||

  00003	8b 45 10	 mov	 eax, DWORD PTR _version$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	0f 84 a9 00 00
	00		 je	 $LN3@inflateIni
  0000e	80 38 31	 cmp	 BYTE PTR [eax], 49	; 00000031H
  00011	0f 85 a0 00 00
	00		 jne	 $LN3@inflateIni
  00017	83 7d 14 38	 cmp	 DWORD PTR _stream_size$[ebp], 56 ; 00000038H
  0001b	0f 85 96 00 00
	00		 jne	 $LN3@inflateIni

; 207  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  00021	56		 push	 esi
  00022	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00025	85 f6		 test	 esi, esi
  00027	75 06		 jne	 SHORT $LN4@inflateIni
  00029	8d 46 fe	 lea	 eax, DWORD PTR [esi-2]
  0002c	5e		 pop	 esi

; 237  : }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
$LN4@inflateIni:

; 208  :     strm->msg = Z_NULL;                 /* in case we return an error */
; 209  :     if (strm->zalloc == (alloc_func)0) {

  0002f	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  00033	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  0003a	75 0e		 jne	 SHORT $LN5@inflateIni

; 210  : #ifdef Z_SOLO
; 211  :         return Z_STREAM_ERROR;
; 212  : #else
; 213  :         strm->zalloc = zcalloc;

  0003c	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], OFFSET _zcalloc

; 214  :         strm->opaque = (voidpf)0;

  00043	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
$LN5@inflateIni:

; 215  : #endif
; 216  :     }
; 217  :     if (strm->zfree == (free_func)0)

  0004a	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  0004e	75 07		 jne	 SHORT $LN6@inflateIni

; 218  : #ifdef Z_SOLO
; 219  :         return Z_STREAM_ERROR;
; 220  : #else
; 221  :         strm->zfree = zcfree;

  00050	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], OFFSET _zcfree
$LN6@inflateIni:

; 222  : #endif
; 223  :     state = (struct inflate_state FAR *)

  00057	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0005a	57		 push	 edi
  0005b	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  00060	6a 01		 push	 1
  00062	ff 76 28	 push	 DWORD PTR [esi+40]
  00065	ff d0		 call	 eax
  00067	8b f8		 mov	 edi, eax
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 224  :             ZALLOC(strm, 1, sizeof(struct inflate_state));
; 225  :     if (state == Z_NULL) return Z_MEM_ERROR;

  0006c	85 ff		 test	 edi, edi
  0006e	75 07		 jne	 SHORT $LN7@inflateIni
  00070	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  00073	5f		 pop	 edi
  00074	5e		 pop	 esi

; 237  : }

  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
$LN7@inflateIni:

; 226  :     Tracev((stderr, "inflate: allocated\n"));
; 227  :     strm->state = (struct internal_state FAR *)state;

  00077	53		 push	 ebx

; 228  :     state->strm = strm;
; 229  :     state->window = Z_NULL;
; 230  :     state->mode = HEAD;     /* to pass state test in inflateReset2() */
; 231  :     ret = inflateReset2(strm, windowBits);

  00078	ff 75 0c	 push	 DWORD PTR _windowBits$[ebp]
  0007b	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  0007e	56		 push	 esi
  0007f	89 37		 mov	 DWORD PTR [edi], esi
  00081	c7 47 38 00 00
	00 00		 mov	 DWORD PTR [edi+56], 0
  00088	c7 47 04 34 3f
	00 00		 mov	 DWORD PTR [edi+4], 16180 ; 00003f34H
  0008f	e8 00 00 00 00	 call	 _inflateReset2
  00094	8b d8		 mov	 ebx, eax
  00096	83 c4 08	 add	 esp, 8

; 232  :     if (ret != Z_OK) {

  00099	85 db		 test	 ebx, ebx
  0009b	74 13		 je	 SHORT $LN8@inflateIni

; 233  :         ZFREE(strm, state);

  0009d	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  000a0	57		 push	 edi
  000a1	ff 76 28	 push	 DWORD PTR [esi+40]
  000a4	ff d1		 call	 ecx
  000a6	83 c4 08	 add	 esp, 8

; 234  :         strm->state = Z_NULL;

  000a9	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
$LN8@inflateIni:

; 235  :     }
; 236  :     return ret;

  000b0	8b c3		 mov	 eax, ebx
  000b2	5b		 pop	 ebx
  000b3	5f		 pop	 edi
  000b4	5e		 pop	 esi

; 237  : }

  000b5	5d		 pop	 ebp
  000b6	c3		 ret	 0
$LN3@inflateIni:

; 205  :         stream_size != (int)(sizeof(z_stream)))
; 206  :         return Z_VERSION_ERROR;

  000b7	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH

; 237  : }

  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
_inflateInit2_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\inflate.c
;	COMDAT _inflate
_TEXT	SEGMENT
_in$1$ = -56						; size = 4
$T1 = -52						; size = 4
_from$1$ = -52						; size = 4
_copy$9$ = -52						; size = 4
tv3102 = -52						; size = 4
tv3052 = -52						; size = 4
tv3041 = -52						; size = 4
tv3036 = -52						; size = 4
tv3029 = -52						; size = 4
tv3027 = -52						; size = 4
tv3026 = -52						; size = 4
tv3020 = -52						; size = 4
tv3018 = -52						; size = 4
tv3017 = -52						; size = 4
tv2992 = -52						; size = 4
tv2990 = -52						; size = 4
tv2988 = -52						; size = 4
tv2987 = -52						; size = 4
tv2979 = -52						; size = 4
tv2714 = -52						; size = 4
_copy$7$ = -52						; size = 4
_copy$4$ = -52						; size = 4
_copy$3$ = -52						; size = 4
_copy$2$ = -52						; size = 4
_len$1$ = -52						; size = 4
tv3030 = -48						; size = 4
tv3005 = -48						; size = 4
tv3004 = -48						; size = 4
tv2955 = -48						; size = 4
_copy$1$ = -48						; size = 4
_len$5$ = -48						; size = 4
_last$ = -48						; size = 4
_here$ = -48						; size = 4
_ret$1$ = -44						; size = 4
_copy$12$ = -40						; size = 4
_copy$10$ = -40						; size = 4
_copy$8$ = -40						; size = 4
tv3120 = -40						; size = 4
tv3028 = -40						; size = 4
tv3003 = -40						; size = 4
tv2989 = -40						; size = 4
_len$4$ = -40						; size = 4
_len$3$ = -40						; size = 4
_len$2$ = -40						; size = 4
_out$1$ = -36						; size = 4
_put$1$ = -32						; size = 4
_hbuf$ = -28						; size = 4
_left$1$ = -24						; size = 4
_bits$1$ = -20						; size = 4
_next$1$ = -16						; size = 4
tv2994 = -12						; size = 4
_have$1$ = -12						; size = 4
_state$1$ = -8						; size = 4
_hold$1$ = -4						; size = 4
_strm$ = 8						; size = 4
_flush$ = 12						; size = 4
_inflate PROC						; COMDAT

; 625  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 626  :     struct inflate_state FAR *state;
; 627  :     z_const unsigned char FAR *next;    /* next input */
; 628  :     unsigned char FAR *put;     /* next output */
; 629  :     unsigned have, left;        /* available input and output */
; 630  :     unsigned long hold;         /* bit buffer */
; 631  :     unsigned bits;              /* bits in bit buffer */
; 632  :     unsigned in, out;           /* save starting available input and output */
; 633  :     unsigned copy;              /* number of stored or match bytes to copy */
; 634  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 635  :     code here;                  /* current decoding table entry */
; 636  :     code last;                  /* parent table entry */
; 637  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 638  :     int ret;                    /* return code */
; 639  : #ifdef GUNZIP
; 640  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 641  : #endif
; 642  :     static const unsigned short order[19] = /* permutation of code lengths */
; 643  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 644  : 
; 645  :     if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	83 ec 38	 sub	 esp, 56			; 00000038H
  00009	8b ca		 mov	 ecx, edx
  0000b	e8 00 00 00 00	 call	 _inflateStateCheck
  00010	85 c0		 test	 eax, eax
  00012	0f 85 80 16 00
	00		 jne	 $LN333@inflate
  00018	39 42 0c	 cmp	 DWORD PTR [edx+12], eax
  0001b	0f 84 77 16 00
	00		 je	 $LN333@inflate
  00021	39 02		 cmp	 DWORD PTR [edx], eax
  00023	75 09		 jne	 SHORT $LN332@inflate
  00025	39 42 04	 cmp	 DWORD PTR [edx+4], eax
  00028	0f 85 6a 16 00
	00		 jne	 $LN333@inflate
$LN332@inflate:

; 648  : 
; 649  :     state = (struct inflate_state FAR *)strm->state;

  0002e	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]
  00031	89 4d f8	 mov	 DWORD PTR _state$1$[ebp], ecx

; 650  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  00034	81 79 04 3f 3f
	00 00		 cmp	 DWORD PTR [ecx+4], 16191 ; 00003f3fH
  0003b	75 07		 jne	 SHORT $LN4@inflate
  0003d	c7 41 04 40 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16192 ; 00003f40H
$LN4@inflate:

; 651  :     LOAD();

  00044	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00047	89 45 e0	 mov	 DWORD PTR _put$1$[ebp], eax
  0004a	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0004d	89 45 e8	 mov	 DWORD PTR _left$1$[ebp], eax

; 652  :     in = have;
; 653  :     out = left;

  00050	89 45 dc	 mov	 DWORD PTR _out$1$[ebp], eax

; 654  :     ret = Z_OK;

  00053	33 c0		 xor	 eax, eax
  00055	53		 push	 ebx
  00056	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]
  00059	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax

; 655  :     for (;;)
; 656  :         switch (state->mode) {

  0005c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0005f	56		 push	 esi
  00060	8b 71 40	 mov	 esi, DWORD PTR [ecx+64]
  00063	2d 34 3f 00 00	 sub	 eax, 16180		; 00003f34H
  00068	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0006b	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0006e	89 5d c8	 mov	 DWORD PTR _in$1$[ebp], ebx
  00071	57		 push	 edi
  00072	8b 3a		 mov	 edi, DWORD PTR [edx]
  00074	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00077	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0007a	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0007d	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  00080	0f 87 f3 14 00
	00		 ja	 $LN499@inflate
$LL5@inflate:
  00086	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN963@inflate[eax*4]
$LN335@inflate:

; 657  :         case HEAD:
; 658  :             if (state->wrap == 0) {

  0008d	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00090	89 45 cc	 mov	 DWORD PTR tv3102[ebp], eax
  00093	85 c0		 test	 eax, eax
  00095	75 0c		 jne	 SHORT $LN12@inflate

; 659  :                 state->mode = TYPEDO;

  00097	c7 41 04 40 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16192 ; 00003f40H

; 660  :                 break;

  0009e	e9 c5 14 00 00	 jmp	 $LN8@inflate
$LN12@inflate:

; 661  :             }
; 662  :             NEEDBITS(16);

  000a3	83 fe 10	 cmp	 esi, 16			; 00000010H
  000a6	73 2d		 jae	 SHORT $LN10@inflate
$LL13@inflate:
  000a8	85 db		 test	 ebx, ebx
  000aa	0f 84 08 05 00
	00		 je	 $LN915@inflate
  000b0	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  000b3	8b ce		 mov	 ecx, esi
  000b5	d3 e0		 shl	 eax, cl
  000b7	83 c6 08	 add	 esi, 8
  000ba	4b		 dec	 ebx
  000bb	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  000be	03 d0		 add	 edx, eax
  000c0	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  000c3	47		 inc	 edi
  000c4	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  000c7	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  000ca	83 fe 10	 cmp	 esi, 16			; 00000010H
  000cd	72 d9		 jb	 SHORT $LL13@inflate
  000cf	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  000d2	8b 45 cc	 mov	 eax, DWORD PTR tv3102[ebp]
$LN10@inflate:

; 663  : #ifdef GUNZIP
; 664  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  000d5	a8 02		 test	 al, 2
  000d7	74 57		 je	 SHORT $LN338@inflate
  000d9	81 fa 1f 8b 00
	00		 cmp	 edx, 35615		; 00008b1fH
  000df	75 4f		 jne	 SHORT $LN338@inflate

; 665  :                 if (state->wbits == 0)

  000e1	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  000e5	75 07		 jne	 SHORT $LN339@inflate

; 666  :                     state->wbits = 15;

  000e7	c7 41 28 0f 00
	00 00		 mov	 DWORD PTR [ecx+40], 15	; 0000000fH
$LN339@inflate:

; 667  :                 state->check = crc32(0L, Z_NULL, 0);

  000ee	6a 00		 push	 0
  000f0	6a 00		 push	 0
  000f2	6a 00		 push	 0
  000f4	e8 00 00 00 00	 call	 _crc32
  000f9	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 668  :                 CRC2(state->check, hold);

  000fc	6a 02		 push	 2
  000fe	66 c7 45 e4 1f
	8b		 mov	 WORD PTR _hbuf$[ebp], 35615 ; 00008b1fH
  00104	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00107	8d 4d e4	 lea	 ecx, DWORD PTR _hbuf$[ebp]
  0010a	51		 push	 ecx
  0010b	50		 push	 eax
  0010c	e8 00 00 00 00	 call	 _crc32
  00111	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 669  :                 INITBITS();

  00114	33 d2		 xor	 edx, edx
  00116	83 c4 18	 add	 esp, 24			; 00000018H
  00119	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0011c	33 f6		 xor	 esi, esi
  0011e	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00121	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 670  :                 state->mode = FLAGS;

  00124	c7 41 04 35 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16181 ; 00003f35H

; 671  :                 break;

  0012b	e9 38 14 00 00	 jmp	 $LN8@inflate
$LN338@inflate:

; 672  :             }
; 673  :             state->flags = 0;           /* expect zlib header */
; 674  :             if (state->head != Z_NULL)

  00130	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00133	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  0013a	85 c0		 test	 eax, eax
  0013c	74 07		 je	 SHORT $LN340@inflate

; 675  :                 state->head->done = -1;

  0013e	c7 40 30 ff ff
	ff ff		 mov	 DWORD PTR [eax+48], -1
$LN340@inflate:

; 676  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */

  00145	f6 41 0c 01	 test	 BYTE PTR [ecx+12], 1
  00149	0f 84 c1 00 00
	00		 je	 $LN342@inflate
  0014f	0f b6 ca	 movzx	 ecx, dl
  00152	8b c2		 mov	 eax, edx
  00154	c1 e1 08	 shl	 ecx, 8
  00157	33 d2		 xor	 edx, edx
  00159	c1 e8 08	 shr	 eax, 8
  0015c	03 c1		 add	 eax, ecx
  0015e	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  00163	f7 f1		 div	 ecx

; 687  :                 state->mode = BAD;

  00165	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00168	85 d2		 test	 edx, edx
  0016a	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  0016d	0f 85 9d 00 00
	00		 jne	 $LN342@inflate

; 684  :             }
; 685  :             if (BITS(4) != Z_DEFLATED) {

  00173	8b c2		 mov	 eax, edx
  00175	24 0f		 and	 al, 15			; 0000000fH
  00177	3c 08		 cmp	 al, 8
  00179	74 0f		 je	 SHORT $LN26@inflate

; 686  :                 strm->msg = (char *)"unknown compression method";

  0017b	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0017e	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@

; 688  :                 break;

  00185	e9 d7 13 00 00	 jmp	 $LN953@inflate
$LN26@inflate:

; 689  :             }
; 690  :             DROPBITS(4);

  0018a	c1 ea 04	 shr	 edx, 4
  0018d	83 ee 04	 sub	 esi, 4

; 691  :             len = BITS(4) + 8;

  00190	8b c2		 mov	 eax, edx
  00192	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00195	83 e0 0f	 and	 eax, 15			; 0000000fH
  00198	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0019b	83 c0 08	 add	 eax, 8

; 692  :             if (state->wbits == 0)

  0019e	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  001a2	89 45 cc	 mov	 DWORD PTR _len$1$[ebp], eax
  001a5	75 03		 jne	 SHORT $LN344@inflate

; 693  :                 state->wbits = len;

  001a7	89 41 28	 mov	 DWORD PTR [ecx+40], eax
$LN344@inflate:

; 694  :             if (len > 15 || len > state->wbits) {

  001aa	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  001ad	77 52		 ja	 SHORT $LN346@inflate
  001af	3b 41 28	 cmp	 eax, DWORD PTR [ecx+40]
  001b2	77 4d		 ja	 SHORT $LN346@inflate

; 698  :             }
; 699  :             state->dmax = 1U << len;

  001b4	8b 4d cc	 mov	 ecx, DWORD PTR _len$1$[ebp]
  001b7	b8 01 00 00 00	 mov	 eax, 1
  001bc	d3 e0		 shl	 eax, cl
  001be	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 700  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 701  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  001c1	6a 00		 push	 0
  001c3	6a 00		 push	 0
  001c5	6a 00		 push	 0
  001c7	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  001ca	e8 00 00 00 00	 call	 _adler32
  001cf	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  001d2	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d5	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  001d8	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  001db	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 702  :             state->mode = hold & 0x200 ? DICTID : TYPE;

  001de	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  001e1	c1 ea 08	 shr	 edx, 8
  001e4	f7 d2		 not	 edx
  001e6	83 e2 02	 and	 edx, 2
  001e9	81 ca 3d 3f 00
	00		 or	 edx, 16189		; 00003f3dH
  001ef	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 703  :             INITBITS();

  001f2	33 d2		 xor	 edx, edx
  001f4	33 f6		 xor	 esi, esi
  001f6	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  001f9	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 704  :             break;

  001fc	e9 67 13 00 00	 jmp	 $LN8@inflate
$LN346@inflate:

; 695  :                 strm->msg = (char *)"invalid window size";

  00201	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00204	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@

; 696  :                 state->mode = BAD;
; 697  :                 break;

  0020b	e9 51 13 00 00	 jmp	 $LN953@inflate
$LN342@inflate:

; 677  : #else
; 678  :             if (
; 679  : #endif
; 680  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {
; 681  :                 strm->msg = (char *)"incorrect header check";

  00210	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00213	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@

; 682  :                 state->mode = BAD;
; 683  :                 break;

  0021a	e9 42 13 00 00	 jmp	 $LN953@inflate
$LN32@inflate:

; 705  : #ifdef GUNZIP
; 706  :         case FLAGS:
; 707  :             NEEDBITS(16);

  0021f	83 fe 10	 cmp	 esi, 16			; 00000010H
  00222	73 2a		 jae	 SHORT $LN30@inflate
$LL33@inflate:
  00224	85 db		 test	 ebx, ebx
  00226	0f 84 8c 03 00
	00		 je	 $LN915@inflate
  0022c	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0022f	8b ce		 mov	 ecx, esi
  00231	d3 e0		 shl	 eax, cl
  00233	83 c6 08	 add	 esi, 8
  00236	4b		 dec	 ebx
  00237	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0023a	03 d0		 add	 edx, eax
  0023c	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0023f	47		 inc	 edi
  00240	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00243	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00246	83 fe 10	 cmp	 esi, 16			; 00000010H
  00249	72 d9		 jb	 SHORT $LL33@inflate
  0024b	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN30@inflate:

; 708  :             state->flags = (int)(hold);

  0024e	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 709  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  00251	80 fa 08	 cmp	 dl, 8
  00254	74 0f		 je	 SHORT $LN349@inflate

; 710  :                 strm->msg = (char *)"unknown compression method";

  00256	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00259	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@

; 711  :                 state->mode = BAD;
; 712  :                 break;

  00260	e9 fc 12 00 00	 jmp	 $LN953@inflate
$LN349@inflate:

; 713  :             }
; 714  :             if (state->flags & 0xe000) {

  00265	f7 c2 00 e0 00
	00		 test	 edx, 57344		; 0000e000H
  0026b	74 0f		 je	 SHORT $LN350@inflate

; 715  :                 strm->msg = (char *)"unknown header flags set";

  0026d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00270	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@

; 716  :                 state->mode = BAD;
; 717  :                 break;

  00277	e9 e5 12 00 00	 jmp	 $LN953@inflate
$LN350@inflate:

; 718  :             }
; 719  :             if (state->head != Z_NULL)

  0027c	8b 71 24	 mov	 esi, DWORD PTR [ecx+36]
  0027f	85 f6		 test	 esi, esi
  00281	74 0a		 je	 SHORT $LN351@inflate

; 720  :                 state->head->text = (int)((hold >> 8) & 1);

  00283	8b c2		 mov	 eax, edx
  00285	c1 e8 08	 shr	 eax, 8
  00288	83 e0 01	 and	 eax, 1
  0028b	89 06		 mov	 DWORD PTR [esi], eax
$LN351@inflate:

; 721  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  0028d	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  00294	74 26		 je	 SHORT $LN39@inflate
  00296	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  0029a	74 20		 je	 SHORT $LN39@inflate

; 722  :                 CRC2(state->check, hold);

  0029c	6a 02		 push	 2
  0029e	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  002a1	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  002a4	50		 push	 eax
  002a5	ff 71 1c	 push	 DWORD PTR [ecx+28]
  002a8	c1 ea 08	 shr	 edx, 8
  002ab	88 55 e5	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  002ae	e8 00 00 00 00	 call	 _crc32
  002b3	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  002b6	83 c4 0c	 add	 esp, 12			; 0000000cH
  002b9	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN39@inflate:

; 723  :             INITBITS();

  002bc	33 d2		 xor	 edx, edx

; 724  :             state->mode = TIME;

  002be	c7 41 04 36 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16182 ; 00003f36H
  002c5	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  002c8	33 f6		 xor	 esi, esi

; 725  :         case TIME:
; 726  :             NEEDBITS(32);

  002ca	eb 05		 jmp	 SHORT $LL47@inflate
$LN46@inflate:
  002cc	83 fe 20	 cmp	 esi, 32			; 00000020H
  002cf	73 27		 jae	 SHORT $LN44@inflate
$LL47@inflate:
  002d1	85 db		 test	 ebx, ebx
  002d3	0f 84 df 02 00
	00		 je	 $LN915@inflate
  002d9	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  002dc	8b ce		 mov	 ecx, esi
  002de	d3 e0		 shl	 eax, cl
  002e0	4b		 dec	 ebx
  002e1	03 d0		 add	 edx, eax
  002e3	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  002e6	47		 inc	 edi
  002e7	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  002ea	83 c6 08	 add	 esi, 8
  002ed	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  002f0	83 fe 20	 cmp	 esi, 32			; 00000020H
  002f3	72 dc		 jb	 SHORT $LL47@inflate
  002f5	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN44@inflate:

; 727  :             if (state->head != Z_NULL)

  002f8	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  002fb	85 c0		 test	 eax, eax
  002fd	74 03		 je	 SHORT $LN355@inflate

; 728  :                 state->head->time = hold;

  002ff	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN355@inflate:

; 729  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  00302	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  00309	74 36		 je	 SHORT $LN53@inflate
  0030b	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  0030f	74 30		 je	 SHORT $LN53@inflate

; 730  :                 CRC4(state->check, hold);

  00311	8b c2		 mov	 eax, edx
  00313	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  00316	c1 e8 08	 shr	 eax, 8
  00319	88 45 e5	 mov	 BYTE PTR _hbuf$[ebp+1], al
  0031c	8b c2		 mov	 eax, edx
  0031e	c1 e8 10	 shr	 eax, 16			; 00000010H
  00321	88 45 e6	 mov	 BYTE PTR _hbuf$[ebp+2], al
  00324	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  00327	6a 04		 push	 4
  00329	50		 push	 eax
  0032a	ff 71 1c	 push	 DWORD PTR [ecx+28]
  0032d	c1 ea 18	 shr	 edx, 24			; 00000018H
  00330	88 55 e7	 mov	 BYTE PTR _hbuf$[ebp+3], dl
  00333	e8 00 00 00 00	 call	 _crc32
  00338	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0033b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0033e	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN53@inflate:

; 731  :             INITBITS();

  00341	33 d2		 xor	 edx, edx

; 732  :             state->mode = OS;

  00343	c7 41 04 37 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16183 ; 00003f37H
  0034a	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0034d	33 f6		 xor	 esi, esi

; 733  :         case OS:
; 734  :             NEEDBITS(16);

  0034f	eb 05		 jmp	 SHORT $LL61@inflate
$LN60@inflate:
  00351	83 fe 10	 cmp	 esi, 16			; 00000010H
  00354	73 27		 jae	 SHORT $LN58@inflate
$LL61@inflate:
  00356	85 db		 test	 ebx, ebx
  00358	0f 84 5a 02 00
	00		 je	 $LN915@inflate
  0035e	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00361	8b ce		 mov	 ecx, esi
  00363	d3 e0		 shl	 eax, cl
  00365	4b		 dec	 ebx
  00366	03 d0		 add	 edx, eax
  00368	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0036b	47		 inc	 edi
  0036c	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0036f	83 c6 08	 add	 esi, 8
  00372	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00375	83 fe 10	 cmp	 esi, 16			; 00000010H
  00378	72 dc		 jb	 SHORT $LL61@inflate
  0037a	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN58@inflate:

; 735  :             if (state->head != Z_NULL) {

  0037d	8b 71 24	 mov	 esi, DWORD PTR [ecx+36]
  00380	85 f6		 test	 esi, esi
  00382	74 17		 je	 SHORT $LN359@inflate

; 736  :                 state->head->xflags = (int)(hold & 0xff);

  00384	0f b6 c2	 movzx	 eax, dl

; 737  :                 state->head->os = (int)(hold >> 8);

  00387	8b ca		 mov	 ecx, edx
  00389	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0038c	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  0038f	c1 e9 08	 shr	 ecx, 8
  00392	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  00395	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00398	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN359@inflate:

; 738  :             }
; 739  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  0039b	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  003a2	74 26		 je	 SHORT $LN67@inflate
  003a4	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  003a8	74 20		 je	 SHORT $LN67@inflate

; 740  :                 CRC2(state->check, hold);

  003aa	6a 02		 push	 2
  003ac	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  003af	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  003b2	50		 push	 eax
  003b3	ff 71 1c	 push	 DWORD PTR [ecx+28]
  003b6	c1 ea 08	 shr	 edx, 8
  003b9	88 55 e5	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  003bc	e8 00 00 00 00	 call	 _crc32
  003c1	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  003c4	83 c4 0c	 add	 esp, 12			; 0000000cH
  003c7	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN67@inflate:

; 741  :             INITBITS();

  003ca	33 d2		 xor	 edx, edx

; 742  :             state->mode = EXLEN;

  003cc	c7 41 04 38 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16184 ; 00003f38H
  003d3	33 f6		 xor	 esi, esi
  003d5	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  003d8	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN361@inflate:

; 743  :         case EXLEN:
; 744  :             if (state->flags & 0x0400) {

  003db	f7 41 14 00 04
	00 00		 test	 DWORD PTR [ecx+20], 1024 ; 00000400H
  003e2	74 7d		 je	 SHORT $LN362@inflate

; 745  :                 NEEDBITS(16);

  003e4	83 fe 10	 cmp	 esi, 16			; 00000010H
  003e7	73 2e		 jae	 SHORT $LN72@inflate
  003e9	0f 1f 80 00 00
	00 00		 npad	 7
$LL75@inflate:
  003f0	85 db		 test	 ebx, ebx
  003f2	0f 84 c0 01 00
	00		 je	 $LN915@inflate
  003f8	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  003fb	8b ce		 mov	 ecx, esi
  003fd	d3 e0		 shl	 eax, cl
  003ff	4b		 dec	 ebx
  00400	03 d0		 add	 edx, eax
  00402	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00405	47		 inc	 edi
  00406	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00409	83 c6 08	 add	 esi, 8
  0040c	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0040f	83 fe 10	 cmp	 esi, 16			; 00000010H
  00412	72 dc		 jb	 SHORT $LL75@inflate
  00414	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN72@inflate:

; 746  :                 state->length = (unsigned)(hold);
; 747  :                 if (state->head != Z_NULL)

  00417	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0041a	89 51 44	 mov	 DWORD PTR [ecx+68], edx
  0041d	85 c0		 test	 eax, eax
  0041f	74 03		 je	 SHORT $LN365@inflate

; 748  :                     state->head->extra_len = (unsigned)hold;

  00421	89 50 14	 mov	 DWORD PTR [eax+20], edx
$LN365@inflate:

; 749  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  00424	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  0042b	74 26		 je	 SHORT $LN81@inflate
  0042d	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  00431	74 20		 je	 SHORT $LN81@inflate

; 750  :                     CRC2(state->check, hold);

  00433	6a 02		 push	 2
  00435	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  00438	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  0043b	50		 push	 eax
  0043c	ff 71 1c	 push	 DWORD PTR [ecx+28]
  0043f	c1 ea 08	 shr	 edx, 8
  00442	88 55 e5	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  00445	e8 00 00 00 00	 call	 _crc32
  0044a	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0044d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00450	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN81@inflate:

; 751  :                 INITBITS();

  00453	33 f6		 xor	 esi, esi
  00455	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  0045c	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 752  :             }

  0045f	eb 0e		 jmp	 SHORT $LN367@inflate
$LN362@inflate:

; 753  :             else if (state->head != Z_NULL)

  00461	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00464	85 c0		 test	 eax, eax
  00466	74 07		 je	 SHORT $LN367@inflate

; 754  :                 state->head->extra = Z_NULL;

  00468	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
$LN367@inflate:

; 755  :             state->mode = EXTRA;

  0046f	c7 41 04 39 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16185 ; 00003f39H
$LN368@inflate:

; 756  :         case EXTRA:
; 757  :             if (state->flags & 0x0400) {

  00476	f7 41 14 00 04
	00 00		 test	 DWORD PTR [ecx+20], 1024 ; 00000400H
  0047d	0f 84 96 00 00
	00		 je	 $LN374@inflate

; 758  :                 copy = state->length;

  00483	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]

; 759  :                 if (copy > have) copy = have;

  00486	3b c3		 cmp	 eax, ebx
  00488	8b d0		 mov	 edx, eax
  0048a	89 45 d0	 mov	 DWORD PTR _copy$1$[ebp], eax
  0048d	0f 47 d3	 cmova	 edx, ebx
  00490	89 55 cc	 mov	 DWORD PTR _copy$2$[ebp], edx

; 760  :                 if (copy) {

  00493	85 d2		 test	 edx, edx
  00495	74 78		 je	 SHORT $LN371@inflate

; 761  :                     if (state->head != Z_NULL &&

  00497	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0049a	85 c0		 test	 eax, eax
  0049c	74 3f		 je	 SHORT $LN372@inflate
  0049e	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
  004a1	85 ff		 test	 edi, edi
  004a3	89 7d f4	 mov	 DWORD PTR tv2994[ebp], edi
  004a6	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  004a9	74 32		 je	 SHORT $LN372@inflate

; 762  :                         state->head->extra != Z_NULL) {
; 763  :                         len = state->head->extra_len - state->length;

  004ab	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  004ae	2b 4d d0	 sub	 ecx, DWORD PTR _copy$1$[ebp]
  004b1	89 4d d8	 mov	 DWORD PTR _len$2$[ebp], ecx

; 764  :                         zmemcpy(state->head->extra + len, next,

  004b4	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  004b7	8b 45 d8	 mov	 eax, DWORD PTR _len$2$[ebp]
  004ba	03 c2		 add	 eax, edx
  004bc	3b c1		 cmp	 eax, ecx
  004be	8b 45 d8	 mov	 eax, DWORD PTR _len$2$[ebp]
  004c1	76 04		 jbe	 SHORT $LN509@inflate
  004c3	2b c8		 sub	 ecx, eax
  004c5	eb 02		 jmp	 SHORT $LN510@inflate
$LN509@inflate:
  004c7	8b ca		 mov	 ecx, edx
$LN510@inflate:
  004c9	03 45 f4	 add	 eax, DWORD PTR tv2994[ebp]
  004cc	51		 push	 ecx
  004cd	57		 push	 edi
  004ce	50		 push	 eax
  004cf	e8 00 00 00 00	 call	 _memcpy
  004d4	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  004d7	83 c4 0c	 add	 esp, 12			; 0000000cH
  004da	8b 55 cc	 mov	 edx, DWORD PTR _copy$2$[ebp]
$LN372@inflate:

; 765  :                                 len + copy > state->head->extra_max ?
; 766  :                                 state->head->extra_max - len : copy);
; 767  :                     }
; 768  :                     if ((state->flags & 0x0200) && (state->wrap & 4))

  004dd	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  004e4	74 19		 je	 SHORT $LN373@inflate
  004e6	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  004ea	74 13		 je	 SHORT $LN373@inflate

; 769  :                         state->check = crc32(state->check, next, copy);

  004ec	52		 push	 edx
  004ed	57		 push	 edi
  004ee	ff 71 1c	 push	 DWORD PTR [ecx+28]
  004f1	e8 00 00 00 00	 call	 _crc32
  004f6	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  004f9	83 c4 0c	 add	 esp, 12			; 0000000cH
  004fc	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN373@inflate:

; 770  :                     have -= copy;

  004ff	8b 45 cc	 mov	 eax, DWORD PTR _copy$2$[ebp]
  00502	2b d8		 sub	 ebx, eax

; 771  :                     next += copy;

  00504	03 f8		 add	 edi, eax
  00506	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx

; 772  :                     state->length -= copy;

  00509	29 41 44	 sub	 DWORD PTR [ecx+68], eax
  0050c	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
$LN371@inflate:

; 773  :                 }
; 774  :                 if (state->length) goto inf_leave;

  0050f	83 79 44 00	 cmp	 DWORD PTR [ecx+68], 0
  00513	0f 85 9f 00 00
	00		 jne	 $LN915@inflate
$LN374@inflate:

; 775  :             }
; 776  :             state->length = 0;

  00519	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0

; 777  :             state->mode = NAME;

  00520	c7 41 04 3a 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16186 ; 00003f3aH
$LN375@inflate:

; 778  :         case NAME:
; 779  :             if (state->flags & 0x0800) {

  00527	f7 41 14 00 08
	00 00		 test	 DWORD PTR [ecx+20], 2048 ; 00000800H
  0052e	0f 84 0b 01 00
	00		 je	 $LN376@inflate

; 780  :                 if (have == 0) goto inf_leave;

  00534	85 db		 test	 ebx, ebx
  00536	0f 84 7c 00 00
	00		 je	 $LN915@inflate

; 781  :                 copy = 0;

  0053c	33 d2		 xor	 edx, edx
  0053e	66 90		 npad	 2
$LL88@inflate:

; 782  :                 do {
; 783  :                     len = (unsigned)(next[copy++]);

  00540	0f b6 04 3a	 movzx	 eax, BYTE PTR [edx+edi]
  00544	42		 inc	 edx
  00545	89 45 d8	 mov	 DWORD PTR _len$3$[ebp], eax

; 784  :                     if (state->head != Z_NULL &&
; 785  :                             state->head->name != Z_NULL &&

  00548	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0054b	85 c0		 test	 eax, eax
  0054d	74 1e		 je	 SHORT $LN86@inflate
  0054f	8b 70 1c	 mov	 esi, DWORD PTR [eax+28]
  00552	85 f6		 test	 esi, esi
  00554	74 17		 je	 SHORT $LN86@inflate
  00556	8b 71 44	 mov	 esi, DWORD PTR [ecx+68]
  00559	3b 70 20	 cmp	 esi, DWORD PTR [eax+32]
  0055c	73 0f		 jae	 SHORT $LN86@inflate

; 786  :                             state->length < state->head->name_max)
; 787  :                         state->head->name[state->length++] = (Bytef)len;

  0055e	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00561	8b 5d d8	 mov	 ebx, DWORD PTR _len$3$[ebp]
  00564	88 1c 06	 mov	 BYTE PTR [esi+eax], bl
  00567	ff 41 44	 inc	 DWORD PTR [ecx+68]
  0056a	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN86@inflate:

; 788  :                 } while (len && copy < have);

  0056d	8b 45 d8	 mov	 eax, DWORD PTR _len$3$[ebp]
  00570	85 c0		 test	 eax, eax
  00572	74 04		 je	 SHORT $LN380@inflate
  00574	3b d3		 cmp	 edx, ebx
  00576	72 c8		 jb	 SHORT $LL88@inflate
$LN380@inflate:

; 789  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  00578	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  0057f	8b 75 ec	 mov	 esi, DWORD PTR _bits$1$[ebp]
  00582	89 55 cc	 mov	 DWORD PTR _copy$3$[ebp], edx
  00585	74 1f		 je	 SHORT $LN381@inflate
  00587	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  0058b	74 19		 je	 SHORT $LN381@inflate

; 790  :                     state->check = crc32(state->check, next, copy);

  0058d	52		 push	 edx
  0058e	57		 push	 edi
  0058f	ff 71 1c	 push	 DWORD PTR [ecx+28]
  00592	e8 00 00 00 00	 call	 _crc32
  00597	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0059a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0059d	8b 55 cc	 mov	 edx, DWORD PTR _copy$3$[ebp]
  005a0	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  005a3	8b 45 d8	 mov	 eax, DWORD PTR _len$3$[ebp]
$LN381@inflate:

; 791  :                 have -= copy;

  005a6	2b da		 sub	 ebx, edx

; 792  :                 next += copy;

  005a8	03 fa		 add	 edi, edx
  005aa	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  005ad	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi

; 793  :                 if (len) goto inf_leave;

  005b0	85 c0		 test	 eax, eax
  005b2	0f 84 95 00 00
	00		 je	 $LN383@inflate
$LN915@inflate:

; 661  :             }
; 662  :             NEEDBITS(16);

  005b8	8b 45 f4	 mov	 eax, DWORD PTR _have$1$[ebp]
$LN921@inflate:

; 1065 :                     PULLBYTE();

  005bb	8b 55 0c	 mov	 edx, DWORD PTR _flush$[ebp]
$inf_leave$965:

; 1245 :         }
; 1246 : 
; 1247 :     /*
; 1248 :        Return from inflate(), updating the total counts and the check value.
; 1249 :        If there was no progress during the inflate() call, return a buffer
; 1250 :        error.  Call updatewindow() to create and/or update the window state.
; 1251 :        Note: a memory error from inflate() is non-recoverable.
; 1252 :      */
; 1253 :   inf_leave:
; 1254 :     RESTORE();

  005be	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
  005c1	8b 4d e0	 mov	 ecx, DWORD PTR _put$1$[ebp]
  005c4	8b 5d f8	 mov	 ebx, DWORD PTR _state$1$[ebp]
  005c7	89 4f 0c	 mov	 DWORD PTR [edi+12], ecx
  005ca	8b 4d e8	 mov	 ecx, DWORD PTR _left$1$[ebp]
  005cd	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  005d0	8b 4d f0	 mov	 ecx, DWORD PTR _next$1$[ebp]
  005d3	89 47 04	 mov	 DWORD PTR [edi+4], eax
  005d6	8b 45 fc	 mov	 eax, DWORD PTR _hold$1$[ebp]
  005d9	89 0f		 mov	 DWORD PTR [edi], ecx

; 1255 :     if (state->wsize || (out != strm->avail_out && state->mode < BAD &&

  005db	83 7b 2c 00	 cmp	 DWORD PTR [ebx+44], 0
  005df	89 73 40	 mov	 DWORD PTR [ebx+64], esi
  005e2	8b 75 dc	 mov	 esi, DWORD PTR _out$1$[ebp]
  005e5	89 43 3c	 mov	 DWORD PTR [ebx+60], eax
  005e8	75 27		 jne	 SHORT $LN502@inflate
  005ea	3b 77 10	 cmp	 esi, DWORD PTR [edi+16]
  005ed	0f 84 eb 0f 00
	00		 je	 $LN503@inflate
  005f3	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  005f6	3d 51 3f 00 00	 cmp	 eax, 16209		; 00003f51H
  005fb	0f 8d dd 0f 00
	00		 jge	 $LN503@inflate
  00601	3d 4e 3f 00 00	 cmp	 eax, 16206		; 00003f4eH
  00606	7c 09		 jl	 SHORT $LN502@inflate
  00608	83 fa 04	 cmp	 edx, 4
  0060b	0f 84 cd 0f 00
	00		 je	 $LN503@inflate
$LN502@inflate:

; 1256 :             (state->mode < CHECK || flush != Z_FINISH)))
; 1257 :         if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {

  00611	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  00614	8b c6		 mov	 eax, esi
  00616	2b 47 10	 sub	 eax, DWORD PTR [edi+16]
  00619	8b cf		 mov	 ecx, edi
  0061b	50		 push	 eax
  0061c	e8 00 00 00 00	 call	 _updatewindow
  00621	83 c4 04	 add	 esp, 4
  00624	85 c0		 test	 eax, eax
  00626	0f 84 b2 0f 00
	00		 je	 $LN503@inflate

; 1258 :             state->mode = MEM;

  0062c	c7 43 04 52 3f
	00 00		 mov	 DWORD PTR [ebx+4], 16210 ; 00003f52H
$LN498@inflate:
  00633	5f		 pop	 edi
  00634	5e		 pop	 esi

; 1259 :             return Z_MEM_ERROR;

  00635	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0063a	5b		 pop	 ebx

; 1273 :         ret = Z_BUF_ERROR;
; 1274 :     return ret;
; 1275 : }

  0063b	8b e5		 mov	 esp, ebp
  0063d	5d		 pop	 ebp
  0063e	c3		 ret	 0
$LN376@inflate:

; 794  :             }
; 795  :             else if (state->head != Z_NULL)

  0063f	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00642	85 c0		 test	 eax, eax
  00644	74 07		 je	 SHORT $LN383@inflate

; 796  :                 state->head->name = Z_NULL;

  00646	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
$LN383@inflate:

; 797  :             state->length = 0;

  0064d	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0

; 798  :             state->mode = COMMENT;

  00654	c7 41 04 3b 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16187 ; 00003f3bH
$LN384@inflate:

; 799  :         case COMMENT:
; 800  :             if (state->flags & 0x1000) {

  0065b	f7 41 14 00 10
	00 00		 test	 DWORD PTR [ecx+20], 4096 ; 00001000H
  00662	0f 84 84 00 00
	00		 je	 $LN385@inflate

; 801  :                 if (have == 0) goto inf_leave;

  00668	85 db		 test	 ebx, ebx
  0066a	0f 84 48 ff ff
	ff		 je	 $LN915@inflate

; 802  :                 copy = 0;

  00670	33 d2		 xor	 edx, edx
$LL91@inflate:

; 803  :                 do {
; 804  :                     len = (unsigned)(next[copy++]);

  00672	0f b6 04 3a	 movzx	 eax, BYTE PTR [edx+edi]
  00676	42		 inc	 edx
  00677	89 45 d8	 mov	 DWORD PTR _len$4$[ebp], eax

; 805  :                     if (state->head != Z_NULL &&
; 806  :                             state->head->comment != Z_NULL &&

  0067a	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0067d	85 c0		 test	 eax, eax
  0067f	74 1e		 je	 SHORT $LN89@inflate
  00681	8b 70 24	 mov	 esi, DWORD PTR [eax+36]
  00684	85 f6		 test	 esi, esi
  00686	74 17		 je	 SHORT $LN89@inflate
  00688	8b 71 44	 mov	 esi, DWORD PTR [ecx+68]
  0068b	3b 70 28	 cmp	 esi, DWORD PTR [eax+40]
  0068e	73 0f		 jae	 SHORT $LN89@inflate

; 807  :                             state->length < state->head->comm_max)
; 808  :                         state->head->comment[state->length++] = (Bytef)len;

  00690	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  00693	8b 5d d8	 mov	 ebx, DWORD PTR _len$4$[ebp]
  00696	88 1c 06	 mov	 BYTE PTR [esi+eax], bl
  00699	ff 41 44	 inc	 DWORD PTR [ecx+68]
  0069c	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN89@inflate:

; 809  :                 } while (len && copy < have);

  0069f	8b 45 d8	 mov	 eax, DWORD PTR _len$4$[ebp]
  006a2	85 c0		 test	 eax, eax
  006a4	74 04		 je	 SHORT $LN389@inflate
  006a6	3b d3		 cmp	 edx, ebx
  006a8	72 c8		 jb	 SHORT $LL91@inflate
$LN389@inflate:

; 810  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  006aa	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  006b1	8b 75 ec	 mov	 esi, DWORD PTR _bits$1$[ebp]
  006b4	89 55 cc	 mov	 DWORD PTR _copy$4$[ebp], edx
  006b7	74 1f		 je	 SHORT $LN390@inflate
  006b9	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  006bd	74 19		 je	 SHORT $LN390@inflate

; 811  :                     state->check = crc32(state->check, next, copy);

  006bf	52		 push	 edx
  006c0	57		 push	 edi
  006c1	ff 71 1c	 push	 DWORD PTR [ecx+28]
  006c4	e8 00 00 00 00	 call	 _crc32
  006c9	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  006cc	83 c4 0c	 add	 esp, 12			; 0000000cH
  006cf	8b 55 cc	 mov	 edx, DWORD PTR _copy$4$[ebp]
  006d2	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  006d5	8b 45 d8	 mov	 eax, DWORD PTR _len$4$[ebp]
$LN390@inflate:

; 812  :                 have -= copy;

  006d8	2b da		 sub	 ebx, edx

; 813  :                 next += copy;

  006da	03 fa		 add	 edi, edx
  006dc	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  006df	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi

; 814  :                 if (len) goto inf_leave;

  006e2	85 c0		 test	 eax, eax
  006e4	0f 85 ce fe ff
	ff		 jne	 $LN915@inflate

; 815  :             }

  006ea	eb 0e		 jmp	 SHORT $LN392@inflate
$LN385@inflate:

; 816  :             else if (state->head != Z_NULL)

  006ec	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  006ef	85 c0		 test	 eax, eax
  006f1	74 07		 je	 SHORT $LN392@inflate

; 817  :                 state->head->comment = Z_NULL;

  006f3	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0
$LN392@inflate:
  006fa	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]

; 818  :             state->mode = HCRC;

  006fd	c7 41 04 3c 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16188 ; 00003f3cH
$LN393@inflate:

; 819  :         case HCRC:
; 820  :             if (state->flags & 0x0200) {

  00704	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00707	89 45 cc	 mov	 DWORD PTR tv2714[ebp], eax
  0070a	a9 00 02 00 00	 test	 eax, 512		; 00000200H
  0070f	74 58		 je	 SHORT $LN101@inflate

; 821  :                 NEEDBITS(16);

  00711	83 fe 10	 cmp	 esi, 16			; 00000010H
  00714	73 2a		 jae	 SHORT $LN92@inflate
$LL95@inflate:
  00716	85 db		 test	 ebx, ebx
  00718	0f 84 9a fe ff
	ff		 je	 $LN915@inflate
  0071e	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00721	8b ce		 mov	 ecx, esi
  00723	d3 e0		 shl	 eax, cl
  00725	83 c6 08	 add	 esi, 8
  00728	4b		 dec	 ebx
  00729	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0072c	03 d0		 add	 edx, eax
  0072e	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00731	47		 inc	 edi
  00732	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00735	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00738	83 fe 10	 cmp	 esi, 16			; 00000010H
  0073b	72 d9		 jb	 SHORT $LL95@inflate
  0073d	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN92@inflate:

; 822  :                 if ((state->wrap & 4) && hold != (state->check & 0xffff)) {

  00740	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  00744	74 17		 je	 SHORT $LN102@inflate
  00746	0f b7 41 1c	 movzx	 eax, WORD PTR [ecx+28]
  0074a	3b d0		 cmp	 edx, eax
  0074c	74 0f		 je	 SHORT $LN102@inflate

; 823  :                     strm->msg = (char *)"header crc mismatch";

  0074e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00751	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@

; 824  :                     state->mode = BAD;
; 825  :                     break;

  00758	e9 04 0e 00 00	 jmp	 $LN953@inflate
$LN102@inflate:

; 826  :                 }
; 827  :                 INITBITS();

  0075d	33 f6		 xor	 esi, esi
  0075f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  00766	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN101@inflate:

; 828  :             }
; 829  :             if (state->head != Z_NULL) {

  00769	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0076c	85 c0		 test	 eax, eax
  0076e	74 16		 je	 SHORT $LN397@inflate

; 830  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  00770	8b 55 cc	 mov	 edx, DWORD PTR tv2714[ebp]
  00773	c1 fa 09	 sar	 edx, 9
  00776	83 e2 01	 and	 edx, 1
  00779	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 831  :                 state->head->done = 1;

  0077c	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0077f	c7 40 30 01 00
	00 00		 mov	 DWORD PTR [eax+48], 1
$LN397@inflate:

; 832  :             }
; 833  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  00786	6a 00		 push	 0
  00788	6a 00		 push	 0
  0078a	6a 00		 push	 0
  0078c	e8 00 00 00 00	 call	 _crc32
  00791	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00794	83 c4 0c	 add	 esp, 12			; 0000000cH
  00797	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0079a	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  0079d	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 834  :             state->mode = TYPE;
; 835  :             break;

  007a0	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  007a3	c7 41 04 3f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16191 ; 00003f3fH
  007aa	e9 b9 0d 00 00	 jmp	 $LN8@inflate
$LN105@inflate:

; 836  : #endif
; 837  :         case DICTID:
; 838  :             NEEDBITS(32);

  007af	83 fe 20	 cmp	 esi, 32			; 00000020H
  007b2	73 24		 jae	 SHORT $LN103@inflate
$LL106@inflate:
  007b4	85 db		 test	 ebx, ebx
  007b6	0f 84 fc fd ff
	ff		 je	 $LN915@inflate
  007bc	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  007bf	8b ce		 mov	 ecx, esi
  007c1	d3 e0		 shl	 eax, cl
  007c3	4b		 dec	 ebx
  007c4	03 d0		 add	 edx, eax
  007c6	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  007c9	47		 inc	 edi
  007ca	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  007cd	83 c6 08	 add	 esi, 8
  007d0	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  007d3	83 fe 20	 cmp	 esi, 32			; 00000020H
  007d6	72 dc		 jb	 SHORT $LL106@inflate
$LN103@inflate:

; 839  :             strm->adler = state->check = ZSWAP32(hold);

  007d8	8b ca		 mov	 ecx, edx
  007da	8b c2		 mov	 eax, edx
  007dc	c1 e0 10	 shl	 eax, 16			; 00000010H
  007df	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  007e5	03 c8		 add	 ecx, eax
  007e7	8b c2		 mov	 eax, edx
  007e9	c1 e8 08	 shr	 eax, 8
  007ec	c1 e1 08	 shl	 ecx, 8
  007ef	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  007f4	c1 ea 18	 shr	 edx, 24			; 00000018H
  007f7	03 c1		 add	 eax, ecx
  007f9	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  007fc	03 c2		 add	 eax, edx
  007fe	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00801	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00804	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 840  :             INITBITS();

  00807	33 d2		 xor	 edx, edx
  00809	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0080c	33 f6		 xor	 esi, esi

; 841  :             state->mode = DICT;

  0080e	c7 41 04 3e 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16190 ; 00003f3eH
$LN400@inflate:

; 842  :         case DICT:
; 843  :             if (state->havedict == 0) {

  00815	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00819	0f 84 66 0d 00
	00		 je	 $LN586@inflate

; 846  :             }
; 847  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  0081f	6a 00		 push	 0
  00821	6a 00		 push	 0
  00823	6a 00		 push	 0
  00825	e8 00 00 00 00	 call	 _adler32
  0082a	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0082d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00830	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00833	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00836	89 42 30	 mov	 DWORD PTR [edx+48], eax
  00839	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]

; 848  :             state->mode = TYPE;

  0083c	c7 41 04 3f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16191 ; 00003f3fH
$LN402@inflate:

; 849  :         case TYPE:
; 850  :             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;

  00843	8b 45 0c	 mov	 eax, DWORD PTR _flush$[ebp]
  00846	83 f8 05	 cmp	 eax, 5
  00849	0f 84 69 fd ff
	ff		 je	 $LN915@inflate
  0084f	83 f8 06	 cmp	 eax, 6
  00852	0f 84 60 fd ff
	ff		 je	 $LN915@inflate
$LN403@inflate:

; 851  :         case TYPEDO:
; 852  :             if (state->last) {

  00858	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  0085c	74 1e		 je	 SHORT $LN122@inflate

; 853  :                 BYTEBITS();

  0085e	8b ce		 mov	 ecx, esi
  00860	83 e1 07	 and	 ecx, 7
  00863	d3 ea		 shr	 edx, cl
  00865	2b f1		 sub	 esi, ecx

; 854  :                 state->mode = CHECK;

  00867	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0086a	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0086d	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00870	c7 41 04 4e 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16206 ; 00003f4eH

; 855  :                 break;

  00877	e9 ec 0c 00 00	 jmp	 $LN8@inflate
$LN122@inflate:

; 856  :             }
; 857  :             NEEDBITS(3);

  0087c	83 fe 03	 cmp	 esi, 3
  0087f	73 27		 jae	 SHORT $LN120@inflate
$LL123@inflate:
  00881	85 db		 test	 ebx, ebx
  00883	0f 84 2f fd ff
	ff		 je	 $LN915@inflate
  00889	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0088c	8b ce		 mov	 ecx, esi
  0088e	d3 e0		 shl	 eax, cl
  00890	4b		 dec	 ebx
  00891	03 d0		 add	 edx, eax
  00893	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00896	47		 inc	 edi
  00897	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0089a	83 c6 08	 add	 esi, 8
  0089d	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  008a0	83 fe 03	 cmp	 esi, 3
  008a3	72 dc		 jb	 SHORT $LL123@inflate
  008a5	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN120@inflate:

; 858  :             state->last = BITS(1);

  008a8	8b c2		 mov	 eax, edx

; 859  :             DROPBITS(1);

  008aa	d1 ea		 shr	 edx, 1
  008ac	83 e0 01	 and	 eax, 1
  008af	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 860  :             switch (BITS(2)) {

  008b2	8b c2		 mov	 eax, edx
  008b4	83 e0 03	 and	 eax, 3
  008b7	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN964@inflate[eax*4]
$LN408@inflate:

; 884  :             }
; 885  :             DROPBITS(2);

  008be	c1 ea 02	 shr	 edx, 2
  008c1	83 ee 03	 sub	 esi, 3
  008c4	c7 41 04 41 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16193 ; 00003f41H
  008cb	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  008ce	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 886  :             break;

  008d1	e9 92 0c 00 00	 jmp	 $LN8@inflate
$LN409@inflate:

; 861  :             case 0:                             /* stored block */
; 862  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 863  :                         state->last ? " (last)" : ""));
; 864  :                 state->mode = STORED;
; 865  :                 break;
; 866  :             case 1:                             /* fixed block */
; 867  :                 fixedtables(state);

  008d6	e8 00 00 00 00	 call	 _fixedtables

; 868  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 869  :                         state->last ? " (last)" : ""));
; 870  :                 state->mode = LEN_;             /* decode codes */
; 871  :                 if (flush == Z_TREES) {

  008db	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  008df	c7 41 04 47 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16199 ; 00003f47H
  008e6	75 37		 jne	 SHORT $LN138@inflate

; 872  :                     DROPBITS(2);

  008e8	c1 ea 02	 shr	 edx, 2
  008eb	83 ee 03	 sub	 esi, 3
  008ee	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx

; 873  :                     goto inf_leave;

  008f1	e9 c2 fc ff ff	 jmp	 $LN915@inflate
$LN411@inflate:

; 884  :             }
; 885  :             DROPBITS(2);

  008f6	c1 ea 02	 shr	 edx, 2
  008f9	83 ee 03	 sub	 esi, 3
  008fc	c7 41 04 44 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16196 ; 00003f44H
  00903	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00906	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 886  :             break;

  00909	e9 5a 0c 00 00	 jmp	 $LN8@inflate
$LN412@inflate:

; 874  :                 }
; 875  :                 break;
; 876  :             case 2:                             /* dynamic block */
; 877  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 878  :                         state->last ? " (last)" : ""));
; 879  :                 state->mode = TABLE;
; 880  :                 break;
; 881  :             case 3:
; 882  :                 strm->msg = (char *)"invalid block type";

  0090e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00911	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@

; 883  :                 state->mode = BAD;

  00918	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
$LN138@inflate:

; 884  :             }
; 885  :             DROPBITS(2);

  0091f	c1 ea 02	 shr	 edx, 2
  00922	83 ee 03	 sub	 esi, 3
  00925	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00928	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 886  :             break;

  0092b	e9 38 0c 00 00	 jmp	 $LN8@inflate
$LN141@inflate:

; 887  :         case STORED:
; 888  :             BYTEBITS();                         /* go to byte boundary */

  00930	8b ce		 mov	 ecx, esi
  00932	83 e1 07	 and	 ecx, 7
  00935	2b f1		 sub	 esi, ecx
  00937	d3 ea		 shr	 edx, cl
  00939	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0093c	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 889  :             NEEDBITS(32);

  0093f	83 fe 20	 cmp	 esi, 32			; 00000020H
  00942	73 27		 jae	 SHORT $LN142@inflate
$LL145@inflate:
  00944	85 db		 test	 ebx, ebx
  00946	0f 84 6c fc ff
	ff		 je	 $LN915@inflate
  0094c	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0094f	8b ce		 mov	 ecx, esi
  00951	d3 e0		 shl	 eax, cl
  00953	83 c6 08	 add	 esi, 8
  00956	4b		 dec	 ebx
  00957	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0095a	03 d0		 add	 edx, eax
  0095c	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0095f	47		 inc	 edi
  00960	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00963	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00966	83 fe 20	 cmp	 esi, 32			; 00000020H
  00969	72 d9		 jb	 SHORT $LL145@inflate
$LN142@inflate:

; 890  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  0096b	8b c2		 mov	 eax, edx
  0096d	0f b7 ca	 movzx	 ecx, dx
  00970	f7 d0		 not	 eax
  00972	89 4d cc	 mov	 DWORD PTR tv3052[ebp], ecx
  00975	c1 e8 10	 shr	 eax, 16			; 00000010H
  00978	3b c8		 cmp	 ecx, eax

; 892  :                 state->mode = BAD;

  0097a	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0097d	74 0f		 je	 SHORT $LN415@inflate

; 891  :                 strm->msg = (char *)"invalid stored block lengths";

  0097f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00982	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@

; 893  :                 break;

  00989	e9 d3 0b 00 00	 jmp	 $LN953@inflate
$LN415@inflate:

; 894  :             }
; 895  :             state->length = (unsigned)hold & 0xffff;

  0098e	8b 45 cc	 mov	 eax, DWORD PTR tv3052[ebp]

; 896  :             Tracev((stderr, "inflate:       stored length %u\n",
; 897  :                     state->length));
; 898  :             INITBITS();

  00991	33 d2		 xor	 edx, edx
  00993	33 f6		 xor	 esi, esi
  00995	89 41 44	 mov	 DWORD PTR [ecx+68], eax

; 899  :             state->mode = COPY_;
; 900  :             if (flush == Z_TREES) goto inf_leave;

  00998	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  0099c	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0099f	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  009a2	c7 41 04 42 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16194 ; 00003f42H
  009a9	0f 84 09 fc ff
	ff		 je	 $LN915@inflate
$LN416@inflate:

; 901  :         case COPY_:
; 902  :             state->mode = COPY;

  009af	c7 41 04 43 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16195 ; 00003f43H
$LN418@inflate:

; 903  :         case COPY:
; 904  :             copy = state->length;

  009b6	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]

; 905  :             if (copy) {

  009b9	85 c0		 test	 eax, eax
  009bb	0f 84 f0 06 00
	00		 je	 $LN419@inflate

; 906  :                 if (copy > have) copy = have;

  009c1	3b c3		 cmp	 eax, ebx
  009c3	0f 47 c3	 cmova	 eax, ebx

; 907  :                 if (copy > left) copy = left;

  009c6	3b 45 e8	 cmp	 eax, DWORD PTR _left$1$[ebp]
  009c9	0f 47 45 e8	 cmova	 eax, DWORD PTR _left$1$[ebp]
  009cd	89 45 cc	 mov	 DWORD PTR _copy$7$[ebp], eax

; 908  :                 if (copy == 0) goto inf_leave;

  009d0	85 c0		 test	 eax, eax
  009d2	0f 84 e0 fb ff
	ff		 je	 $LN915@inflate

; 909  :                 zmemcpy(put, next, copy);

  009d8	50		 push	 eax
  009d9	57		 push	 edi
  009da	ff 75 e0	 push	 DWORD PTR _put$1$[ebp]
  009dd	e8 00 00 00 00	 call	 _memcpy

; 910  :                 have -= copy;

  009e2	8b 45 cc	 mov	 eax, DWORD PTR _copy$7$[ebp]
  009e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 911  :                 next += copy;
; 912  :                 left -= copy;
; 913  :                 put += copy;
; 914  :                 state->length -= copy;

  009e8	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  009eb	2b d8		 sub	 ebx, eax
  009ed	29 45 e8	 sub	 DWORD PTR _left$1$[ebp], eax
  009f0	03 f8		 add	 edi, eax
  009f2	01 45 e0	 add	 DWORD PTR _put$1$[ebp], eax

; 915  :                 break;

  009f5	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  009f8	29 41 44	 sub	 DWORD PTR [ecx+68], eax
  009fb	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  009fe	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00a01	e9 62 0b 00 00	 jmp	 $LN8@inflate
$LN155@inflate:

; 916  :             }
; 917  :             Tracev((stderr, "inflate:       stored end\n"));
; 918  :             state->mode = TYPE;
; 919  :             break;
; 920  :         case TABLE:
; 921  :             NEEDBITS(14);

  00a06	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  00a09	73 2c		 jae	 SHORT $LN153@inflate
  00a0b	0f 1f 44 00 00	 npad	 5
$LL156@inflate:
  00a10	85 db		 test	 ebx, ebx
  00a12	0f 84 a0 fb ff
	ff		 je	 $LN915@inflate
  00a18	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00a1b	8b ce		 mov	 ecx, esi
  00a1d	d3 e0		 shl	 eax, cl
  00a1f	4b		 dec	 ebx
  00a20	03 d0		 add	 edx, eax
  00a22	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00a25	47		 inc	 edi
  00a26	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00a29	83 c6 08	 add	 esi, 8
  00a2c	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00a2f	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  00a32	72 dc		 jb	 SHORT $LL156@inflate
  00a34	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN153@inflate:

; 922  :             state->nlen = BITS(5) + 257;

  00a37	8b c2		 mov	 eax, edx

; 923  :             DROPBITS(5);
; 924  :             state->ndist = BITS(5) + 1;
; 925  :             DROPBITS(5);
; 926  :             state->ncode = BITS(4) + 4;
; 927  :             DROPBITS(4);

  00a39	83 ee 0e	 sub	 esi, 14			; 0000000eH
  00a3c	83 e0 1f	 and	 eax, 31			; 0000001fH
  00a3f	c1 ea 05	 shr	 edx, 5
  00a42	05 01 01 00 00	 add	 eax, 257		; 00000101H
  00a47	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00a4a	89 41 64	 mov	 DWORD PTR [ecx+100], eax
  00a4d	8b c2		 mov	 eax, edx
  00a4f	83 e0 1f	 and	 eax, 31			; 0000001fH
  00a52	c1 ea 05	 shr	 edx, 5
  00a55	40		 inc	 eax
  00a56	89 41 68	 mov	 DWORD PTR [ecx+104], eax
  00a59	8b c2		 mov	 eax, edx
  00a5b	83 e0 0f	 and	 eax, 15			; 0000000fH
  00a5e	c1 ea 04	 shr	 edx, 4
  00a61	83 c0 04	 add	 eax, 4
  00a64	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx

; 928  : #ifndef PKZIP_BUG_WORKAROUND
; 929  :             if (state->nlen > 286 || state->ndist > 30) {

  00a67	81 79 64 1e 01
	00 00		 cmp	 DWORD PTR [ecx+100], 286 ; 0000011eH
  00a6e	89 41 60	 mov	 DWORD PTR [ecx+96], eax
  00a71	0f 87 f6 00 00
	00		 ja	 $LN426@inflate
  00a77	83 79 68 1e	 cmp	 DWORD PTR [ecx+104], 30	; 0000001eH
  00a7b	0f 87 ec 00 00
	00		 ja	 $LN426@inflate

; 933  :             }
; 934  : #endif
; 935  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 936  :             state->have = 0;

  00a81	c7 41 6c 00 00
	00 00		 mov	 DWORD PTR [ecx+108], 0

; 937  :             state->mode = LENLENS;

  00a88	c7 41 04 45 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16197 ; 00003f45H
$LN532@inflate:

; 938  :         case LENLENS:
; 939  :             while (state->have < state->ncode) {

  00a8f	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00a92	3b 41 60	 cmp	 eax, DWORD PTR [ecx+96]
  00a95	73 64		 jae	 SHORT $LN534@inflate
$LL170@inflate:

; 940  :                 NEEDBITS(3);

  00a97	83 fe 03	 cmp	 esi, 3
  00a9a	73 28		 jae	 SHORT $LN172@inflate
  00a9c	0f 1f 40 00	 npad	 4
$LL175@inflate:
  00aa0	85 db		 test	 ebx, ebx
  00aa2	0f 84 10 fb ff
	ff		 je	 $LN915@inflate
  00aa8	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00aab	8b ce		 mov	 ecx, esi
  00aad	d3 e0		 shl	 eax, cl
  00aaf	4b		 dec	 ebx
  00ab0	03 d0		 add	 edx, eax
  00ab2	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00ab5	47		 inc	 edi
  00ab6	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00ab9	83 c6 08	 add	 esi, 8
  00abc	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00abf	83 fe 03	 cmp	 esi, 3
  00ac2	72 dc		 jb	 SHORT $LL175@inflate
$LN172@inflate:

; 941  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  00ac4	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00ac7	8b ca		 mov	 ecx, edx
  00ac9	8b 7d f8	 mov	 edi, DWORD PTR _state$1$[ebp]
  00acc	83 e1 07	 and	 ecx, 7

; 942  :                 DROPBITS(3);

  00acf	c1 ea 03	 shr	 edx, 3
  00ad2	83 ee 03	 sub	 esi, 3
  00ad5	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00ad8	8b 40 6c	 mov	 eax, DWORD PTR [eax+108]
  00adb	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00ade	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  00ae6	66 89 4c 47 74	 mov	 WORD PTR [edi+eax*2+116], cx
  00aeb	8b cf		 mov	 ecx, edi
  00aed	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  00af0	ff 41 6c	 inc	 DWORD PTR [ecx+108]
  00af3	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00af6	3b 41 60	 cmp	 eax, DWORD PTR [ecx+96]
  00af9	72 9c		 jb	 SHORT $LL170@inflate
$LN534@inflate:

; 943  :             }
; 944  :             while (state->have < 19)

  00afb	83 79 6c 13	 cmp	 DWORD PTR [ecx+108], 19	; 00000013H
  00aff	73 1b		 jae	 SHORT $LN184@inflate
$LL183@inflate:

; 945  :                 state->lens[order[state->have++]] = 0;

  00b01	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00b04	33 d2		 xor	 edx, edx
  00b06	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  00b0e	66 89 54 41 74	 mov	 WORD PTR [ecx+eax*2+116], dx
  00b13	ff 41 6c	 inc	 DWORD PTR [ecx+108]
  00b16	83 79 6c 13	 cmp	 DWORD PTR [ecx+108], 19	; 00000013H
  00b1a	72 e5		 jb	 SHORT $LL183@inflate
$LN184@inflate:

; 946  :             state->next = state->codes;

  00b1c	8d 81 34 05 00
	00		 lea	 eax, DWORD PTR [ecx+1332]

; 947  :             state->lencode = (const code FAR *)(state->next);
; 948  :             state->lenbits = 7;

  00b22	c7 41 58 07 00
	00 00		 mov	 DWORD PTR [ecx+88], 7
  00b29	8d 51 70	 lea	 edx, DWORD PTR [ecx+112]
  00b2c	89 41 50	 mov	 DWORD PTR [ecx+80], eax
  00b2f	89 02		 mov	 DWORD PTR [edx], eax
  00b31	83 c1 58	 add	 ecx, 88			; 00000058H

; 949  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),

  00b34	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00b37	05 f4 02 00 00	 add	 eax, 756		; 000002f4H
  00b3c	50		 push	 eax
  00b3d	51		 push	 ecx
  00b3e	52		 push	 edx
  00b3f	8b 55 f8	 mov	 edx, DWORD PTR _state$1$[ebp]
  00b42	33 c9		 xor	 ecx, ecx
  00b44	6a 13		 push	 19			; 00000013H
  00b46	8d 52 74	 lea	 edx, DWORD PTR [edx+116]
  00b49	e8 00 00 00 00	 call	 _inflate_table

; 953  :                 state->mode = BAD;

  00b4e	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00b51	83 c4 10	 add	 esp, 16			; 00000010H

; 954  :                 break;

  00b54	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00b57	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax
  00b5a	85 c0		 test	 eax, eax
  00b5c	74 1e		 je	 SHORT $LN429@inflate

; 950  :                                 &(state->lenbits), state->work);
; 951  :             if (ret) {
; 952  :                 strm->msg = (char *)"invalid code lengths set";

  00b5e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00b61	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@

; 954  :                 break;

  00b68	e9 f4 09 00 00	 jmp	 $LN953@inflate
$LN426@inflate:

; 930  :                 strm->msg = (char *)"too many length or distance symbols";

  00b6d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00b70	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@

; 931  :                 state->mode = BAD;
; 932  :                 break;

  00b77	e9 e5 09 00 00	 jmp	 $LN953@inflate
$LN429@inflate:

; 955  :             }
; 956  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 957  :             state->have = 0;

  00b7c	c7 41 6c 00 00
	00 00		 mov	 DWORD PTR [ecx+108], 0

; 958  :             state->mode = CODELENS;

  00b83	c7 41 04 46 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16198 ; 00003f46H
$LN535@inflate:

; 959  :         case CODELENS:
; 960  :             while (state->have < state->nlen + state->ndist) {

  00b8a	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00b8d	03 41 64	 add	 eax, DWORD PTR [ecx+100]
  00b90	39 41 6c	 cmp	 DWORD PTR [ecx+108], eax
  00b93	0f 83 32 02 00
	00		 jae	 $LN186@inflate
  00b99	0f 1f 80 00 00
	00 00		 npad	 7
$LL185@inflate:

; 961  :                 for (;;) {
; 962  :                     here = state->lencode[BITS(state->lenbits)];

  00ba0	8b 49 58	 mov	 ecx, DWORD PTR [ecx+88]
  00ba3	b8 01 00 00 00	 mov	 eax, 1
  00ba8	d3 e0		 shl	 eax, cl
  00baa	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00bad	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00bb0	89 4d d8	 mov	 DWORD PTR tv2989[ebp], ecx
  00bb3	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  00bb6	89 45 cc	 mov	 DWORD PTR tv3029[ebp], eax
  00bb9	8b c1		 mov	 eax, ecx
  00bbb	8b 4d cc	 mov	 ecx, DWORD PTR tv3029[ebp]
  00bbe	23 c2		 and	 eax, edx
  00bc0	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 963  :                     if ((unsigned)(here.bits) <= bits) break;

  00bc3	8b c8		 mov	 ecx, eax
  00bc5	c1 e9 08	 shr	 ecx, 8
  00bc8	0f b6 c9	 movzx	 ecx, cl
  00bcb	89 45 d0	 mov	 DWORD PTR _here$[ebp], eax
  00bce	3b ce		 cmp	 ecx, esi
  00bd0	76 39		 jbe	 SHORT $LN562@inflate
$LL187@inflate:

; 964  :                     PULLBYTE();

  00bd2	85 db		 test	 ebx, ebx
  00bd4	0f 84 de f9 ff
	ff		 je	 $LN915@inflate
  00bda	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00bdd	8b ce		 mov	 ecx, esi
  00bdf	d3 e0		 shl	 eax, cl
  00be1	4b		 dec	 ebx
  00be2	8b 4d cc	 mov	 ecx, DWORD PTR tv3029[ebp]
  00be5	03 d0		 add	 edx, eax
  00be7	8b 45 d8	 mov	 eax, DWORD PTR tv2989[ebp]
  00bea	47		 inc	 edi
  00beb	23 c2		 and	 eax, edx
  00bed	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00bf0	83 c6 08	 add	 esi, 8
  00bf3	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00bf6	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00bf9	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00bfc	8b c8		 mov	 ecx, eax
  00bfe	c1 e9 08	 shr	 ecx, 8
  00c01	0f b6 c9	 movzx	 ecx, cl
  00c04	89 45 d0	 mov	 DWORD PTR _here$[ebp], eax
  00c07	3b ce		 cmp	 ecx, esi
  00c09	77 c7		 ja	 SHORT $LL187@inflate
$LN562@inflate:

; 965  :                 }
; 966  :                 if (here.val < 16) {

  00c0b	8b c8		 mov	 ecx, eax
  00c0d	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00c10	89 4d cc	 mov	 DWORD PTR tv3020[ebp], ecx
  00c13	66 83 f9 10	 cmp	 cx, 16			; 00000010H
  00c17	73 2c		 jae	 SHORT $LN954@inflate

; 967  :                     DROPBITS(here.bits);
; 968  :                     state->lens[state->have++] = here.val;

  00c19	8b 7d cc	 mov	 edi, DWORD PTR tv3020[ebp]
  00c1c	c1 e8 08	 shr	 eax, 8
  00c1f	0f b6 c8	 movzx	 ecx, al
  00c22	d3 ea		 shr	 edx, cl
  00c24	2b f1		 sub	 esi, ecx
  00c26	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00c29	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00c2c	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00c2f	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00c32	66 89 7c 41 74	 mov	 WORD PTR [ecx+eax*2+116], di
  00c37	ff 41 6c	 inc	 DWORD PTR [ecx+108]
  00c3a	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00c3d	89 45 cc	 mov	 DWORD PTR tv3041[ebp], eax

; 969  :                 }

  00c40	e9 74 01 00 00	 jmp	 $LN955@inflate
$LN954@inflate:

; 970  :                 else {
; 971  :                     if (here.val == 16) {

  00c45	75 77		 jne	 SHORT $LN435@inflate

; 972  :                         NEEDBITS(here.bits + 2);

  00c47	8b c8		 mov	 ecx, eax
  00c49	c1 e9 08	 shr	 ecx, 8
  00c4c	0f b6 c9	 movzx	 ecx, cl
  00c4f	83 c1 02	 add	 ecx, 2
  00c52	89 4d cc	 mov	 DWORD PTR $T1[ebp], ecx
  00c55	3b f1		 cmp	 esi, ecx
  00c57	73 2c		 jae	 SHORT $LN196@inflate
  00c59	0f 1f 80 00 00
	00 00		 npad	 7
$LL199@inflate:
  00c60	85 db		 test	 ebx, ebx
  00c62	0f 84 50 f9 ff
	ff		 je	 $LN915@inflate
  00c68	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  00c6b	8b ce		 mov	 ecx, esi
  00c6d	d3 e2		 shl	 edx, cl
  00c6f	4b		 dec	 ebx
  00c70	01 55 fc	 add	 DWORD PTR _hold$1$[ebp], edx
  00c73	47		 inc	 edi
  00c74	83 c6 08	 add	 esi, 8
  00c77	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00c7a	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00c7d	3b 75 cc	 cmp	 esi, DWORD PTR $T1[ebp]
  00c80	72 de		 jb	 SHORT $LL199@inflate
  00c82	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN196@inflate:

; 973  :                         DROPBITS(here.bits);

  00c85	0f b6 cc	 movzx	 ecx, ah
  00c88	d3 ea		 shr	 edx, cl
  00c8a	2b f1		 sub	 esi, ecx

; 974  :                         if (state->have == 0) {

  00c8c	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00c8f	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00c92	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00c95	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00c98	85 c0		 test	 eax, eax
  00c9a	0f 84 51 01 00
	00		 je	 $LN567@inflate

; 978  :                         }
; 979  :                         len = state->lens[state->have - 1];

  00ca0	0f b7 44 41 72	 movzx	 eax, WORD PTR [ecx+eax*2+114]
  00ca5	89 45 d0	 mov	 DWORD PTR _len$5$[ebp], eax

; 980  :                         copy = 3 + BITS(2);

  00ca8	8b c2		 mov	 eax, edx
  00caa	83 e0 03	 and	 eax, 3

; 981  :                         DROPBITS(2);

  00cad	c1 ea 02	 shr	 edx, 2
  00cb0	83 c0 03	 add	 eax, 3
  00cb3	83 ee 02	 sub	 esi, 2
  00cb6	89 45 d8	 mov	 DWORD PTR _copy$8$[ebp], eax

; 982  :                     }

  00cb9	e9 b1 00 00 00	 jmp	 $LN956@inflate
$LN435@inflate:

; 983  :                     else if (here.val == 17) {

  00cbe	66 83 7d d2 11	 cmp	 WORD PTR _here$[ebp+2], 17 ; 00000011H

; 984  :                         NEEDBITS(here.bits + 3);

  00cc3	0f b6 cc	 movzx	 ecx, ah
  00cc6	75 4a		 jne	 SHORT $LN226@inflate
  00cc8	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
  00ccb	89 4d cc	 mov	 DWORD PTR tv3018[ebp], ecx
  00cce	3b f0		 cmp	 esi, eax
  00cd0	73 29		 jae	 SHORT $LN210@inflate
$LL213@inflate:
  00cd2	85 db		 test	 ebx, ebx
  00cd4	0f 84 de f8 ff
	ff		 je	 $LN915@inflate
  00cda	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00cdd	8b ce		 mov	 ecx, esi
  00cdf	d3 e0		 shl	 eax, cl
  00ce1	4b		 dec	 ebx
  00ce2	8b 4d cc	 mov	 ecx, DWORD PTR tv3018[ebp]
  00ce5	03 d0		 add	 edx, eax
  00ce7	47		 inc	 edi
  00ce8	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00ceb	83 c6 08	 add	 esi, 8
  00cee	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00cf1	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00cf4	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
  00cf7	3b f0		 cmp	 esi, eax
  00cf9	72 d7		 jb	 SHORT $LL213@inflate
$LN210@inflate:

; 985  :                         DROPBITS(here.bits);

  00cfb	d3 ea		 shr	 edx, cl

; 986  :                         len = 0;
; 987  :                         copy = 3 + BITS(3);

  00cfd	8b c2		 mov	 eax, edx
  00cff	83 e0 07	 and	 eax, 7
  00d02	83 c0 03	 add	 eax, 3

; 988  :                         DROPBITS(3);

  00d05	c1 ea 03	 shr	 edx, 3
  00d08	89 45 d8	 mov	 DWORD PTR _copy$8$[ebp], eax
  00d0b	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 989  :                     }

  00d10	eb 4c		 jmp	 SHORT $LN957@inflate
$LN226@inflate:

; 990  :                     else {
; 991  :                         NEEDBITS(here.bits + 7);

  00d12	8d 41 07	 lea	 eax, DWORD PTR [ecx+7]
  00d15	89 4d cc	 mov	 DWORD PTR tv3017[ebp], ecx
  00d18	3b f0		 cmp	 esi, eax
  00d1a	73 2d		 jae	 SHORT $LN224@inflate
  00d1c	0f 1f 40 00	 npad	 4
$LL227@inflate:
  00d20	85 db		 test	 ebx, ebx
  00d22	0f 84 90 f8 ff
	ff		 je	 $LN915@inflate
  00d28	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00d2b	8b ce		 mov	 ecx, esi
  00d2d	d3 e0		 shl	 eax, cl
  00d2f	4b		 dec	 ebx
  00d30	8b 4d cc	 mov	 ecx, DWORD PTR tv3017[ebp]
  00d33	03 d0		 add	 edx, eax
  00d35	47		 inc	 edi
  00d36	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00d39	83 c6 08	 add	 esi, 8
  00d3c	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00d3f	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00d42	8d 41 07	 lea	 eax, DWORD PTR [ecx+7]
  00d45	3b f0		 cmp	 esi, eax
  00d47	72 d7		 jb	 SHORT $LL227@inflate
$LN224@inflate:

; 992  :                         DROPBITS(here.bits);

  00d49	d3 ea		 shr	 edx, cl

; 993  :                         len = 0;
; 994  :                         copy = 11 + BITS(7);

  00d4b	8b c2		 mov	 eax, edx
  00d4d	83 e0 7f	 and	 eax, 127		; 0000007fH
  00d50	83 c0 0b	 add	 eax, 11			; 0000000bH

; 995  :                         DROPBITS(7);

  00d53	c1 ea 07	 shr	 edx, 7
  00d56	89 45 d8	 mov	 DWORD PTR _copy$8$[ebp], eax
  00d59	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
$LN957@inflate:
  00d5e	2b c1		 sub	 eax, ecx
  00d60	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _len$5$[ebp], 0
  00d67	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00d6a	03 f0		 add	 esi, eax
  00d6c	8b 45 d8	 mov	 eax, DWORD PTR _copy$8$[ebp]
$LN956@inflate:

; 996  :                     }
; 997  :                     if (state->have + copy > state->nlen + state->ndist) {

  00d6f	8b 49 6c	 mov	 ecx, DWORD PTR [ecx+108]
  00d72	8b 7d f8	 mov	 edi, DWORD PTR _state$1$[ebp]
  00d75	03 c8		 add	 ecx, eax
  00d77	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00d7a	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00d7d	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00d80	8b 40 68	 mov	 eax, DWORD PTR [eax+104]
  00d83	03 47 64	 add	 eax, DWORD PTR [edi+100]
  00d86	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  00d89	3b c8		 cmp	 ecx, eax
  00d8b	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00d8e	77 61		 ja	 SHORT $LN567@inflate
  00d90	8b 5d d8	 mov	 ebx, DWORD PTR _copy$8$[ebp]
  00d93	8b 7d d0	 mov	 edi, DWORD PTR _len$5$[ebp]
  00d96	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL238@inflate:

; 998  :                         strm->msg = (char *)"invalid bit length repeat";
; 999  :                         state->mode = BAD;
; 1000 :                         break;
; 1001 :                     }
; 1002 :                     while (copy--)
; 1003 :                         state->lens[state->have++] = (unsigned short)len;

  00da0	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00da3	66 89 7c 41 74	 mov	 WORD PTR [ecx+eax*2+116], di
  00da8	ff 41 6c	 inc	 DWORD PTR [ecx+108]
  00dab	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00dae	89 45 cc	 mov	 DWORD PTR tv3041[ebp], eax
  00db1	83 eb 01	 sub	 ebx, 1
  00db4	75 ea		 jne	 SHORT $LL238@inflate
  00db6	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN955@inflate:

; 959  :         case CODELENS:
; 960  :             while (state->have < state->nlen + state->ndist) {

  00db9	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00dbc	03 41 64	 add	 eax, DWORD PTR [ecx+100]
  00dbf	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  00dc2	39 45 cc	 cmp	 DWORD PTR tv3041[ebp], eax
  00dc5	0f 82 d5 fd ff
	ff		 jb	 $LL185@inflate
$LN186@inflate:

; 1004 :                 }
; 1005 :             }
; 1006 : 
; 1007 :             /* handle error breaks in while */
; 1008 :             if (state->mode == BAD) break;

  00dcb	81 79 04 51 3f
	00 00		 cmp	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  00dd2	0f 84 90 07 00
	00		 je	 $LN8@inflate

; 1009 : 
; 1010 :             /* check for end-of-block code (better have one) */
; 1011 :             if (state->lens[256] == 0) {

  00dd8	66 83 b9 74 02
	00 00 00	 cmp	 WORD PTR [ecx+628], 0
  00de0	75 1e		 jne	 SHORT $LN445@inflate

; 1012 :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00de2	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00de5	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@

; 1013 :                 state->mode = BAD;
; 1014 :                 break;

  00dec	e9 70 07 00 00	 jmp	 $LN953@inflate
$LN567@inflate:

; 975  :                             strm->msg = (char *)"invalid bit length repeat";

  00df1	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00df4	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@

; 976  :                             state->mode = BAD;
; 977  :                             break;

  00dfb	e9 61 07 00 00	 jmp	 $LN953@inflate
$LN445@inflate:

; 1015 :             }
; 1016 : 
; 1017 :             /* build code tables -- note: do not change the lenbits or distbits
; 1018 :                values here (9 and 6) without reading the comments in inftrees.h
; 1019 :                concerning the ENOUGH constants, which depend on those values */
; 1020 :             state->next = state->codes;

  00e00	8d 51 70	 lea	 edx, DWORD PTR [ecx+112]

; 1021 :             state->lencode = (const code FAR *)(state->next);
; 1022 :             state->lenbits = 9;

  00e03	c7 41 58 09 00
	00 00		 mov	 DWORD PTR [ecx+88], 9
  00e0a	8d 81 34 05 00
	00		 lea	 eax, DWORD PTR [ecx+1332]
  00e10	89 55 cc	 mov	 DWORD PTR tv3036[ebp], edx

; 1023 :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),

  00e13	8d b9 f4 02 00
	00		 lea	 edi, DWORD PTR [ecx+756]
  00e19	89 02		 mov	 DWORD PTR [edx], eax
  00e1b	89 41 50	 mov	 DWORD PTR [ecx+80], eax
  00e1e	8d 41 58	 lea	 eax, DWORD PTR [ecx+88]
  00e21	57		 push	 edi
  00e22	50		 push	 eax
  00e23	52		 push	 edx
  00e24	ff 71 64	 push	 DWORD PTR [ecx+100]
  00e27	8d 51 74	 lea	 edx, DWORD PTR [ecx+116]
  00e2a	89 7d d0	 mov	 DWORD PTR tv3030[ebp], edi
  00e2d	b9 01 00 00 00	 mov	 ecx, 1
  00e32	e8 00 00 00 00	 call	 _inflate_table

; 1024 :                                 &(state->lenbits), state->work);
; 1025 :             if (ret) {

  00e37	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  00e3a	83 c4 10	 add	 esp, 16			; 00000010H

; 1026 :                 strm->msg = (char *)"invalid literal/lengths set";
; 1027 :                 state->mode = BAD;

  00e3d	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00e40	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax
  00e43	85 c0		 test	 eax, eax
  00e45	74 12		 je	 SHORT $LN446@inflate

; 1028 :                 break;

  00e47	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00e4a	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00e4d	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
  00e54	e9 08 07 00 00	 jmp	 $LN953@inflate
$LN446@inflate:

; 1029 :             }
; 1030 :             state->distcode = (const code FAR *)(state->next);

  00e59	8b 55 cc	 mov	 edx, DWORD PTR tv3036[ebp]

; 1031 :             state->distbits = 6;
; 1032 :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,

  00e5c	ff 75 d0	 push	 DWORD PTR tv3030[ebp]
  00e5f	c7 41 5c 06 00
	00 00		 mov	 DWORD PTR [ecx+92], 6
  00e66	8b 02		 mov	 eax, DWORD PTR [edx]
  00e68	89 41 54	 mov	 DWORD PTR [ecx+84], eax
  00e6b	8d 41 5c	 lea	 eax, DWORD PTR [ecx+92]
  00e6e	50		 push	 eax
  00e6f	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00e72	52		 push	 edx
  00e73	ff 71 68	 push	 DWORD PTR [ecx+104]
  00e76	83 c1 74	 add	 ecx, 116		; 00000074H
  00e79	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00e7c	b9 02 00 00 00	 mov	 ecx, 2
  00e81	e8 00 00 00 00	 call	 _inflate_table

; 1033 :                             &(state->next), &(state->distbits), state->work);
; 1034 :             if (ret) {
; 1035 :                 strm->msg = (char *)"invalid distances set";
; 1036 :                 state->mode = BAD;

  00e86	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00e89	83 c4 10	 add	 esp, 16			; 00000010H
  00e8c	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax
  00e8f	85 c0		 test	 eax, eax
  00e91	74 12		 je	 SHORT $LN447@inflate

; 1037 :                 break;

  00e93	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00e96	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00e99	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@
  00ea0	e9 bc 06 00 00	 jmp	 $LN953@inflate
$LN447@inflate:

; 1038 :             }
; 1039 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1040 :             state->mode = LEN_;
; 1041 :             if (flush == Z_TREES) goto inf_leave;

  00ea5	8b 55 0c	 mov	 edx, DWORD PTR _flush$[ebp]
  00ea8	c7 41 04 47 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16199 ; 00003f47H
  00eaf	83 fa 06	 cmp	 edx, 6
  00eb2	0f 84 1e 07 00
	00		 je	 $LN891@inflate
  00eb8	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN448@inflate:

; 1042 :         case LEN_:
; 1043 :             state->mode = LEN;

  00ebb	c7 41 04 48 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16200 ; 00003f48H
$LN450@inflate:

; 1044 :         case LEN:
; 1045 :             if (have >= 6 && left >= 258) {

  00ec2	83 fb 06	 cmp	 ebx, 6
  00ec5	72 75		 jb	 SHORT $LN451@inflate
  00ec7	81 7d e8 02 01
	00 00		 cmp	 DWORD PTR _left$1$[ebp], 258 ; 00000102H
  00ece	72 6c		 jb	 SHORT $LN451@inflate

; 1046 :                 RESTORE();

  00ed0	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00ed3	8b 7d e0	 mov	 edi, DWORD PTR _put$1$[ebp]
  00ed6	89 78 0c	 mov	 DWORD PTR [eax+12], edi
  00ed9	8b 7d e8	 mov	 edi, DWORD PTR _left$1$[ebp]
  00edc	89 78 10	 mov	 DWORD PTR [eax+16], edi
  00edf	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  00ee2	89 38		 mov	 DWORD PTR [eax], edi
  00ee4	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  00ee7	89 51 3c	 mov	 DWORD PTR [ecx+60], edx

; 1047 :                 inflate_fast(strm, out);

  00eea	8b 55 dc	 mov	 edx, DWORD PTR _out$1$[ebp]
  00eed	89 71 40	 mov	 DWORD PTR [ecx+64], esi
  00ef0	8b c8		 mov	 ecx, eax
  00ef2	e8 00 00 00 00	 call	 _inflate_fast

; 1048 :                 LOAD();

  00ef7	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00efa	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00efd	8b 38		 mov	 edi, DWORD PTR [eax]
  00eff	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  00f02	89 4d e0	 mov	 DWORD PTR _put$1$[ebp], ecx
  00f05	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00f08	89 4d e8	 mov	 DWORD PTR _left$1$[ebp], ecx
  00f0b	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00f0e	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00f11	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx

; 1049 :                 if (state->mode == TYPE)

  00f14	81 79 04 3f 3f
	00 00		 cmp	 DWORD PTR [ecx+4], 16191 ; 00003f3fH
  00f1b	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00f1e	8b 71 40	 mov	 esi, DWORD PTR [ecx+64]
  00f21	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00f24	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00f27	0f 85 3b 06 00
	00		 jne	 $LN8@inflate

; 1050 :                     state->back = -1;

  00f2d	c7 81 c8 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7112], -1

; 1051 :                 break;

  00f37	e9 2c 06 00 00	 jmp	 $LN8@inflate
$LN451@inflate:

; 1052 :             }
; 1053 :             state->back = 0;

  00f3c	c7 81 c8 1b 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+7112], 0

; 1054 :             for (;;) {
; 1055 :                 here = state->lencode[BITS(state->lenbits)];

  00f46	b8 01 00 00 00	 mov	 eax, 1
  00f4b	8b 49 58	 mov	 ecx, DWORD PTR [ecx+88]
  00f4e	d3 e0		 shl	 eax, cl
  00f50	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00f53	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00f56	89 4d cc	 mov	 DWORD PTR tv2988[ebp], ecx
  00f59	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  00f5c	89 45 d8	 mov	 DWORD PTR tv3028[ebp], eax
  00f5f	8b c1		 mov	 eax, ecx
  00f61	8b 4d d8	 mov	 ecx, DWORD PTR tv3028[ebp]
  00f64	23 c2		 and	 eax, edx
  00f66	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 1056 :                 if ((unsigned)(here.bits) <= bits) break;

  00f69	8b c8		 mov	 ecx, eax
  00f6b	c1 e9 08	 shr	 ecx, 8
  00f6e	0f b6 c9	 movzx	 ecx, cl
  00f71	3b ce		 cmp	 ecx, esi
  00f73	76 36		 jbe	 SHORT $LN569@inflate
$LL246@inflate:

; 1057 :                 PULLBYTE();

  00f75	85 db		 test	 ebx, ebx
  00f77	0f 84 3b f6 ff
	ff		 je	 $LN915@inflate
  00f7d	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00f80	8b ce		 mov	 ecx, esi
  00f82	d3 e0		 shl	 eax, cl
  00f84	4b		 dec	 ebx
  00f85	8b 4d d8	 mov	 ecx, DWORD PTR tv3028[ebp]
  00f88	03 d0		 add	 edx, eax
  00f8a	8b 45 cc	 mov	 eax, DWORD PTR tv2988[ebp]
  00f8d	47		 inc	 edi
  00f8e	23 c2		 and	 eax, edx
  00f90	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00f93	83 c6 08	 add	 esi, 8
  00f96	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00f99	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00f9c	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00f9f	8b c8		 mov	 ecx, eax
  00fa1	c1 e9 08	 shr	 ecx, 8
  00fa4	0f b6 c9	 movzx	 ecx, cl
  00fa7	3b ce		 cmp	 ecx, esi
  00fa9	77 ca		 ja	 SHORT $LL246@inflate
$LN569@inflate:

; 1058 :             }
; 1059 :             if (here.op && (here.op & 0xf0) == 0) {

  00fab	84 c0		 test	 al, al
  00fad	0f 84 b7 00 00
	00		 je	 $LN263@inflate
  00fb3	a8 f0		 test	 al, 240			; 000000f0H
  00fb5	0f 85 af 00 00
	00		 jne	 $LN263@inflate

; 1060 :                 last = here;
; 1061 :                 for (;;) {
; 1062 :                     here = state->lencode[last.val +

  00fbb	8b c8		 mov	 ecx, eax
  00fbd	bb 01 00 00 00	 mov	 ebx, 1
  00fc2	c1 e9 08	 shr	 ecx, 8
  00fc5	8b d0		 mov	 edx, eax
  00fc7	0f b6 f9	 movzx	 edi, cl
  00fca	89 4d cc	 mov	 DWORD PTR tv3027[ebp], ecx
  00fcd	0f b6 c8	 movzx	 ecx, al
  00fd0	03 cf		 add	 ecx, edi
  00fd2	c1 e8 10	 shr	 eax, 16			; 00000010H
  00fd5	d3 e3		 shl	 ebx, cl
  00fd7	8b cf		 mov	 ecx, edi
  00fd9	4b		 dec	 ebx
  00fda	89 55 d0	 mov	 DWORD PTR _last$[ebp], edx
  00fdd	23 5d fc	 and	 ebx, DWORD PTR _hold$1$[ebp]
  00fe0	d3 eb		 shr	 ebx, cl
  00fe2	8b 4d d8	 mov	 ecx, DWORD PTR tv3028[ebp]
  00fe5	03 d8		 add	 ebx, eax
  00fe7	8b 04 99	 mov	 eax, DWORD PTR [ecx+ebx*4]

; 1063 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1064 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00fea	8b c8		 mov	 ecx, eax
  00fec	c1 e9 08	 shr	 ecx, 8
  00fef	0f b6 f9	 movzx	 edi, cl
  00ff2	8b 4d cc	 mov	 ecx, DWORD PTR tv3027[ebp]
  00ff5	0f b6 c9	 movzx	 ecx, cl
  00ff8	03 f9		 add	 edi, ecx
  00ffa	3b fe		 cmp	 edi, esi
  00ffc	76 56		 jbe	 SHORT $LN260@inflate
  00ffe	66 90		 npad	 2
$LL252@inflate:

; 1065 :                     PULLBYTE();

  01000	8b 45 f4	 mov	 eax, DWORD PTR _have$1$[ebp]
  01003	85 c0		 test	 eax, eax
  01005	0f 84 b0 f5 ff
	ff		 je	 $LN921@inflate
  0100b	8b 5d f0	 mov	 ebx, DWORD PTR _next$1$[ebp]
  0100e	48		 dec	 eax
  0100f	89 45 f4	 mov	 DWORD PTR _have$1$[ebp], eax
  01012	8b ce		 mov	 ecx, esi
  01014	bf 01 00 00 00	 mov	 edi, 1
  01019	83 c6 08	 add	 esi, 8
  0101c	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  0101f	43		 inc	 ebx
  01020	d3 e0		 shl	 eax, cl
  01022	01 45 fc	 add	 DWORD PTR _hold$1$[ebp], eax
  01025	0f b7 45 d2	 movzx	 eax, WORD PTR _last$[ebp+2]
  01029	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  0102c	0f b6 de	 movzx	 ebx, dh
  0102f	0f b6 ca	 movzx	 ecx, dl
  01032	03 cb		 add	 ecx, ebx
  01034	d3 e7		 shl	 edi, cl
  01036	8b cb		 mov	 ecx, ebx
  01038	4f		 dec	 edi
  01039	23 7d fc	 and	 edi, DWORD PTR _hold$1$[ebp]
  0103c	d3 ef		 shr	 edi, cl
  0103e	03 f8		 add	 edi, eax
  01040	8b 45 d8	 mov	 eax, DWORD PTR tv3028[ebp]
  01043	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  01046	8b c8		 mov	 ecx, eax
  01048	c1 e9 08	 shr	 ecx, 8
  0104b	0f b6 c9	 movzx	 ecx, cl
  0104e	03 cb		 add	 ecx, ebx
  01050	3b ce		 cmp	 ecx, esi
  01052	77 ac		 ja	 SHORT $LL252@inflate
$LN260@inflate:

; 1066 :                 }
; 1067 :                 DROPBITS(last.bits);
; 1068 :                 state->back += last.bits;

  01054	8b 5d f8	 mov	 ebx, DWORD PTR _state$1$[ebp]
  01057	0f b6 ce	 movzx	 ecx, dh
  0105a	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  0105d	d3 ea		 shr	 edx, cl
  0105f	2b f1		 sub	 esi, ecx
  01061	89 8b c8 1b 00
	00		 mov	 DWORD PTR [ebx+7112], ecx
  01067	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN263@inflate:

; 1069 :             }
; 1070 :             DROPBITS(here.bits);
; 1071 :             state->back += here.bits;

  0106a	8b 7d f8	 mov	 edi, DWORD PTR _state$1$[ebp]
  0106d	8b c8		 mov	 ecx, eax
  0106f	c1 e9 08	 shr	 ecx, 8
  01072	0f b6 c9	 movzx	 ecx, cl
  01075	d3 ea		 shr	 edx, cl
  01077	2b f1		 sub	 esi, ecx
  01079	01 8f c8 1b 00
	00		 add	 DWORD PTR [edi+7112], ecx

; 1072 :             state->length = (unsigned)here.val;

  0107f	8b c8		 mov	 ecx, eax
  01081	c1 e9 10	 shr	 ecx, 16			; 00000010H
  01084	89 4f 44	 mov	 DWORD PTR [edi+68], ecx

; 1073 :             if ((int)(here.op) == 0) {

  01087	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]

; 1074 :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 1075 :                         "inflate:         literal '%c'\n" :
; 1076 :                         "inflate:         literal 0x%02x\n", here.val));
; 1077 :                 state->mode = LIT;

  0108a	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0108d	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  01090	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  01093	84 c0		 test	 al, al
  01095	75 0c		 jne	 SHORT $LN458@inflate
  01097	c7 41 04 4d 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16205 ; 00003f4dH

; 1078 :                 break;

  0109e	e9 c5 04 00 00	 jmp	 $LN8@inflate
$LN458@inflate:

; 1079 :             }
; 1080 :             if (here.op & 32) {

  010a3	a8 20		 test	 al, 32			; 00000020H
  010a5	74 16		 je	 SHORT $LN459@inflate

; 1081 :                 Tracevv((stderr, "inflate:         end of block\n"));
; 1082 :                 state->back = -1;

  010a7	c7 81 c8 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7112], -1
$LN419@inflate:

; 1083 :                 state->mode = TYPE;

  010b1	c7 41 04 3f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16191 ; 00003f3fH

; 1084 :                 break;

  010b8	e9 ab 04 00 00	 jmp	 $LN8@inflate
$LN459@inflate:

; 1085 :             }
; 1086 :             if (here.op & 64) {

  010bd	a8 40		 test	 al, 64			; 00000040H
  010bf	74 0f		 je	 SHORT $LN460@inflate

; 1087 :                 strm->msg = (char *)"invalid literal/length code";

  010c1	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  010c4	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@

; 1088 :                 state->mode = BAD;
; 1089 :                 break;

  010cb	e9 91 04 00 00	 jmp	 $LN953@inflate
$LN460@inflate:

; 1090 :             }
; 1091 :             state->extra = (unsigned)(here.op) & 15;

  010d0	0f b6 c0	 movzx	 eax, al
  010d3	83 e0 0f	 and	 eax, 15			; 0000000fH

; 1092 :             state->mode = LENEXT;

  010d6	c7 41 04 49 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16201 ; 00003f49H
  010dd	89 41 4c	 mov	 DWORD PTR [ecx+76], eax
$LN461@inflate:

; 1093 :         case LENEXT:
; 1094 :             if (state->extra) {

  010e0	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  010e3	89 45 d0	 mov	 DWORD PTR tv3005[ebp], eax
  010e6	85 c0		 test	 eax, eax
  010e8	74 52		 je	 SHORT $LN462@inflate

; 1095 :                 NEEDBITS(state->extra);

  010ea	3b f0		 cmp	 esi, eax
  010ec	73 26		 jae	 SHORT $LN264@inflate
  010ee	66 90		 npad	 2
$LL267@inflate:
  010f0	85 db		 test	 ebx, ebx
  010f2	0f 84 c0 f4 ff
	ff		 je	 $LN915@inflate
  010f8	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  010fb	8b ce		 mov	 ecx, esi
  010fd	d3 e0		 shl	 eax, cl
  010ff	4b		 dec	 ebx
  01100	03 d0		 add	 edx, eax
  01102	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  01105	47		 inc	 edi
  01106	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  01109	83 c6 08	 add	 esi, 8
  0110c	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0110f	3b 75 d0	 cmp	 esi, DWORD PTR tv3005[ebp]
  01112	72 dc		 jb	 SHORT $LL267@inflate
$LN264@inflate:

; 1096 :                 state->length += BITS(state->extra);

  01114	8b 4d d0	 mov	 ecx, DWORD PTR tv3005[ebp]
  01117	b8 01 00 00 00	 mov	 eax, 1
  0111c	d3 e0		 shl	 eax, cl
  0111e	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01121	48		 dec	 eax
  01122	23 c2		 and	 eax, edx
  01124	01 41 44	 add	 DWORD PTR [ecx+68], eax

; 1097 :                 DROPBITS(state->extra);

  01127	8b 45 d0	 mov	 eax, DWORD PTR tv3005[ebp]
  0112a	8b c8		 mov	 ecx, eax
  0112c	d3 ea		 shr	 edx, cl
  0112e	2b f0		 sub	 esi, eax

; 1098 :                 state->back += state->extra;

  01130	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01133	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  01136	01 81 c8 1b 00
	00		 add	 DWORD PTR [ecx+7112], eax
$LN462@inflate:

; 1099 :             }
; 1100 :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1101 :             state->was = state->length;

  0113c	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  0113f	89 81 cc 1b 00
	00		 mov	 DWORD PTR [ecx+7116], eax

; 1102 :             state->mode = DIST;

  01145	c7 41 04 4a 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16202 ; 00003f4aH
$LN464@inflate:

; 1103 :         case DIST:
; 1104 :             for (;;) {
; 1105 :                 here = state->distcode[BITS(state->distbits)];

  0114c	8b 49 5c	 mov	 ecx, DWORD PTR [ecx+92]
  0114f	b8 01 00 00 00	 mov	 eax, 1
  01154	d3 e0		 shl	 eax, cl
  01156	48		 dec	 eax
  01157	89 45 cc	 mov	 DWORD PTR tv2987[ebp], eax
  0115a	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  0115d	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  01160	8b 45 cc	 mov	 eax, DWORD PTR tv2987[ebp]
  01163	23 c2		 and	 eax, edx
  01165	89 4d d8	 mov	 DWORD PTR tv3003[ebp], ecx
  01168	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 1106 :                 if ((unsigned)(here.bits) <= bits) break;

  0116b	8b c8		 mov	 ecx, eax
  0116d	c1 e9 08	 shr	 ecx, 8
  01170	0f b6 c9	 movzx	 ecx, cl
  01173	3b ce		 cmp	 ecx, esi
  01175	76 36		 jbe	 SHORT $LN574@inflate
$LL275@inflate:

; 1107 :                 PULLBYTE();

  01177	85 db		 test	 ebx, ebx
  01179	0f 84 39 f4 ff
	ff		 je	 $LN915@inflate
  0117f	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  01182	8b ce		 mov	 ecx, esi
  01184	d3 e0		 shl	 eax, cl
  01186	4b		 dec	 ebx
  01187	8b 4d d8	 mov	 ecx, DWORD PTR tv3003[ebp]
  0118a	03 d0		 add	 edx, eax
  0118c	8b 45 cc	 mov	 eax, DWORD PTR tv2987[ebp]
  0118f	47		 inc	 edi
  01190	23 c2		 and	 eax, edx
  01192	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  01195	83 c6 08	 add	 esi, 8
  01198	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0119b	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0119e	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  011a1	8b c8		 mov	 ecx, eax
  011a3	c1 e9 08	 shr	 ecx, 8
  011a6	0f b6 c9	 movzx	 ecx, cl
  011a9	3b ce		 cmp	 ecx, esi
  011ab	77 ca		 ja	 SHORT $LL275@inflate
$LN574@inflate:

; 1108 :             }
; 1109 :             if ((here.op & 0xf0) == 0) {

  011ad	a8 f0		 test	 al, 240			; 000000f0H
  011af	0f 85 b4 00 00
	00		 jne	 $LN917@inflate

; 1110 :                 last = here;
; 1111 :                 for (;;) {
; 1112 :                     here = state->distcode[last.val +

  011b5	8b c8		 mov	 ecx, eax
  011b7	bb 01 00 00 00	 mov	 ebx, 1
  011bc	c1 e9 08	 shr	 ecx, 8
  011bf	8b d0		 mov	 edx, eax
  011c1	0f b6 f9	 movzx	 edi, cl
  011c4	89 4d cc	 mov	 DWORD PTR tv3026[ebp], ecx
  011c7	0f b6 c8	 movzx	 ecx, al
  011ca	03 cf		 add	 ecx, edi
  011cc	c1 e8 10	 shr	 eax, 16			; 00000010H
  011cf	d3 e3		 shl	 ebx, cl
  011d1	8b cf		 mov	 ecx, edi
  011d3	4b		 dec	 ebx
  011d4	89 55 d0	 mov	 DWORD PTR _last$[ebp], edx
  011d7	23 5d fc	 and	 ebx, DWORD PTR _hold$1$[ebp]
  011da	d3 eb		 shr	 ebx, cl
  011dc	8b 4d d8	 mov	 ecx, DWORD PTR tv3003[ebp]
  011df	03 d8		 add	 ebx, eax
  011e1	8b 04 99	 mov	 eax, DWORD PTR [ecx+ebx*4]

; 1113 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1114 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  011e4	8b c8		 mov	 ecx, eax
  011e6	c1 e9 08	 shr	 ecx, 8
  011e9	0f b6 f9	 movzx	 edi, cl
  011ec	8b 4d cc	 mov	 ecx, DWORD PTR tv3026[ebp]
  011ef	0f b6 c9	 movzx	 ecx, cl
  011f2	03 f9		 add	 edi, ecx
  011f4	3b fe		 cmp	 edi, esi
  011f6	76 5c		 jbe	 SHORT $LN289@inflate
  011f8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL281@inflate:

; 1115 :                     PULLBYTE();

  01200	8b 45 f4	 mov	 eax, DWORD PTR _have$1$[ebp]
  01203	85 c0		 test	 eax, eax
  01205	0f 84 b0 f3 ff
	ff		 je	 $LN921@inflate
  0120b	8b 5d f0	 mov	 ebx, DWORD PTR _next$1$[ebp]
  0120e	48		 dec	 eax
  0120f	89 45 f4	 mov	 DWORD PTR _have$1$[ebp], eax
  01212	8b ce		 mov	 ecx, esi
  01214	bf 01 00 00 00	 mov	 edi, 1
  01219	83 c6 08	 add	 esi, 8
  0121c	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  0121f	43		 inc	 ebx
  01220	d3 e0		 shl	 eax, cl
  01222	01 45 fc	 add	 DWORD PTR _hold$1$[ebp], eax
  01225	0f b7 45 d2	 movzx	 eax, WORD PTR _last$[ebp+2]
  01229	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  0122c	0f b6 de	 movzx	 ebx, dh
  0122f	0f b6 ca	 movzx	 ecx, dl
  01232	03 cb		 add	 ecx, ebx
  01234	d3 e7		 shl	 edi, cl
  01236	8b cb		 mov	 ecx, ebx
  01238	4f		 dec	 edi
  01239	23 7d fc	 and	 edi, DWORD PTR _hold$1$[ebp]
  0123c	d3 ef		 shr	 edi, cl
  0123e	03 f8		 add	 edi, eax
  01240	8b 45 d8	 mov	 eax, DWORD PTR tv3003[ebp]
  01243	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  01246	8b c8		 mov	 ecx, eax
  01248	c1 e9 08	 shr	 ecx, 8
  0124b	0f b6 c9	 movzx	 ecx, cl
  0124e	03 cb		 add	 ecx, ebx
  01250	3b ce		 cmp	 ecx, esi
  01252	77 ac		 ja	 SHORT $LL281@inflate
$LN289@inflate:

; 1116 :                 }
; 1117 :                 DROPBITS(last.bits);
; 1118 :                 state->back += last.bits;

  01254	8b 5d f8	 mov	 ebx, DWORD PTR _state$1$[ebp]
  01257	0f b6 ce	 movzx	 ecx, dh
  0125a	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  0125d	2b f1		 sub	 esi, ecx
  0125f	d3 ea		 shr	 edx, cl
  01261	01 8b c8 1b 00
	00		 add	 DWORD PTR [ebx+7112], ecx
  01267	eb 03		 jmp	 SHORT $LN292@inflate
$LN917@inflate:

; 1108 :             }
; 1109 :             if ((here.op & 0xf0) == 0) {

  01269	8b 5d f8	 mov	 ebx, DWORD PTR _state$1$[ebp]
$LN292@inflate:

; 1125 :                 break;

  0126c	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  0126f	8b c8		 mov	 ecx, eax
  01271	c1 e9 08	 shr	 ecx, 8
  01274	0f b6 c9	 movzx	 ecx, cl
  01277	01 8b c8 1b 00
	00		 add	 DWORD PTR [ebx+7112], ecx
  0127d	2b f1		 sub	 esi, ecx
  0127f	d3 ea		 shr	 edx, cl
  01281	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  01284	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  01287	a8 40		 test	 al, 64			; 00000040H
  01289	74 15		 je	 SHORT $LN470@inflate

; 1119 :             }
; 1120 :             DROPBITS(here.bits);
; 1121 :             state->back += here.bits;
; 1122 :             if (here.op & 64) {
; 1123 :                 strm->msg = (char *)"invalid distance code";
; 1124 :                 state->mode = BAD;

  0128b	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0128e	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 1125 :                 break;

  01291	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
  01294	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
  0129b	e9 c1 02 00 00	 jmp	 $LN953@inflate
$LN470@inflate:

; 1126 :             }
; 1127 :             state->offset = (unsigned)here.val;

  012a0	8b c8		 mov	 ecx, eax

; 1128 :             state->extra = (unsigned)(here.op) & 15;

  012a2	0f b6 c0	 movzx	 eax, al
  012a5	c1 e9 10	 shr	 ecx, 16			; 00000010H
  012a8	83 e0 0f	 and	 eax, 15			; 0000000fH
  012ab	89 4b 48	 mov	 DWORD PTR [ebx+72], ecx
  012ae	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  012b1	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
  012b4	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 1129 :             state->mode = DISTEXT;

  012b7	c7 41 04 4b 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16203 ; 00003f4bH
$LN471@inflate:

; 1130 :         case DISTEXT:
; 1131 :             if (state->extra) {

  012be	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  012c1	89 45 d0	 mov	 DWORD PTR tv3004[ebp], eax
  012c4	85 c0		 test	 eax, eax
  012c6	74 57		 je	 SHORT $LN472@inflate

; 1132 :                 NEEDBITS(state->extra);

  012c8	3b f0		 cmp	 esi, eax
  012ca	73 28		 jae	 SHORT $LN293@inflate
  012cc	0f 1f 40 00	 npad	 4
$LL296@inflate:
  012d0	85 db		 test	 ebx, ebx
  012d2	0f 84 e0 f2 ff
	ff		 je	 $LN915@inflate
  012d8	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  012db	8b ce		 mov	 ecx, esi
  012dd	d3 e0		 shl	 eax, cl
  012df	4b		 dec	 ebx
  012e0	03 d0		 add	 edx, eax
  012e2	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  012e5	47		 inc	 edi
  012e6	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  012e9	83 c6 08	 add	 esi, 8
  012ec	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  012ef	3b 75 d0	 cmp	 esi, DWORD PTR tv3004[ebp]
  012f2	72 dc		 jb	 SHORT $LL296@inflate
$LN293@inflate:

; 1133 :                 state->offset += BITS(state->extra);

  012f4	8b 4d d0	 mov	 ecx, DWORD PTR tv3004[ebp]
  012f7	b8 01 00 00 00	 mov	 eax, 1
  012fc	d3 e0		 shl	 eax, cl
  012fe	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01301	48		 dec	 eax
  01302	23 c2		 and	 eax, edx
  01304	01 41 48	 add	 DWORD PTR [ecx+72], eax

; 1134 :                 DROPBITS(state->extra);

  01307	8b 45 d0	 mov	 eax, DWORD PTR tv3004[ebp]
  0130a	8b c8		 mov	 ecx, eax
  0130c	d3 ea		 shr	 edx, cl
  0130e	2b f0		 sub	 esi, eax

; 1135 :                 state->back += state->extra;

  01310	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01313	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  01316	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  01319	01 81 c8 1b 00
	00		 add	 DWORD PTR [ecx+7112], eax
$LN472@inflate:

; 1136 :             }
; 1137 : #ifdef INFLATE_STRICT
; 1138 :             if (state->offset > state->dmax) {
; 1139 :                 strm->msg = (char *)"invalid distance too far back";
; 1140 :                 state->mode = BAD;
; 1141 :                 break;
; 1142 :             }
; 1143 : #endif
; 1144 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1145 :             state->mode = MATCH;

  0131f	c7 41 04 4c 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16204 ; 00003f4cH
$LN474@inflate:

; 1146 :         case MATCH:
; 1147 :             if (left == 0) goto inf_leave;

  01326	83 7d e8 00	 cmp	 DWORD PTR _left$1$[ebp], 0
  0132a	0f 84 88 f2 ff
	ff		 je	 $LN915@inflate

; 1148 :             copy = out - left;

  01330	8b 45 dc	 mov	 eax, DWORD PTR _out$1$[ebp]
  01333	2b 45 e8	 sub	 eax, DWORD PTR _left$1$[ebp]
  01336	89 45 cc	 mov	 DWORD PTR _copy$9$[ebp], eax

; 1149 :             if (state->offset > copy) {         /* copy from window */

  01339	8b 41 48	 mov	 eax, DWORD PTR [ecx+72]
  0133c	89 45 d8	 mov	 DWORD PTR _copy$10$[ebp], eax
  0133f	3b 45 cc	 cmp	 eax, DWORD PTR _copy$9$[ebp]
  01342	76 56		 jbe	 SHORT $LN476@inflate

; 1150 :                 copy = state->offset - copy;

  01344	2b 45 cc	 sub	 eax, DWORD PTR _copy$9$[ebp]
  01347	89 45 d8	 mov	 DWORD PTR _copy$10$[ebp], eax

; 1151 :                 if (copy > state->whave) {

  0134a	3b 41 30	 cmp	 eax, DWORD PTR [ecx+48]
  0134d	76 18		 jbe	 SHORT $LN479@inflate

; 1152 :                     if (state->sane) {

  0134f	83 b9 c4 1b 00
	00 00		 cmp	 DWORD PTR [ecx+7108], 0
  01356	74 0f		 je	 SHORT $LN479@inflate

; 1153 :                         strm->msg = (char *)"invalid distance too far back";

  01358	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0135b	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@

; 1154 :                         state->mode = BAD;
; 1155 :                         break;

  01362	e9 fa 01 00 00	 jmp	 $LN953@inflate
$LN479@inflate:

; 1156 :                     }
; 1157 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1158 :                     Trace((stderr, "inflate.c too far\n"));
; 1159 :                     copy -= state->whave;
; 1160 :                     if (copy > state->length) copy = state->length;
; 1161 :                     if (copy > left) copy = left;
; 1162 :                     left -= copy;
; 1163 :                     state->length -= copy;
; 1164 :                     do {
; 1165 :                         *put++ = 0;
; 1166 :                     } while (--copy);
; 1167 :                     if (state->length == 0) state->mode = LEN;
; 1168 :                     break;
; 1169 : #endif
; 1170 :                 }
; 1171 :                 if (copy > state->wnext) {

  01367	8b 79 34	 mov	 edi, DWORD PTR [ecx+52]
  0136a	3b c7		 cmp	 eax, edi
  0136c	76 10		 jbe	 SHORT $LN480@inflate

; 1172 :                     copy -= state->wnext;

  0136e	2b c7		 sub	 eax, edi
  01370	89 45 d8	 mov	 DWORD PTR _copy$10$[ebp], eax

; 1173 :                     from = state->window + (state->wsize - copy);

  01373	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  01376	03 41 2c	 add	 eax, DWORD PTR [ecx+44]
  01379	2b 45 d8	 sub	 eax, DWORD PTR _copy$10$[ebp]

; 1174 :                 }

  0137c	eb 08		 jmp	 SHORT $LN958@inflate
$LN480@inflate:

; 1175 :                 else
; 1176 :                     from = state->window + (state->wnext - copy);

  0137e	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  01381	2b 45 d8	 sub	 eax, DWORD PTR _copy$10$[ebp]
  01384	03 c7		 add	 eax, edi
$LN958@inflate:
  01386	89 45 cc	 mov	 DWORD PTR _from$1$[ebp], eax

; 1177 :                 if (copy > state->length) copy = state->length;

  01389	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  0138c	8b f8		 mov	 edi, eax
  0138e	39 7d d8	 cmp	 DWORD PTR _copy$10$[ebp], edi
  01391	89 45 d0	 mov	 DWORD PTR tv2955[ebp], eax
  01394	0f 46 45 d8	 cmovbe	 eax, DWORD PTR _copy$10$[ebp]

; 1178 :             }

  01398	eb 0f		 jmp	 SHORT $LN959@inflate
$LN476@inflate:

; 1179 :             else {                              /* copy from output */
; 1180 :                 from = put - state->offset;

  0139a	8b 45 e0	 mov	 eax, DWORD PTR _put$1$[ebp]
  0139d	2b 45 d8	 sub	 eax, DWORD PTR _copy$10$[ebp]
  013a0	89 45 cc	 mov	 DWORD PTR _from$1$[ebp], eax

; 1181 :                 copy = state->length;

  013a3	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  013a6	89 45 d0	 mov	 DWORD PTR tv2955[ebp], eax
$LN959@inflate:

; 1188 :             } while (--copy);

  013a9	8b 5d cc	 mov	 ebx, DWORD PTR _from$1$[ebp]
  013ac	8b f8		 mov	 edi, eax
  013ae	89 45 d8	 mov	 DWORD PTR _copy$12$[ebp], eax
  013b1	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
  013b4	3b f8		 cmp	 edi, eax
  013b6	0f 47 f8	 cmova	 edi, eax
  013b9	2b c7		 sub	 eax, edi
  013bb	89 45 e8	 mov	 DWORD PTR _left$1$[ebp], eax
  013be	8b 45 d0	 mov	 eax, DWORD PTR tv2955[ebp]
  013c1	2b c7		 sub	 eax, edi
  013c3	89 41 44	 mov	 DWORD PTR [ecx+68], eax
  013c6	8b 4d e0	 mov	 ecx, DWORD PTR _put$1$[ebp]
  013c9	2b d9		 sub	 ebx, ecx
  013cb	0f 1f 44 00 00	 npad	 5
$LL306@inflate:

; 1182 :             }
; 1183 :             if (copy > left) copy = left;
; 1184 :             left -= copy;
; 1185 :             state->length -= copy;
; 1186 :             do {
; 1187 :                 *put++ = *from++;

  013d0	8a 04 0b	 mov	 al, BYTE PTR [ebx+ecx]
  013d3	88 01		 mov	 BYTE PTR [ecx], al
  013d5	41		 inc	 ecx

; 1188 :             } while (--copy);

  013d6	83 ef 01	 sub	 edi, 1
  013d9	75 f5		 jne	 SHORT $LL306@inflate

; 1189 :             if (state->length == 0) state->mode = LEN;

  013db	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
  013de	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  013e1	89 4d e0	 mov	 DWORD PTR _put$1$[ebp], ecx
  013e4	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  013e7	83 79 44 00	 cmp	 DWORD PTR [ecx+68], 0
  013eb	0f 85 77 01 00
	00		 jne	 $LN8@inflate
  013f1	c7 41 04 48 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16200 ; 00003f48H

; 1190 :             break;

  013f8	e9 6b 01 00 00	 jmp	 $LN8@inflate
$LN485@inflate:

; 1191 :         case LIT:
; 1192 :             if (left == 0) goto inf_leave;

  013fd	83 7d e8 00	 cmp	 DWORD PTR _left$1$[ebp], 0
  01401	0f 84 b1 f1 ff
	ff		 je	 $LN915@inflate

; 1193 :             *put++ = (unsigned char)(state->length);

  01407	8b 7d e0	 mov	 edi, DWORD PTR _put$1$[ebp]
  0140a	8a 41 44	 mov	 al, BYTE PTR [ecx+68]
  0140d	ff 45 e0	 inc	 DWORD PTR _put$1$[ebp]

; 1194 :             left--;

  01410	ff 4d e8	 dec	 DWORD PTR _left$1$[ebp]
  01413	88 07		 mov	 BYTE PTR [edi], al

; 1195 :             state->mode = LEN;
; 1196 :             break;

  01415	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  01418	c7 41 04 48 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16200 ; 00003f48H
  0141f	e9 44 01 00 00	 jmp	 $LN8@inflate
$LN487@inflate:

; 1197 :         case CHECK:
; 1198 :             if (state->wrap) {

  01424	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  01428	0f 84 da 00 00
	00		 je	 $LN316@inflate

; 1199 :                 NEEDBITS(32);

  0142e	83 fe 20	 cmp	 esi, 32			; 00000020H
  01431	73 2a		 jae	 SHORT $LN307@inflate
$LL310@inflate:
  01433	85 db		 test	 ebx, ebx
  01435	0f 84 7d f1 ff
	ff		 je	 $LN915@inflate
  0143b	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0143e	8b ce		 mov	 ecx, esi
  01440	d3 e0		 shl	 eax, cl
  01442	83 c6 08	 add	 esi, 8
  01445	4b		 dec	 ebx
  01446	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  01449	03 d0		 add	 edx, eax
  0144b	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0144e	47		 inc	 edi
  0144f	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  01452	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  01455	83 fe 20	 cmp	 esi, 32			; 00000020H
  01458	72 d9		 jb	 SHORT $LL310@inflate
  0145a	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN307@inflate:

; 1200 :                 out -= left;

  0145d	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
  01460	29 45 dc	 sub	 DWORD PTR _out$1$[ebp], eax

; 1201 :                 strm->total_out += out;

  01463	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01466	8b 7d dc	 mov	 edi, DWORD PTR _out$1$[ebp]
  01469	01 78 14	 add	 DWORD PTR [eax+20], edi

; 1202 :                 state->total += out;

  0146c	8b c7		 mov	 eax, edi
  0146e	01 41 20	 add	 DWORD PTR [ecx+32], eax

; 1203 :                 if ((state->wrap & 4) && out)

  01471	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  01475	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  01478	74 33		 je	 SHORT $LN490@inflate
  0147a	85 c0		 test	 eax, eax
  0147c	74 2f		 je	 SHORT $LN490@inflate

; 1204 :                     strm->adler = state->check =

  0147e	50		 push	 eax
  0147f	8b 45 e0	 mov	 eax, DWORD PTR _put$1$[ebp]
  01482	2b 45 dc	 sub	 eax, DWORD PTR _out$1$[ebp]
  01485	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  01489	50		 push	 eax
  0148a	ff 71 1c	 push	 DWORD PTR [ecx+28]
  0148d	74 07		 je	 SHORT $LN511@inflate
  0148f	e8 00 00 00 00	 call	 _crc32
  01494	eb 05		 jmp	 SHORT $LN960@inflate
$LN511@inflate:
  01496	e8 00 00 00 00	 call	 _adler32
$LN960@inflate:
  0149b	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0149e	83 c4 0c	 add	 esp, 12			; 0000000cH
  014a1	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  014a4	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  014a7	89 42 30	 mov	 DWORD PTR [edx+48], eax
  014aa	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN490@inflate:

; 1205 :                         UPDATE(state->check, put - out, out);
; 1206 :                 out = left;
; 1207 :                 if ((state->wrap & 4) && (

  014ad	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  014b1	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
  014b4	89 45 dc	 mov	 DWORD PTR _out$1$[ebp], eax
  014b7	74 45		 je	 SHORT $LN317@inflate
  014b9	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  014bd	8b c2		 mov	 eax, edx
  014bf	75 2c		 jne	 SHORT $LN514@inflate
  014c1	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  014c6	89 45 d8	 mov	 DWORD PTR tv3120[ebp], eax
  014c9	8b c2		 mov	 eax, edx
  014cb	c1 e0 10	 shl	 eax, 16			; 00000010H
  014ce	01 45 d8	 add	 DWORD PTR tv3120[ebp], eax
  014d1	8b c2		 mov	 eax, edx
  014d3	c1 65 d8 08	 shl	 DWORD PTR tv3120[ebp], 8
  014d7	c1 e8 08	 shr	 eax, 8
  014da	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  014df	01 45 d8	 add	 DWORD PTR tv3120[ebp], eax
  014e2	8b c2		 mov	 eax, edx
  014e4	c1 e8 18	 shr	 eax, 24			; 00000018H
  014e7	01 45 d8	 add	 DWORD PTR tv3120[ebp], eax
  014ea	8b 45 d8	 mov	 eax, DWORD PTR tv3120[ebp]
$LN514@inflate:
  014ed	3b 41 1c	 cmp	 eax, DWORD PTR [ecx+28]
  014f0	74 0c		 je	 SHORT $LN317@inflate

; 1208 : #ifdef GUNZIP
; 1209 :                      state->flags ? hold :
; 1210 : #endif
; 1211 :                      ZSWAP32(hold)) != state->check) {
; 1212 :                     strm->msg = (char *)"incorrect data check";

  014f2	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  014f5	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@

; 1213 :                     state->mode = BAD;
; 1214 :                     break;

  014fc	eb 63		 jmp	 SHORT $LN953@inflate
$LN317@inflate:

; 1215 :                 }
; 1216 :                 INITBITS();

  014fe	33 d2		 xor	 edx, edx
  01500	33 f6		 xor	 esi, esi
  01502	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  01505	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN316@inflate:

; 1217 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1218 :             }
; 1219 : #ifdef GUNZIP
; 1220 :             state->mode = LENGTH;

  01508	c7 41 04 4f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16207 ; 00003f4fH
$LN492@inflate:

; 1221 :         case LENGTH:
; 1222 :             if (state->wrap && state->flags) {

  0150f	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  01513	0f 84 9e 00 00
	00		 je	 $LN327@inflate
  01519	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  0151d	0f 84 94 00 00
	00		 je	 $LN327@inflate

; 1223 :                 NEEDBITS(32);

  01523	83 fe 20	 cmp	 esi, 32			; 00000020H
  01526	73 2a		 jae	 SHORT $LN318@inflate
$LL321@inflate:
  01528	85 db		 test	 ebx, ebx
  0152a	0f 84 88 f0 ff
	ff		 je	 $LN915@inflate
  01530	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  01533	8b ce		 mov	 ecx, esi
  01535	d3 e0		 shl	 eax, cl
  01537	83 c6 08	 add	 esi, 8
  0153a	4b		 dec	 ebx
  0153b	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0153e	03 d0		 add	 edx, eax
  01540	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  01543	47		 inc	 edi
  01544	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  01547	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0154a	83 fe 20	 cmp	 esi, 32			; 00000020H
  0154d	72 d9		 jb	 SHORT $LL321@inflate
  0154f	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN318@inflate:

; 1224 :                 if (hold != (state->total & 0xffffffffUL)) {

  01552	3b 51 20	 cmp	 edx, DWORD PTR [ecx+32]
  01555	74 57		 je	 SHORT $LN328@inflate

; 1225 :                     strm->msg = (char *)"incorrect length check";

  01557	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0155a	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
$LN953@inflate:

; 1226 :                     state->mode = BAD;

  01561	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
$LN8@inflate:

; 655  :     for (;;)
; 656  :         switch (state->mode) {

  01568	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0156b	2d 34 3f 00 00	 sub	 eax, 16180		; 00003f34H
  01570	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  01573	0f 86 0d eb ff
	ff		 jbe	 $LL5@inflate
$LN499@inflate:
  01579	5f		 pop	 edi
  0157a	5e		 pop	 esi

; 1239 :             goto inf_leave;
; 1240 :         case MEM:
; 1241 :             return Z_MEM_ERROR;
; 1242 :         case SYNC:
; 1243 :         default:
; 1244 :             return Z_STREAM_ERROR;

  0157b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  01580	5b		 pop	 ebx

; 1273 :         ret = Z_BUF_ERROR;
; 1274 :     return ret;
; 1275 : }

  01581	8b e5		 mov	 esp, ebp
  01583	5d		 pop	 ebp
  01584	c3		 ret	 0
$LN586@inflate:

; 844  :                 RESTORE();

  01585	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01588	8b 4d e0	 mov	 ecx, DWORD PTR _put$1$[ebp]
  0158b	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0158e	8b 4d e8	 mov	 ecx, DWORD PTR _left$1$[ebp]
  01591	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  01594	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01597	89 38		 mov	 DWORD PTR [eax], edi
  01599	89 58 04	 mov	 DWORD PTR [eax+4], ebx

; 845  :                 return Z_NEED_DICT;

  0159c	b8 02 00 00 00	 mov	 eax, 2
  015a1	5f		 pop	 edi
  015a2	89 71 40	 mov	 DWORD PTR [ecx+64], esi
  015a5	5e		 pop	 esi
  015a6	89 51 3c	 mov	 DWORD PTR [ecx+60], edx
  015a9	5b		 pop	 ebx

; 1273 :         ret = Z_BUF_ERROR;
; 1274 :     return ret;
; 1275 : }

  015aa	8b e5		 mov	 esp, ebp
  015ac	5d		 pop	 ebp
  015ad	c3		 ret	 0
$LN328@inflate:

; 1227 :                     break;
; 1228 :                 }
; 1229 :                 INITBITS();

  015ae	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  015b5	33 f6		 xor	 esi, esi
$LN327@inflate:

; 1230 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1231 :             }
; 1232 : #endif
; 1233 :             state->mode = DONE;

  015b7	c7 41 04 50 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16208 ; 00003f50H
$LN496@inflate:

; 1234 :         case DONE:
; 1235 :             ret = Z_STREAM_END;

  015be	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _ret$1$[ebp], 1

; 1236 :             goto inf_leave;

  015c5	e9 ee ef ff ff	 jmp	 $LN915@inflate
$LN497@inflate:

; 1237 :         case BAD:
; 1238 :             ret = Z_DATA_ERROR;

  015ca	c7 45 d4 fd ff
	ff ff		 mov	 DWORD PTR _ret$1$[ebp], -3 ; fffffffdH

; 1223 :                 NEEDBITS(32);

  015d1	e9 e2 ef ff ff	 jmp	 $LN915@inflate
$LN891@inflate:

; 1038 :             }
; 1039 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1040 :             state->mode = LEN_;
; 1041 :             if (flush == Z_TREES) goto inf_leave;

  015d6	8b 45 f4	 mov	 eax, DWORD PTR _have$1$[ebp]
  015d9	e9 e0 ef ff ff	 jmp	 $inf_leave$965
$LN503@inflate:

; 1260 :         }
; 1261 :     in -= strm->avail_in;

  015de	8b 45 c8	 mov	 eax, DWORD PTR _in$1$[ebp]
  015e1	2b 47 04	 sub	 eax, DWORD PTR [edi+4]

; 1262 :     out -= strm->avail_out;

  015e4	2b 77 10	 sub	 esi, DWORD PTR [edi+16]

; 1263 :     strm->total_in += in;

  015e7	01 47 08	 add	 DWORD PTR [edi+8], eax

; 1264 :     strm->total_out += out;

  015ea	01 77 14	 add	 DWORD PTR [edi+20], esi

; 1265 :     state->total += out;

  015ed	01 73 20	 add	 DWORD PTR [ebx+32], esi

; 1266 :     if ((state->wrap & 4) && out)

  015f0	f6 43 0c 04	 test	 BYTE PTR [ebx+12], 4
  015f4	89 45 c8	 mov	 DWORD PTR _in$1$[ebp], eax
  015f7	89 75 dc	 mov	 DWORD PTR _out$1$[ebp], esi
  015fa	74 29		 je	 SHORT $LN504@inflate
  015fc	85 f6		 test	 esi, esi
  015fe	74 25		 je	 SHORT $LN504@inflate

; 1267 :         strm->adler = state->check =

  01600	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  01603	56		 push	 esi
  01604	2b c6		 sub	 eax, esi
  01606	83 7b 14 00	 cmp	 DWORD PTR [ebx+20], 0
  0160a	50		 push	 eax
  0160b	ff 73 1c	 push	 DWORD PTR [ebx+28]
  0160e	74 07		 je	 SHORT $LN515@inflate
  01610	e8 00 00 00 00	 call	 _crc32
  01615	eb 05		 jmp	 SHORT $LN961@inflate
$LN515@inflate:
  01617	e8 00 00 00 00	 call	 _adler32
$LN961@inflate:
  0161c	89 43 1c	 mov	 DWORD PTR [ebx+28], eax
  0161f	83 c4 0c	 add	 esp, 12			; 0000000cH
  01622	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN504@inflate:

; 1268 :             UPDATE(state->check, strm->next_out - out, out);
; 1269 :     strm->data_type = (int)state->bits + (state->last ? 64 : 0) +

  01625	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  01628	81 fa 47 3f 00
	00		 cmp	 edx, 16199		; 00003f47H
  0162e	74 0c		 je	 SHORT $LN517@inflate
  01630	81 fa 42 3f 00
	00		 cmp	 edx, 16194		; 00003f42H
  01636	74 04		 je	 SHORT $LN517@inflate
  01638	33 f6		 xor	 esi, esi
  0163a	eb 05		 jmp	 SHORT $LN518@inflate
$LN517@inflate:
  0163c	be 00 01 00 00	 mov	 esi, 256		; 00000100H
$LN518@inflate:
  01641	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  01644	f7 d9		 neg	 ecx
  01646	c7 45 cc 80 00
	00 00		 mov	 DWORD PTR tv2979[ebp], 128 ; 00000080H
  0164d	1b c9		 sbb	 ecx, ecx
  0164f	33 c0		 xor	 eax, eax
  01651	83 e1 40	 and	 ecx, 64			; 00000040H
  01654	81 fa 3f 3f 00
	00		 cmp	 edx, 16191		; 00003f3fH
  0165a	0f 44 45 cc	 cmove	 eax, DWORD PTR tv2979[ebp]
  0165e	03 ce		 add	 ecx, esi
  01660	03 c1		 add	 eax, ecx
  01662	03 43 40	 add	 eax, DWORD PTR [ebx+64]

; 1270 :                       (state->mode == TYPE ? 128 : 0) +
; 1271 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
; 1272 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  01665	83 7d c8 00	 cmp	 DWORD PTR _in$1$[ebp], 0
  01669	89 47 2c	 mov	 DWORD PTR [edi+44], eax
  0166c	75 06		 jne	 SHORT $LN507@inflate
  0166e	83 7d dc 00	 cmp	 DWORD PTR _out$1$[ebp], 0
  01672	74 06		 je	 SHORT $LN506@inflate
$LN507@inflate:
  01674	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  01678	75 14		 jne	 SHORT $LN919@inflate
$LN506@inflate:
  0167a	8b 45 d4	 mov	 eax, DWORD PTR _ret$1$[ebp]
  0167d	b9 fb ff ff ff	 mov	 ecx, -5			; fffffffbH
  01682	5f		 pop	 edi
  01683	85 c0		 test	 eax, eax
  01685	5e		 pop	 esi
  01686	0f 44 c1	 cmove	 eax, ecx
  01689	5b		 pop	 ebx

; 1273 :         ret = Z_BUF_ERROR;
; 1274 :     return ret;
; 1275 : }

  0168a	8b e5		 mov	 esp, ebp
  0168c	5d		 pop	 ebp
  0168d	c3		 ret	 0
$LN919@inflate:

; 1270 :                       (state->mode == TYPE ? 128 : 0) +
; 1271 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
; 1272 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  0168e	8b 45 d4	 mov	 eax, DWORD PTR _ret$1$[ebp]
  01691	5f		 pop	 edi
  01692	5e		 pop	 esi
  01693	5b		 pop	 ebx

; 1273 :         ret = Z_BUF_ERROR;
; 1274 :     return ret;
; 1275 : }

  01694	8b e5		 mov	 esp, ebp
  01696	5d		 pop	 ebp
  01697	c3		 ret	 0
$LN333@inflate:

; 646  :         (strm->next_in == Z_NULL && strm->avail_in != 0))
; 647  :         return Z_STREAM_ERROR;

  01698	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1273 :         ret = Z_BUF_ERROR;
; 1274 :     return ret;
; 1275 : }

  0169d	8b e5		 mov	 esp, ebp
  0169f	5d		 pop	 ebp
  016a0	c3		 ret	 0
  016a1	0f 1f 00	 npad	 3
$LN963@inflate:
  016a4	00 00 00 00	 DD	 $LN335@inflate
  016a8	00 00 00 00	 DD	 $LN32@inflate
  016ac	00 00 00 00	 DD	 $LN46@inflate
  016b0	00 00 00 00	 DD	 $LN60@inflate
  016b4	00 00 00 00	 DD	 $LN361@inflate
  016b8	00 00 00 00	 DD	 $LN368@inflate
  016bc	00 00 00 00	 DD	 $LN375@inflate
  016c0	00 00 00 00	 DD	 $LN384@inflate
  016c4	00 00 00 00	 DD	 $LN393@inflate
  016c8	00 00 00 00	 DD	 $LN105@inflate
  016cc	00 00 00 00	 DD	 $LN400@inflate
  016d0	00 00 00 00	 DD	 $LN402@inflate
  016d4	00 00 00 00	 DD	 $LN403@inflate
  016d8	00 00 00 00	 DD	 $LN141@inflate
  016dc	00 00 00 00	 DD	 $LN416@inflate
  016e0	00 00 00 00	 DD	 $LN418@inflate
  016e4	00 00 00 00	 DD	 $LN155@inflate
  016e8	00 00 00 00	 DD	 $LN532@inflate
  016ec	00 00 00 00	 DD	 $LN535@inflate
  016f0	00 00 00 00	 DD	 $LN448@inflate
  016f4	00 00 00 00	 DD	 $LN450@inflate
  016f8	00 00 00 00	 DD	 $LN461@inflate
  016fc	00 00 00 00	 DD	 $LN464@inflate
  01700	00 00 00 00	 DD	 $LN471@inflate
  01704	00 00 00 00	 DD	 $LN474@inflate
  01708	00 00 00 00	 DD	 $LN485@inflate
  0170c	00 00 00 00	 DD	 $LN487@inflate
  01710	00 00 00 00	 DD	 $LN492@inflate
  01714	00 00 00 00	 DD	 $LN496@inflate
  01718	00 00 00 00	 DD	 $LN497@inflate
  0171c	00 00 00 00	 DD	 $LN498@inflate
$LN964@inflate:
  01720	00 00 00 00	 DD	 $LN408@inflate
  01724	00 00 00 00	 DD	 $LN409@inflate
  01728	00 00 00 00	 DD	 $LN411@inflate
  0172c	00 00 00 00	 DD	 $LN412@inflate
_inflate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\inflate.c
;	COMDAT _inflateEnd
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateEnd PROC					; COMDAT

; 1279 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1280 :     struct inflate_state FAR *state;
; 1281 :     if (inflateStateCheck(strm))

  00004	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 _inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 08		 je	 SHORT $LN2@inflateEnd

; 1282 :         return Z_STREAM_ERROR;

  00012	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1289 : }

  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
$LN2@inflateEnd:

; 1283 :     state = (struct inflate_state FAR *)strm->state;

  0001a	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]

; 1284 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  0001d	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  00020	85 c0		 test	 eax, eax
  00022	74 0c		 je	 SHORT $LN3@inflateEnd
  00024	50		 push	 eax
  00025	ff 76 28	 push	 DWORD PTR [esi+40]
  00028	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0002b	ff d0		 call	 eax
  0002d	83 c4 08	 add	 esp, 8
$LN3@inflateEnd:

; 1285 :     ZFREE(strm, strm->state);

  00030	ff 76 1c	 push	 DWORD PTR [esi+28]
  00033	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00036	ff 76 28	 push	 DWORD PTR [esi+40]
  00039	ff d0		 call	 eax
  0003b	83 c4 08	 add	 esp, 8

; 1286 :     strm->state = Z_NULL;

  0003e	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0

; 1287 :     Tracev((stderr, "inflate: end\n"));
; 1288 :     return Z_OK;

  00045	33 c0		 xor	 eax, eax

; 1289 : }

  00047	5e		 pop	 esi
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
_inflateEnd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\inflate.c
;	COMDAT _inflateStateCheck
_TEXT	SEGMENT
_inflateStateCheck PROC					; COMDAT
; _strm$ = ecx

; 108  :     struct inflate_state FAR *state;
; 109  :     if (strm == Z_NULL ||
; 110  :         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)

  00000	85 c9		 test	 ecx, ecx
  00002	74 27		 je	 SHORT $LN3@inflateSta
  00004	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  00008	74 21		 je	 SHORT $LN3@inflateSta
  0000a	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  0000e	74 1b		 je	 SHORT $LN3@inflateSta

; 112  :     state = (struct inflate_state FAR *)strm->state;

  00010	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 113  :     if (state == Z_NULL || state->strm != strm ||
; 114  :         state->mode < HEAD || state->mode > SYNC)

  00013	85 c0		 test	 eax, eax
  00015	74 14		 je	 SHORT $LN3@inflateSta
  00017	39 08		 cmp	 DWORD PTR [eax], ecx
  00019	75 10		 jne	 SHORT $LN3@inflateSta
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	2d 34 3f 00 00	 sub	 eax, 16180		; 00003f34H
  00023	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00026	77 03		 ja	 SHORT $LN3@inflateSta

; 115  :         return 1;
; 116  :     return 0;

  00028	33 c0		 xor	 eax, eax

; 117  : }

  0002a	c3		 ret	 0
$LN3@inflateSta:

; 111  :         return 1;

  0002b	b8 01 00 00 00	 mov	 eax, 1

; 117  : }

  00030	c3		 ret	 0
_inflateStateCheck ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\inflate.c
;	COMDAT _inflateResetKeep
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateResetKeep PROC					; COMDAT

; 121  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 122  :     struct inflate_state FAR *state;
; 123  : 
; 124  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	8b ca		 mov	 ecx, edx
  00008	e8 00 00 00 00	 call	 _inflateStateCheck
  0000d	85 c0		 test	 eax, eax
  0000f	74 07		 je	 SHORT $LN2@inflateRes
  00011	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 142  : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
$LN2@inflateRes:

; 125  :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]

; 126  :     strm->total_in = strm->total_out = state->total = 0;

  0001b	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
  00022	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0
  00029	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 127  :     strm->msg = Z_NULL;

  00030	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 128  :     if (state->wrap)        /* to support ill-conceived Java test suite */

  00037	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0003a	85 c0		 test	 eax, eax
  0003c	74 06		 je	 SHORT $LN3@inflateRes

; 129  :         strm->adler = state->wrap & 1;

  0003e	83 e0 01	 and	 eax, 1
  00041	89 42 30	 mov	 DWORD PTR [edx+48], eax
$LN3@inflateRes:

; 130  :     state->mode = HEAD;
; 131  :     state->last = 0;
; 132  :     state->havedict = 0;
; 133  :     state->dmax = 32768U;
; 134  :     state->head = Z_NULL;
; 135  :     state->hold = 0;
; 136  :     state->bits = 0;
; 137  :     state->lencode = state->distcode = state->next = state->codes;

  00044	8d 81 34 05 00
	00		 lea	 eax, DWORD PTR [ecx+1332]
  0004a	c7 41 04 34 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16180 ; 00003f34H
  00051	89 41 70	 mov	 DWORD PTR [ecx+112], eax
  00054	89 41 54	 mov	 DWORD PTR [ecx+84], eax
  00057	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 138  :     state->sane = 1;
; 139  :     state->back = -1;
; 140  :     Tracev((stderr, "inflate: reset\n"));
; 141  :     return Z_OK;

  0005a	33 c0		 xor	 eax, eax
  0005c	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00063	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0006a	c7 41 18 00 80
	00 00		 mov	 DWORD PTR [ecx+24], 32768 ; 00008000H
  00071	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0
  00078	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0
  0007f	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0
  00086	c7 81 c4 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+7108], 1
  00090	c7 81 c8 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7112], -1

; 142  : }

  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
_inflateResetKeep ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\inflate.c
;	COMDAT _inflateReset2
_TEXT	SEGMENT
_state$1$ = -4						; size = 4
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_inflateReset2 PROC					; COMDAT

; 160  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 161  :     int wrap;
; 162  :     struct inflate_state FAR *state;
; 163  : 
; 164  :     /* get the state */
; 165  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _strm$[ebp]
  00008	8b cb		 mov	 ecx, ebx
  0000a	e8 00 00 00 00	 call	 _inflateStateCheck
  0000f	85 c0		 test	 eax, eax
  00011	74 0a		 je	 SHORT $LN2@inflateRes
  00013	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 193  : }

  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
$LN2@inflateRes:

; 166  :     state = (struct inflate_state FAR *)strm->state;

  0001d	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  00020	56		 push	 esi

; 167  : 
; 168  :     /* extract wrap request from windowBits parameter */
; 169  :     if (windowBits < 0) {

  00021	8b 75 0c	 mov	 esi, DWORD PTR _windowBits$[ebp]
  00024	89 45 fc	 mov	 DWORD PTR _state$1$[ebp], eax
  00027	57		 push	 edi
  00028	85 f6		 test	 esi, esi
  0002a	79 06		 jns	 SHORT $LN3@inflateRes

; 170  :         wrap = 0;

  0002c	33 ff		 xor	 edi, edi

; 171  :         windowBits = -windowBits;

  0002e	f7 de		 neg	 esi

; 172  :     }

  00030	eb 10		 jmp	 SHORT $LN5@inflateRes
$LN3@inflateRes:

; 173  :     else {
; 174  :         wrap = (windowBits >> 4) + 5;

  00032	8b fe		 mov	 edi, esi
  00034	c1 ff 04	 sar	 edi, 4
  00037	83 c7 05	 add	 edi, 5

; 175  : #ifdef GUNZIP
; 176  :         if (windowBits < 48)

  0003a	83 fe 30	 cmp	 esi, 48			; 00000030H
  0003d	7d 03		 jge	 SHORT $LN5@inflateRes

; 177  :             windowBits &= 15;

  0003f	83 e6 0f	 and	 esi, 15			; 0000000fH
$LN5@inflateRes:

; 178  : #endif
; 179  :     }
; 180  : 
; 181  :     /* set number of window bits, free window if different */
; 182  :     if (windowBits && (windowBits < 8 || windowBits > 15))

  00042	85 f6		 test	 esi, esi
  00044	74 16		 je	 SHORT $LN6@inflateRes
  00046	83 fe 08	 cmp	 esi, 8
  00049	7c 05		 jl	 SHORT $LN7@inflateRes
  0004b	83 fe 0f	 cmp	 esi, 15			; 0000000fH
  0004e	7e 0c		 jle	 SHORT $LN6@inflateRes
$LN7@inflateRes:
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi

; 183  :         return Z_STREAM_ERROR;

  00052	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 193  : }

  00057	5b		 pop	 ebx
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
$LN6@inflateRes:

; 184  :     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {

  0005c	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0005f	85 c9		 test	 ecx, ecx
  00061	74 1b		 je	 SHORT $LN8@inflateRes
  00063	39 70 28	 cmp	 DWORD PTR [eax+40], esi
  00066	74 16		 je	 SHORT $LN8@inflateRes

; 185  :         ZFREE(strm, state->window);

  00068	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  0006b	51		 push	 ecx
  0006c	ff 73 28	 push	 DWORD PTR [ebx+40]
  0006f	ff d0		 call	 eax

; 186  :         state->window = Z_NULL;

  00071	8b 45 fc	 mov	 eax, DWORD PTR _state$1$[ebp]
  00074	83 c4 08	 add	 esp, 8
  00077	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0
$LN8@inflateRes:

; 187  :     }
; 188  : 
; 189  :     /* update state and reset the rest of it */
; 190  :     state->wrap = wrap;
; 191  :     state->wbits = (unsigned)windowBits;
; 192  :     return inflateReset(strm);

  0007e	53		 push	 ebx
  0007f	89 78 0c	 mov	 DWORD PTR [eax+12], edi
  00082	89 70 28	 mov	 DWORD PTR [eax+40], esi
  00085	e8 00 00 00 00	 call	 _inflateReset
  0008a	83 c4 04	 add	 esp, 4
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi

; 193  : }

  0008f	5b		 pop	 ebx
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
_inflateReset2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\inflate.c
;	COMDAT _inflateInit_
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_version$ = 12						; size = 4
_stream_size$ = 16					; size = 4
_inflateInit_ PROC					; COMDAT

; 243  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 244  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  00003	ff 75 10	 push	 DWORD PTR _stream_size$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR _version$[ebp]
  00009	6a 0f		 push	 15			; 0000000fH
  0000b	ff 75 08	 push	 DWORD PTR _strm$[ebp]
  0000e	e8 00 00 00 00	 call	 _inflateInit2_
  00013	83 c4 10	 add	 esp, 16			; 00000010H

; 245  : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
_inflateInit_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\inflate.c
;	COMDAT _inflatePrime
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_bits$ = 12						; size = 4
_value$ = 16						; size = 4
_inflatePrime PROC					; COMDAT

; 251  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 252  :     struct inflate_state FAR *state;
; 253  : 
; 254  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 07		 je	 SHORT $LN2@inflatePri
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 266  : }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
$LN2@inflatePri:

; 255  :     state = (struct inflate_state FAR *)strm->state;

  00016	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]

; 256  :     if (bits < 0) {

  00019	8b 4d 0c	 mov	 ecx, DWORD PTR _bits$[ebp]
  0001c	85 c9		 test	 ecx, ecx
  0001e	79 12		 jns	 SHORT $LN3@inflatePri

; 257  :         state->hold = 0;

  00020	c7 42 3c 00 00
	00 00		 mov	 DWORD PTR [edx+60], 0

; 258  :         state->bits = 0;
; 259  :         return Z_OK;

  00027	33 c0		 xor	 eax, eax
  00029	c7 42 40 00 00
	00 00		 mov	 DWORD PTR [edx+64], 0

; 266  : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN3@inflatePri:

; 260  :     }
; 261  :     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;

  00032	56		 push	 esi
  00033	57		 push	 edi
  00034	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00037	7f 26		 jg	 SHORT $LN5@inflatePri
  00039	8b 72 40	 mov	 esi, DWORD PTR [edx+64]
  0003c	8d 3c 0e	 lea	 edi, DWORD PTR [esi+ecx]
  0003f	83 ff 20	 cmp	 edi, 32			; 00000020H
  00042	77 1b		 ja	 SHORT $LN5@inflatePri

; 262  :     value &= (1L << bits) - 1;

  00044	b8 01 00 00 00	 mov	 eax, 1

; 263  :     state->hold += (unsigned)value << state->bits;
; 264  :     state->bits += (uInt)bits;

  00049	89 7a 40	 mov	 DWORD PTR [edx+64], edi
  0004c	d3 e0		 shl	 eax, cl
  0004e	8b ce		 mov	 ecx, esi
  00050	48		 dec	 eax
  00051	23 45 10	 and	 eax, DWORD PTR _value$[ebp]
  00054	d3 e0		 shl	 eax, cl
  00056	01 42 3c	 add	 DWORD PTR [edx+60], eax

; 265  :     return Z_OK;

  00059	33 c0		 xor	 eax, eax
  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi

; 266  : }

  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
$LN5@inflatePri:
  0005f	5f		 pop	 edi

; 260  :     }
; 261  :     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;

  00060	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00065	5e		 pop	 esi

; 266  : }

  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
_inflatePrime ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\inflate.c
;	COMDAT _fixedtables
_TEXT	SEGMENT
_fixedtables PROC					; COMDAT
; _state$ = ecx

; 281  : #ifdef BUILDFIXED
; 282  :     static int virgin = 1;
; 283  :     static code *lenfix, *distfix;
; 284  :     static code fixed[544];
; 285  : 
; 286  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 287  :     if (virgin) {
; 288  :         unsigned sym, bits;
; 289  :         static code *next;
; 290  : 
; 291  :         /* literal/length table */
; 292  :         sym = 0;
; 293  :         while (sym < 144) state->lens[sym++] = 8;
; 294  :         while (sym < 256) state->lens[sym++] = 9;
; 295  :         while (sym < 280) state->lens[sym++] = 7;
; 296  :         while (sym < 288) state->lens[sym++] = 8;
; 297  :         next = fixed;
; 298  :         lenfix = next;
; 299  :         bits = 9;
; 300  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 301  : 
; 302  :         /* distance table */
; 303  :         sym = 0;
; 304  :         while (sym < 32) state->lens[sym++] = 5;
; 305  :         distfix = next;
; 306  :         bits = 5;
; 307  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 308  : 
; 309  :         /* do this just once */
; 310  :         virgin = 0;
; 311  :     }
; 312  : #else /* !BUILDFIXED */
; 313  : #   include "inffixed.h"
; 314  : #endif /* BUILDFIXED */
; 315  :     state->lencode = lenfix;

  00000	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], OFFSET ?lenfix@?1??fixedtables@@9@9

; 316  :     state->lenbits = 9;

  00007	c7 41 58 09 00
	00 00		 mov	 DWORD PTR [ecx+88], 9

; 317  :     state->distcode = distfix;

  0000e	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], OFFSET ?distfix@?1??fixedtables@@9@9

; 318  :     state->distbits = 5;

  00015	c7 41 5c 05 00
	00 00		 mov	 DWORD PTR [ecx+92], 5

; 319  : }

  0001c	c3		 ret	 0
_fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\inflate.c
;	COMDAT _updatewindow
_TEXT	SEGMENT
_end$1$ = -4						; size = 4
_copy$ = 8						; size = 4
_updatewindow PROC					; COMDAT
; _strm$ = ecx
; _end$ = edx

; 400  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b c2		 mov	 eax, edx
  00006	8b d1		 mov	 edx, ecx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	89 45 fc	 mov	 DWORD PTR _end$1$[ebp], eax

; 401  :     struct inflate_state FAR *state;
; 402  :     unsigned dist;
; 403  : 
; 404  :     state = (struct inflate_state FAR *)strm->state;
; 405  : 
; 406  :     /* if it hasn't been done already, allocate space for the window */
; 407  :     if (state->window == Z_NULL) {

  0000d	bf 01 00 00 00	 mov	 edi, 1
  00012	8b 72 1c	 mov	 esi, DWORD PTR [edx+28]
  00015	83 7e 38 00	 cmp	 DWORD PTR [esi+56], 0
  00019	75 26		 jne	 SHORT $LN3@updatewind

; 408  :         state->window = (unsigned char FAR *)

  0001b	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0001e	8b c7		 mov	 eax, edi
  00020	d3 e0		 shl	 eax, cl
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	ff 72 28	 push	 DWORD PTR [edx+40]
  00027	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0002a	ff d0		 call	 eax
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002f	89 46 38	 mov	 DWORD PTR [esi+56], eax

; 409  :                         ZALLOC(strm, 1U << state->wbits,
; 410  :                                sizeof(unsigned char));
; 411  :         if (state->window == Z_NULL) return 1;

  00032	85 c0		 test	 eax, eax
  00034	75 08		 jne	 SHORT $LN13@updatewind
  00036	8b c7		 mov	 eax, edi

; 444  : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
$LN13@updatewind:

; 409  :                         ZALLOC(strm, 1U << state->wbits,
; 410  :                                sizeof(unsigned char));
; 411  :         if (state->window == Z_NULL) return 1;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _end$1$[ebp]
$LN3@updatewind:

; 412  :     }
; 413  : 
; 414  :     /* if window not in use yet, initialize */
; 415  :     if (state->wsize == 0) {

  00041	83 7e 2c 00	 cmp	 DWORD PTR [esi+44], 0
  00045	75 16		 jne	 SHORT $LN4@updatewind

; 416  :         state->wsize = 1U << state->wbits;

  00047	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0004a	d3 e7		 shl	 edi, cl
  0004c	89 7e 2c	 mov	 DWORD PTR [esi+44], edi

; 417  :         state->wnext = 0;

  0004f	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0

; 418  :         state->whave = 0;

  00056	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0
$LN4@updatewind:

; 419  :     }
; 420  : 
; 421  :     /* copy state->wsize or less output bytes into the circular window */
; 422  :     if (copy >= state->wsize) {

  0005d	8b 7e 2c	 mov	 edi, DWORD PTR [esi+44]
  00060	53		 push	 ebx
  00061	8b 5d 08	 mov	 ebx, DWORD PTR _copy$[ebp]
  00064	3b df		 cmp	 ebx, edi
  00066	72 25		 jb	 SHORT $LN5@updatewind

; 423  :         zmemcpy(state->window, end - state->wsize, state->wsize);

  00068	57		 push	 edi
  00069	2b c7		 sub	 eax, edi
  0006b	50		 push	 eax
  0006c	ff 76 38	 push	 DWORD PTR [esi+56]
  0006f	e8 00 00 00 00	 call	 _memcpy

; 424  :         state->wnext = 0;
; 425  :         state->whave = state->wsize;

  00074	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH

; 440  :             if (state->whave < state->wsize) state->whave += dist;

  0007a	89 46 30	 mov	 DWORD PTR [esi+48], eax

; 441  :         }
; 442  :     }
; 443  :     return 0;

  0007d	33 c0		 xor	 eax, eax
  0007f	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0
  00086	5b		 pop	 ebx

; 444  : }

  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
$LN5@updatewind:

; 426  :     }
; 427  :     else {
; 428  :         dist = state->wsize - state->wnext;

  0008d	2b 7e 34	 sub	 edi, DWORD PTR [esi+52]

; 429  :         if (dist > copy) dist = copy;

  00090	3b fb		 cmp	 edi, ebx
  00092	0f 47 fb	 cmova	 edi, ebx

; 430  :         zmemcpy(state->window + state->wnext, end - copy, dist);

  00095	2b c3		 sub	 eax, ebx
  00097	57		 push	 edi
  00098	50		 push	 eax
  00099	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  0009c	03 46 34	 add	 eax, DWORD PTR [esi+52]
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 _memcpy
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 431  :         copy -= dist;

  000a8	2b df		 sub	 ebx, edi

; 432  :         if (copy) {

  000aa	74 24		 je	 SHORT $LN8@updatewind

; 433  :             zmemcpy(state->window, end - copy, copy);

  000ac	8b 45 fc	 mov	 eax, DWORD PTR _end$1$[ebp]
  000af	53		 push	 ebx
  000b0	2b c3		 sub	 eax, ebx
  000b2	50		 push	 eax
  000b3	ff 76 38	 push	 DWORD PTR [esi+56]
  000b6	e8 00 00 00 00	 call	 _memcpy

; 434  :             state->wnext = copy;
; 435  :             state->whave = state->wsize;

  000bb	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000be	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c1	89 5e 34	 mov	 DWORD PTR [esi+52], ebx

; 440  :             if (state->whave < state->wsize) state->whave += dist;

  000c4	89 46 30	 mov	 DWORD PTR [esi+48], eax

; 441  :         }
; 442  :     }
; 443  :     return 0;

  000c7	33 c0		 xor	 eax, eax
  000c9	5b		 pop	 ebx

; 444  : }

  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
  000cc	8b e5		 mov	 esp, ebp
  000ce	5d		 pop	 ebp
  000cf	c3		 ret	 0
$LN8@updatewind:

; 436  :         }
; 437  :         else {
; 438  :             state->wnext += dist;

  000d0	01 7e 34	 add	 DWORD PTR [esi+52], edi

; 439  :             if (state->wnext == state->wsize) state->wnext = 0;

  000d3	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  000d6	39 4e 34	 cmp	 DWORD PTR [esi+52], ecx
  000d9	75 07		 jne	 SHORT $LN10@updatewind
  000db	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0
$LN10@updatewind:

; 440  :             if (state->whave < state->wsize) state->whave += dist;

  000e2	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  000e5	3b c1		 cmp	 eax, ecx
  000e7	73 05		 jae	 SHORT $LN11@updatewind
  000e9	03 c7		 add	 eax, edi
  000eb	89 46 30	 mov	 DWORD PTR [esi+48], eax
$LN11@updatewind:

; 441  :         }
; 442  :     }
; 443  :     return 0;

  000ee	5b		 pop	 ebx

; 444  : }

  000ef	5f		 pop	 edi
  000f0	33 c0		 xor	 eax, eax
  000f2	5e		 pop	 esi
  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c3		 ret	 0
_updatewindow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\inflate.c
;	COMDAT _inflateGetDictionary
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateGetDictionary PROC				; COMDAT

; 1295 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1296 :     struct inflate_state FAR *state;
; 1297 : 
; 1298 :     /* check state */
; 1299 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 07		 je	 SHORT $LN2@inflateGet
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1312 : }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
$LN2@inflateGet:

; 1300 :     state = (struct inflate_state FAR *)strm->state;

  00016	56		 push	 esi
  00017	8b 71 1c	 mov	 esi, DWORD PTR [ecx+28]

; 1301 : 
; 1302 :     /* copy dictionary */
; 1303 :     if (state->whave && dictionary != Z_NULL) {

  0001a	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0001d	85 c0		 test	 eax, eax
  0001f	74 2f		 je	 SHORT $LN3@inflateGet
  00021	57		 push	 edi
  00022	8b 7d 0c	 mov	 edi, DWORD PTR _dictionary$[ebp]
  00025	85 ff		 test	 edi, edi
  00027	74 26		 je	 SHORT $LN6@inflateGet

; 1304 :         zmemcpy(dictionary, state->window + state->wnext,

  00029	2b 46 34	 sub	 eax, DWORD PTR [esi+52]
  0002c	50		 push	 eax
  0002d	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00030	03 46 34	 add	 eax, DWORD PTR [esi+52]
  00033	50		 push	 eax
  00034	57		 push	 edi
  00035	e8 00 00 00 00	 call	 _memcpy

; 1305 :                 state->whave - state->wnext);
; 1306 :         zmemcpy(dictionary + state->whave - state->wnext,

  0003a	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0003d	2b f8		 sub	 edi, eax
  0003f	03 7e 30	 add	 edi, DWORD PTR [esi+48]
  00042	50		 push	 eax
  00043	ff 76 38	 push	 DWORD PTR [esi+56]
  00046	57		 push	 edi
  00047	e8 00 00 00 00	 call	 _memcpy
  0004c	83 c4 18	 add	 esp, 24			; 00000018H
$LN6@inflateGet:
  0004f	5f		 pop	 edi
$LN3@inflateGet:

; 1307 :                 state->window, state->wnext);
; 1308 :     }
; 1309 :     if (dictLength != Z_NULL)

  00050	8b 4d 10	 mov	 ecx, DWORD PTR _dictLength$[ebp]
  00053	85 c9		 test	 ecx, ecx
  00055	74 05		 je	 SHORT $LN4@inflateGet

; 1310 :         *dictLength = state->whave;

  00057	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0005a	89 01		 mov	 DWORD PTR [ecx], eax
$LN4@inflateGet:

; 1311 :     return Z_OK;

  0005c	33 c0		 xor	 eax, eax
  0005e	5e		 pop	 esi

; 1312 : }

  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_inflateGetDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\inflate.c
;	COMDAT _inflateSetDictionary
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateSetDictionary PROC				; COMDAT

; 1318 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 1319 :     struct inflate_state FAR *state;
; 1320 :     unsigned long dictid;
; 1321 :     int ret;
; 1322 : 
; 1323 :     /* check state */
; 1324 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
  00007	8b cf		 mov	 ecx, edi
  00009	e8 00 00 00 00	 call	 _inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 08		 je	 SHORT $LN2@inflateSet
  00012	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1347 : }

  00017	5f		 pop	 edi
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
$LN2@inflateSet:

; 1325 :     state = (struct inflate_state FAR *)strm->state;

  0001a	56		 push	 esi
  0001b	8b 77 1c	 mov	 esi, DWORD PTR [edi+28]

; 1326 :     if (state->wrap != 0 && state->mode != DICT)

  0001e	83 7e 0c 00	 cmp	 DWORD PTR [esi+12], 0
  00022	74 12		 je	 SHORT $LN3@inflateSet
  00024	81 7e 04 3e 3f
	00 00		 cmp	 DWORD PTR [esi+4], 16190 ; 00003f3eH
  0002b	74 09		 je	 SHORT $LN3@inflateSet

; 1327 :         return Z_STREAM_ERROR;

  0002d	5e		 pop	 esi
  0002e	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1347 : }

  00033	5f		 pop	 edi
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
$LN3@inflateSet:

; 1328 : 
; 1329 :     /* check for correct dictionary identifier */
; 1330 :     if (state->mode == DICT) {

  00036	81 7e 04 3e 3f
	00 00		 cmp	 DWORD PTR [esi+4], 16190 ; 00003f3eH
  0003d	53		 push	 ebx
  0003e	8b 5d 10	 mov	 ebx, DWORD PTR _dictLength$[ebp]
  00041	75 27		 jne	 SHORT $LN5@inflateSet

; 1331 :         dictid = adler32(0L, Z_NULL, 0);

  00043	6a 00		 push	 0
  00045	6a 00		 push	 0
  00047	6a 00		 push	 0
  00049	e8 00 00 00 00	 call	 _adler32

; 1332 :         dictid = adler32(dictid, dictionary, dictLength);

  0004e	53		 push	 ebx
  0004f	ff 75 0c	 push	 DWORD PTR _dictionary$[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 _adler32
  00058	83 c4 18	 add	 esp, 24			; 00000018H

; 1333 :         if (dictid != state->check)

  0005b	3b 46 1c	 cmp	 eax, DWORD PTR [esi+28]
  0005e	74 0a		 je	 SHORT $LN5@inflateSet

; 1334 :             return Z_DATA_ERROR;

  00060	5b		 pop	 ebx
  00061	5e		 pop	 esi
  00062	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 1347 : }

  00067	5f		 pop	 edi
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
$LN5@inflateSet:

; 1335 :     }
; 1336 : 
; 1337 :     /* copy dictionary to window using updatewindow(), which will amend the
; 1338 :        existing dictionary if appropriate */
; 1339 :     ret = updatewindow(strm, dictionary + dictLength, dictLength);

  0006a	8b 55 0c	 mov	 edx, DWORD PTR _dictionary$[ebp]
  0006d	8b cf		 mov	 ecx, edi
  0006f	53		 push	 ebx
  00070	8d 14 1a	 lea	 edx, DWORD PTR [edx+ebx]
  00073	e8 00 00 00 00	 call	 _updatewindow
  00078	83 c4 04	 add	 esp, 4

; 1340 :     if (ret) {

  0007b	85 c0		 test	 eax, eax
  0007d	74 11		 je	 SHORT $LN6@inflateSet

; 1341 :         state->mode = MEM;

  0007f	5b		 pop	 ebx
  00080	c7 46 04 52 3f
	00 00		 mov	 DWORD PTR [esi+4], 16210 ; 00003f52H

; 1342 :         return Z_MEM_ERROR;

  00087	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0008c	5e		 pop	 esi

; 1347 : }

  0008d	5f		 pop	 edi
  0008e	5d		 pop	 ebp
  0008f	c3		 ret	 0
$LN6@inflateSet:
  00090	5b		 pop	 ebx

; 1343 :     }
; 1344 :     state->havedict = 1;

  00091	c7 46 10 01 00
	00 00		 mov	 DWORD PTR [esi+16], 1

; 1345 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1346 :     return Z_OK;

  00098	33 c0		 xor	 eax, eax
  0009a	5e		 pop	 esi

; 1347 : }

  0009b	5f		 pop	 edi
  0009c	5d		 pop	 ebp
  0009d	c3		 ret	 0
_inflateSetDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\inflate.c
;	COMDAT _inflateGetHeader
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_head$ = 12						; size = 4
_inflateGetHeader PROC					; COMDAT

; 1352 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1353 :     struct inflate_state FAR *state;
; 1354 : 
; 1355 :     /* check state */
; 1356 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 07		 je	 SHORT $LN2@inflateGet
$LN5@inflateGet:
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1364 : }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
$LN2@inflateGet:

; 1357 :     state = (struct inflate_state FAR *)strm->state;

  00016	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]

; 1358 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  00019	f6 41 0c 02	 test	 BYTE PTR [ecx+12], 2
  0001d	74 f0		 je	 SHORT $LN5@inflateGet

; 1359 : 
; 1360 :     /* save header structure */
; 1361 :     state->head = head;

  0001f	8b 45 0c	 mov	 eax, DWORD PTR _head$[ebp]
  00022	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 1362 :     head->done = 0;

  00025	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0

; 1363 :     return Z_OK;

  0002c	33 c0		 xor	 eax, eax

; 1364 : }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
_inflateGetHeader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\inflate.c
;	COMDAT _syncsearch
_TEXT	SEGMENT
_buf$1$ = -8						; size = 4
_have$1$ = -4						; size = 4
_len$ = 8						; size = 4
_syncsearch PROC					; COMDAT
; _have$ = ecx
; _buf$ = edx

; 1381 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1382 :     unsigned got;
; 1383 :     unsigned next;
; 1384 : 
; 1385 :     got = *have;

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	56		 push	 esi
  00009	57		 push	 edi

; 1386 :     next = 0;
; 1387 :     while (next < len && got < 4) {

  0000a	8b 7d 08	 mov	 edi, DWORD PTR _len$[ebp]
  0000d	33 f6		 xor	 esi, esi
  0000f	89 55 f8	 mov	 DWORD PTR _buf$1$[ebp], edx
  00012	89 4d fc	 mov	 DWORD PTR _have$1$[ebp], ecx
  00015	85 ff		 test	 edi, edi
  00017	74 50		 je	 SHORT $LN13@syncsearch
  00019	53		 push	 ebx
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL2@syncsearch:
  00020	83 f8 04	 cmp	 eax, 4
  00023	73 36		 jae	 SHORT $LN14@syncsearch

; 1388 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  00025	8a 1c 16	 mov	 bl, BYTE PTR [esi+edx]
  00028	83 f8 02	 cmp	 eax, 2
  0002b	0f b6 cb	 movzx	 ecx, bl
  0002e	1b d2		 sbb	 edx, edx
  00030	81 e2 01 ff ff
	ff		 and	 edx, -255		; ffffff01H
  00036	81 c2 ff 00 00
	00		 add	 edx, 255		; 000000ffH
  0003c	3b ca		 cmp	 ecx, edx
  0003e	75 03		 jne	 SHORT $LN4@syncsearch

; 1389 :             got++;

  00040	40		 inc	 eax
  00041	eb 10		 jmp	 SHORT $LN7@syncsearch
$LN4@syncsearch:

; 1390 :         else if (buf[next])
; 1391 :             got = 0;
; 1392 :         else
; 1393 :             got = 4 - got;

  00043	b9 04 00 00 00	 mov	 ecx, 4
  00048	33 d2		 xor	 edx, edx
  0004a	2b c8		 sub	 ecx, eax
  0004c	84 db		 test	 bl, bl
  0004e	8b c1		 mov	 eax, ecx
  00050	0f 45 c2	 cmovne	 eax, edx
$LN7@syncsearch:

; 1394 :         next++;

  00053	8b 55 f8	 mov	 edx, DWORD PTR _buf$1$[ebp]
  00056	46		 inc	 esi
  00057	3b f7		 cmp	 esi, edi
  00059	72 c5		 jb	 SHORT $LL2@syncsearch
$LN14@syncsearch:

; 1395 :     }
; 1396 :     *have = got;

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _have$1$[ebp]
  0005e	5b		 pop	 ebx

; 1398 : }

  0005f	5f		 pop	 edi
  00060	89 01		 mov	 DWORD PTR [ecx], eax
  00062	8b c6		 mov	 eax, esi
  00064	5e		 pop	 esi
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
$LN13@syncsearch:

; 1395 :     }
; 1396 :     *have = got;

  00069	89 01		 mov	 DWORD PTR [ecx], eax

; 1397 :     return next;

  0006b	8b c6		 mov	 eax, esi

; 1398 : }

  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_syncsearch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\inflate.c
;	COMDAT _inflateSync
_TEXT	SEGMENT
_in$1$ = -4						; size = 4
_buf$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateSync PROC					; COMDAT

; 1402 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 1403 :     unsigned len;               /* number of bytes to look at or looked at */
; 1404 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1405 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1406 :     struct inflate_state FAR *state;
; 1407 : 
; 1408 :     /* check parameters */
; 1409 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _strm$[ebp]
  00008	8b cb		 mov	 ecx, ebx
  0000a	e8 00 00 00 00	 call	 _inflateStateCheck
  0000f	85 c0		 test	 eax, eax
  00011	74 0a		 je	 SHORT $LN4@inflateSyn
  00013	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1441 : }

  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
$LN4@inflateSyn:

; 1410 :     state = (struct inflate_state FAR *)strm->state;
; 1411 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  0001d	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  00021	57		 push	 edi
  00022	8b 7b 1c	 mov	 edi, DWORD PTR [ebx+28]
  00025	75 11		 jne	 SHORT $LN5@inflateSyn
  00027	83 7f 40 08	 cmp	 DWORD PTR [edi+64], 8
  0002b	73 0b		 jae	 SHORT $LN5@inflateSyn
  0002d	5f		 pop	 edi
  0002e	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH

; 1441 : }

  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
$LN5@inflateSyn:

; 1412 : 
; 1413 :     /* if first time, start search in bit buffer */
; 1414 :     if (state->mode != SYNC) {

  00038	81 7f 04 53 3f
	00 00		 cmp	 DWORD PTR [edi+4], 16211 ; 00003f53H
  0003f	56		 push	 esi
  00040	74 4f		 je	 SHORT $LN6@inflateSyn

; 1415 :         state->mode = SYNC;
; 1416 :         state->hold <<= state->bits & 7;

  00042	8b 57 40	 mov	 edx, DWORD PTR [edi+64]

; 1417 :         state->bits -= state->bits & 7;
; 1418 :         len = 0;

  00045	33 f6		 xor	 esi, esi
  00047	8b ca		 mov	 ecx, edx
  00049	c7 47 04 53 3f
	00 00		 mov	 DWORD PTR [edi+4], 16211 ; 00003f53H
  00050	83 e1 07	 and	 ecx, 7
  00053	d3 67 3c	 shl	 DWORD PTR [edi+60], cl
  00056	2b d1		 sub	 edx, ecx
  00058	89 57 40	 mov	 DWORD PTR [edi+64], edx

; 1419 :         while (state->bits >= 8) {

  0005b	83 fa 08	 cmp	 edx, 8
  0005e	72 1c		 jb	 SHORT $LN3@inflateSyn

; 1420 :             buf[len++] = (unsigned char)(state->hold);

  00060	8b 4f 3c	 mov	 ecx, DWORD PTR [edi+60]
$LL2@inflateSyn:
  00063	8a 47 3c	 mov	 al, BYTE PTR [edi+60]

; 1421 :             state->hold >>= 8;
; 1422 :             state->bits -= 8;

  00066	83 ea 08	 sub	 edx, 8
  00069	88 44 35 fc	 mov	 BYTE PTR _buf$[ebp+esi], al
  0006d	46		 inc	 esi
  0006e	c1 e9 08	 shr	 ecx, 8

; 1423 :         }
; 1424 :         state->have = 0;

  00071	89 4f 3c	 mov	 DWORD PTR [edi+60], ecx
  00074	83 fa 08	 cmp	 edx, 8
  00077	73 ea		 jae	 SHORT $LL2@inflateSyn
  00079	89 57 40	 mov	 DWORD PTR [edi+64], edx
$LN3@inflateSyn:
  0007c	8d 4f 6c	 lea	 ecx, DWORD PTR [edi+108]

; 1425 :         syncsearch(&(state->have), buf, len);

  0007f	8d 55 fc	 lea	 edx, DWORD PTR _buf$[ebp]
  00082	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00088	56		 push	 esi
  00089	e8 00 00 00 00	 call	 _syncsearch
  0008e	83 c4 04	 add	 esp, 4
$LN6@inflateSyn:

; 1426 :     }
; 1427 : 
; 1428 :     /* search available input */
; 1429 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  00091	ff 73 04	 push	 DWORD PTR [ebx+4]
  00094	8b 13		 mov	 edx, DWORD PTR [ebx]
  00096	8d 4f 6c	 lea	 ecx, DWORD PTR [edi+108]
  00099	e8 00 00 00 00	 call	 _syncsearch

; 1430 :     strm->avail_in -= len;

  0009e	29 43 04	 sub	 DWORD PTR [ebx+4], eax
  000a1	83 c4 04	 add	 esp, 4

; 1431 :     strm->next_in += len;

  000a4	01 03		 add	 DWORD PTR [ebx], eax

; 1432 :     strm->total_in += len;

  000a6	01 43 08	 add	 DWORD PTR [ebx+8], eax

; 1433 : 
; 1434 :     /* return no joy or set up to restart inflate() on a new block */
; 1435 :     if (state->have != 4) return Z_DATA_ERROR;

  000a9	83 7f 6c 04	 cmp	 DWORD PTR [edi+108], 4
  000ad	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  000b0	89 45 fc	 mov	 DWORD PTR _in$1$[ebp], eax
  000b3	74 0c		 je	 SHORT $LN7@inflateSyn
  000b5	5e		 pop	 esi
  000b6	5f		 pop	 edi
  000b7	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 1441 : }

  000bc	5b		 pop	 ebx
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
$LN7@inflateSyn:

; 1436 :     in = strm->total_in;  out = strm->total_out;

  000c1	8b 73 14	 mov	 esi, DWORD PTR [ebx+20]

; 1437 :     inflateReset(strm);

  000c4	53		 push	 ebx
  000c5	e8 00 00 00 00	 call	 _inflateReset

; 1438 :     strm->total_in = in;  strm->total_out = out;

  000ca	8b 45 fc	 mov	 eax, DWORD PTR _in$1$[ebp]
  000cd	83 c4 04	 add	 esp, 4
  000d0	89 73 14	 mov	 DWORD PTR [ebx+20], esi
  000d3	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 1439 :     state->mode = TYPE;
; 1440 :     return Z_OK;

  000d6	33 c0		 xor	 eax, eax
  000d8	c7 47 04 3f 3f
	00 00		 mov	 DWORD PTR [edi+4], 16191 ; 00003f3fH
  000df	5e		 pop	 esi
  000e0	5f		 pop	 edi

; 1441 : }

  000e1	5b		 pop	 ebx
  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c3		 ret	 0
_inflateSync ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\inflate.c
;	COMDAT _inflateSyncPoint
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateSyncPoint PROC					; COMDAT

; 1453 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1454 :     struct inflate_state FAR *state;
; 1455 : 
; 1456 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 07		 je	 SHORT $LN2@inflateSyn
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1459 : }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
$LN2@inflateSyn:

; 1457 :     state = (struct inflate_state FAR *)strm->state;

  00016	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 1458 :     return state->mode == STORED && state->bits == 0;

  00019	81 78 04 41 3f
	00 00		 cmp	 DWORD PTR [eax+4], 16193 ; 00003f41H
  00020	75 0d		 jne	 SHORT $LN4@inflateSyn
  00022	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  00026	75 07		 jne	 SHORT $LN4@inflateSyn
  00028	b8 01 00 00 00	 mov	 eax, 1

; 1459 : }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
$LN4@inflateSyn:

; 1458 :     return state->mode == STORED && state->bits == 0;

  0002f	33 c0		 xor	 eax, eax

; 1459 : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
_inflateSyncPoint ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\inflate.c
;	COMDAT _inflateCopy
_TEXT	SEGMENT
_window$1$ = -4						; size = 4
_dest$ = 8						; size = 4
_source$ = 12						; size = 4
_inflateCopy PROC					; COMDAT

; 1464 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 1465 :     struct inflate_state FAR *state;
; 1466 :     struct inflate_state FAR *copy;
; 1467 :     unsigned char FAR *window;
; 1468 :     unsigned wsize;
; 1469 : 
; 1470 :     /* check input */
; 1471 :     if (inflateStateCheck(source) || dest == Z_NULL)

  00005	8b 7d 0c	 mov	 edi, DWORD PTR _source$[ebp]
  00008	8b cf		 mov	 ecx, edi
  0000a	e8 00 00 00 00	 call	 _inflateStateCheck
  0000f	85 c0		 test	 eax, eax
  00011	0f 85 2e 01 00
	00		 jne	 $LN3@inflateCop
  00017	39 45 08	 cmp	 DWORD PTR _dest$[ebp], eax
  0001a	0f 84 25 01 00
	00		 je	 $LN3@inflateCop

; 1473 :     state = (struct inflate_state FAR *)source->state;
; 1474 : 
; 1475 :     /* allocate space */
; 1476 :     copy = (struct inflate_state FAR *)

  00020	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00023	53		 push	 ebx
  00024	8b 5f 1c	 mov	 ebx, DWORD PTR [edi+28]
  00027	56		 push	 esi
  00028	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  0002d	6a 01		 push	 1
  0002f	ff 77 28	 push	 DWORD PTR [edi+40]
  00032	ff d0		 call	 eax
  00034	8b f0		 mov	 esi, eax
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1477 :            ZALLOC(source, 1, sizeof(struct inflate_state));
; 1478 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  00039	85 f6		 test	 esi, esi
  0003b	74 38		 je	 SHORT $LN12@inflateCop

; 1479 :     window = Z_NULL;
; 1480 :     if (state->window != Z_NULL) {

  0003d	83 7b 38 00	 cmp	 DWORD PTR [ebx+56], 0
  00041	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _window$1$[ebp], 0
  00048	74 37		 je	 SHORT $LN6@inflateCop

; 1481 :         window = (unsigned char FAR *)

  0004a	8b 4b 28	 mov	 ecx, DWORD PTR [ebx+40]
  0004d	b8 01 00 00 00	 mov	 eax, 1
  00052	d3 e0		 shl	 eax, cl
  00054	6a 01		 push	 1
  00056	50		 push	 eax
  00057	ff 77 28	 push	 DWORD PTR [edi+40]
  0005a	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  0005d	ff d0		 call	 eax
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00062	89 45 fc	 mov	 DWORD PTR _window$1$[ebp], eax

; 1482 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));
; 1483 :         if (window == Z_NULL) {

  00065	85 c0		 test	 eax, eax
  00067	75 18		 jne	 SHORT $LN6@inflateCop

; 1484 :             ZFREE(source, copy);

  00069	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  0006c	56		 push	 esi
  0006d	ff 77 28	 push	 DWORD PTR [edi+40]
  00070	ff d0		 call	 eax
  00072	83 c4 08	 add	 esp, 8
$LN12@inflateCop:

; 1485 :             return Z_MEM_ERROR;

  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx
  00077	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH

; 1506 : }

  0007c	5f		 pop	 edi
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
$LN6@inflateCop:

; 1486 :         }
; 1487 :     }
; 1488 : 
; 1489 :     /* copy state */
; 1490 :     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

  00081	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
  00084	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]

; 1491 :     zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));

  00087	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  0008c	53		 push	 ebx
  0008d	56		 push	 esi
  0008e	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  00091	0f 10 47 10	 movups	 xmm0, XMMWORD PTR [edi+16]
  00095	0f 11 40 10	 movups	 XMMWORD PTR [eax+16], xmm0
  00099	0f 10 47 20	 movups	 xmm0, XMMWORD PTR [edi+32]
  0009d	0f 11 40 20	 movups	 XMMWORD PTR [eax+32], xmm0
  000a1	f3 0f 7e 47 30	 movq	 xmm0, QWORD PTR [edi+48]
  000a6	66 0f d6 40 30	 movq	 QWORD PTR [eax+48], xmm0
  000ab	e8 00 00 00 00	 call	 _memcpy

; 1492 :     copy->strm = dest;

  000b0	8b 7d 08	 mov	 edi, DWORD PTR _dest$[ebp]

; 1493 :     if (state->lencode >= state->codes &&

  000b3	8d 83 34 05 00
	00		 lea	 eax, DWORD PTR [ebx+1332]
  000b9	89 3e		 mov	 DWORD PTR [esi], edi
  000bb	83 c4 0c	 add	 esp, 12			; 0000000cH
  000be	8b 4b 50	 mov	 ecx, DWORD PTR [ebx+80]
  000c1	3b c8		 cmp	 ecx, eax
  000c3	72 38		 jb	 SHORT $LN7@inflateCop
  000c5	8d 83 c0 1b 00
	00		 lea	 eax, DWORD PTR [ebx+7104]
  000cb	3b c8		 cmp	 ecx, eax
  000cd	77 2e		 ja	 SHORT $LN7@inflateCop

; 1494 :         state->lencode <= state->codes + ENOUGH - 1) {
; 1495 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  000cf	2b cb		 sub	 ecx, ebx
  000d1	8d 81 cc fa ff
	ff		 lea	 eax, DWORD PTR [ecx-1332]
  000d7	c1 f8 02	 sar	 eax, 2
  000da	05 4d 01 00 00	 add	 eax, 333		; 0000014dH
  000df	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  000e2	89 46 50	 mov	 DWORD PTR [esi+80], eax

; 1496 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  000e5	8b 43 54	 mov	 eax, DWORD PTR [ebx+84]
  000e8	2b c3		 sub	 eax, ebx
  000ea	2d 34 05 00 00	 sub	 eax, 1332		; 00000534H
  000ef	c1 f8 02	 sar	 eax, 2
  000f2	05 4d 01 00 00	 add	 eax, 333		; 0000014dH
  000f7	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  000fa	89 46 54	 mov	 DWORD PTR [esi+84], eax
$LN7@inflateCop:

; 1497 :     }
; 1498 :     copy->next = copy->codes + (state->next - state->codes);

  000fd	8b 43 70	 mov	 eax, DWORD PTR [ebx+112]
  00100	2b c3		 sub	 eax, ebx
  00102	2d 34 05 00 00	 sub	 eax, 1332		; 00000534H
  00107	c1 f8 02	 sar	 eax, 2
  0010a	05 4d 01 00 00	 add	 eax, 333		; 0000014dH
  0010f	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  00112	89 46 70	 mov	 DWORD PTR [esi+112], eax

; 1499 :     if (window != Z_NULL) {

  00115	8b 45 fc	 mov	 eax, DWORD PTR _window$1$[ebp]
  00118	85 c0		 test	 eax, eax
  0011a	74 1a		 je	 SHORT $LN8@inflateCop

; 1500 :         wsize = 1U << state->wbits;

  0011c	8b 4b 28	 mov	 ecx, DWORD PTR [ebx+40]
  0011f	ba 01 00 00 00	 mov	 edx, 1
  00124	d3 e2		 shl	 edx, cl

; 1501 :         zmemcpy(window, state->window, wsize);

  00126	52		 push	 edx
  00127	ff 73 38	 push	 DWORD PTR [ebx+56]
  0012a	50		 push	 eax
  0012b	e8 00 00 00 00	 call	 _memcpy
  00130	8b 45 fc	 mov	 eax, DWORD PTR _window$1$[ebp]
  00133	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@inflateCop:

; 1502 :     }
; 1503 :     copy->window = window;

  00136	89 46 38	 mov	 DWORD PTR [esi+56], eax

; 1504 :     dest->state = (struct internal_state FAR *)copy;
; 1505 :     return Z_OK;

  00139	33 c0		 xor	 eax, eax
  0013b	89 77 1c	 mov	 DWORD PTR [edi+28], esi
  0013e	5e		 pop	 esi
  0013f	5b		 pop	 ebx

; 1506 : }

  00140	5f		 pop	 edi
  00141	8b e5		 mov	 esp, ebp
  00143	5d		 pop	 ebp
  00144	c3		 ret	 0
$LN3@inflateCop:

; 1472 :         return Z_STREAM_ERROR;

  00145	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1506 : }

  0014a	5f		 pop	 edi
  0014b	8b e5		 mov	 esp, ebp
  0014d	5d		 pop	 ebp
  0014e	c3		 ret	 0
_inflateCopy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\inflate.c
;	COMDAT _inflateUndermine
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_subvert$ = 12						; size = 4
_inflateUndermine PROC					; COMDAT

; 1511 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1512 :     struct inflate_state FAR *state;
; 1513 : 
; 1514 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 07		 je	 SHORT $LN2@inflateUnd
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1523 : #endif
; 1524 : }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
$LN2@inflateUnd:

; 1515 :     state = (struct inflate_state FAR *)strm->state;
; 1516 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1517 :     state->sane = !subvert;
; 1518 :     return Z_OK;
; 1519 : #else
; 1520 :     (void)subvert;
; 1521 :     state->sane = 1;

  00016	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00019	c7 80 c4 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+7108], 1

; 1522 :     return Z_DATA_ERROR;

  00023	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 1523 : #endif
; 1524 : }

  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
_inflateUndermine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\inflate.c
;	COMDAT _inflateValidate
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_check$ = 12						; size = 4
_inflateValidate PROC					; COMDAT

; 1529 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1530 :     struct inflate_state FAR *state;
; 1531 : 
; 1532 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 07		 je	 SHORT $LN2@inflateVal
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1539 : }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
$LN2@inflateVal:

; 1533 :     state = (struct inflate_state FAR *)strm->state;
; 1534 :     if (check)

  00016	83 7d 0c 00	 cmp	 DWORD PTR _check$[ebp], 0
  0001a	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0001d	74 08		 je	 SHORT $LN3@inflateVal

; 1535 :         state->wrap |= 4;

  0001f	83 48 0c 04	 or	 DWORD PTR [eax+12], 4

; 1538 :     return Z_OK;

  00023	33 c0		 xor	 eax, eax

; 1539 : }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN3@inflateVal:

; 1536 :     else
; 1537 :         state->wrap &= ~4;

  00027	83 60 0c fb	 and	 DWORD PTR [eax+12], -5	; fffffffbH

; 1538 :     return Z_OK;

  0002b	33 c0		 xor	 eax, eax

; 1539 : }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
_inflateValidate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\inflate.c
;	COMDAT _inflateMark
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateMark PROC					; COMDAT

; 1543 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1544 :     struct inflate_state FAR *state;
; 1545 : 
; 1546 :     if (inflateStateCheck(strm))

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 07		 je	 SHORT $LN2@inflateMar

; 1547 :         return -(1L << 16);

  0000f	b8 00 00 ff ff	 mov	 eax, -65536		; ffff0000H

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
$LN2@inflateMar:

; 1548 :     state = (struct inflate_state FAR *)strm->state;

  00016	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 1549 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  00019	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001c	81 f9 43 3f 00
	00		 cmp	 ecx, 16195		; 00003f43H
  00022	75 10		 jne	 SHORT $LN6@inflateMar
  00024	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00027	8b 80 c8 1b 00
	00		 mov	 eax, DWORD PTR [eax+7112]
  0002d	c1 e0 10	 shl	 eax, 16			; 00000010H
  00030	03 c1		 add	 eax, ecx

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
$LN6@inflateMar:

; 1549 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  00034	81 f9 4c 3f 00
	00		 cmp	 ecx, 16204		; 00003f4cH
  0003a	75 16		 jne	 SHORT $LN4@inflateMar
  0003c	8b 88 cc 1b 00
	00		 mov	 ecx, DWORD PTR [eax+7116]
  00042	2b 48 44	 sub	 ecx, DWORD PTR [eax+68]
  00045	8b 80 c8 1b 00
	00		 mov	 eax, DWORD PTR [eax+7112]
  0004b	c1 e0 10	 shl	 eax, 16			; 00000010H
  0004e	03 c1		 add	 eax, ecx

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
$LN4@inflateMar:

; 1549 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  00052	8b 80 c8 1b 00
	00		 mov	 eax, DWORD PTR [eax+7112]
  00058	33 c9		 xor	 ecx, ecx
  0005a	c1 e0 10	 shl	 eax, 16			; 00000010H
  0005d	03 c1		 add	 eax, ecx

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_inflateMark ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\inflate.c
;	COMDAT _inflateCodesUsed
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateCodesUsed PROC					; COMDAT

; 1556 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1557 :     struct inflate_state FAR *state;
; 1558 :     if (inflateStateCheck(strm)) return (unsigned long)-1;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 05		 je	 SHORT $LN2@inflateCod
  0000f	83 c8 ff	 or	 eax, -1

; 1561 : }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
$LN2@inflateCod:

; 1559 :     state = (struct inflate_state FAR *)strm->state;

  00014	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]

; 1560 :     return (unsigned long)(state->next - state->codes);

  00017	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  0001a	2b c1		 sub	 eax, ecx
  0001c	2d 34 05 00 00	 sub	 eax, 1332		; 00000534H
  00021	c1 f8 02	 sar	 eax, 2

; 1561 : }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
_inflateCodesUsed ENDP
_TEXT	ENDS
END
