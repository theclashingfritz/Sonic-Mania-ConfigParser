; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\theclashingfritz\source\repos\INIFileParser\zlib\inffast.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG80384 DB	'invalid distance too far back', 00H
	ORG $+2
$SG80420 DB	'invalid distance code', 00H
	ORG $+2
$SG80427 DB	'invalid literal/length code', 00H
_DATA	ENDS
PUBLIC	_inflate_fast
; Function compile flags: /Odtp
; File c:\users\theclashingfritz\source\repos\inifileparser\zlib\inffast.c
_TEXT	SEGMENT
tv324 = -92						; size = 4
tv317 = -88						; size = 4
_state$ = -84						; size = 4
_out$ = -80						; size = 4
_op$ = -76						; size = 4
_from$ = -72						; size = 4
_dmask$ = -68						; size = 4
_wsize$ = -64						; size = 4
_hold$ = -60						; size = 4
_dist$ = -56						; size = 4
_lcode$ = -52						; size = 4
_end$ = -48						; size = 4
_lmask$ = -44						; size = 4
_wnext$ = -40						; size = 4
_bits$ = -36						; size = 4
_len$ = -32						; size = 4
_in$ = -28						; size = 4
_whave$ = -24						; size = 4
_dcode$ = -20						; size = 4
_last$ = -16						; size = 4
_window$ = -12						; size = 4
_here$ = -8						; size = 4
_beg$ = -4						; size = 4
_strm$ = 8						; size = 4
_start$ = 12						; size = 4
_inflate_fast PROC

; 53   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH

; 54   :     struct inflate_state FAR *state;
; 55   :     z_const unsigned char FAR *in;      /* local strm->next_in */
; 56   :     z_const unsigned char FAR *last;    /* have enough input while in < last */
; 57   :     unsigned char FAR *out;     /* local strm->next_out */
; 58   :     unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
; 59   :     unsigned char FAR *end;     /* while out < end, enough space available */
; 60   : #ifdef INFLATE_STRICT
; 61   :     unsigned dmax;              /* maximum distance from zlib header */
; 62   : #endif
; 63   :     unsigned wsize;             /* window size or zero if not using window */
; 64   :     unsigned whave;             /* valid bytes in the window */
; 65   :     unsigned wnext;             /* window write index */
; 66   :     unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
; 67   :     unsigned long hold;         /* local strm->hold */
; 68   :     unsigned bits;              /* local strm->bits */
; 69   :     code const FAR *lcode;      /* local strm->lencode */
; 70   :     code const FAR *dcode;      /* local strm->distcode */
; 71   :     unsigned lmask;             /* mask for first level of length codes */
; 72   :     unsigned dmask;             /* mask for first level of distance codes */
; 73   :     code here;                  /* retrieved table entry */
; 74   :     unsigned op;                /* code bits, operation, extra bits, or */
; 75   :                                 /*  window position, window bytes to copy */
; 76   :     unsigned len;               /* match length, unused bytes */
; 77   :     unsigned dist;              /* match distance */
; 78   :     unsigned char FAR *from;    /* where to copy match from */
; 79   : 
; 80   :     /* copy state to local variables */
; 81   :     state = (struct inflate_state FAR *)strm->state;

	mov	eax, DWORD PTR _strm$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _state$[ebp], ecx

; 82   :     in = strm->next_in;

	mov	edx, DWORD PTR _strm$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _in$[ebp], eax

; 83   :     last = in + (strm->avail_in - 5);

	mov	ecx, DWORD PTR _strm$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _in$[ebp]
	lea	ecx, DWORD PTR [eax+edx-5]
	mov	DWORD PTR _last$[ebp], ecx

; 84   :     out = strm->next_out;

	mov	edx, DWORD PTR _strm$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _out$[ebp], eax

; 85   :     beg = out - (start - strm->avail_out);

	mov	ecx, DWORD PTR _strm$[ebp]
	mov	edx, DWORD PTR _start$[ebp]
	sub	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _out$[ebp]
	sub	eax, edx
	mov	DWORD PTR _beg$[ebp], eax

; 86   :     end = out + (strm->avail_out - 257);

	mov	ecx, DWORD PTR _strm$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _out$[ebp]
	lea	ecx, DWORD PTR [eax+edx-257]
	mov	DWORD PTR _end$[ebp], ecx

; 87   : #ifdef INFLATE_STRICT
; 88   :     dmax = state->dmax;
; 89   : #endif
; 90   :     wsize = state->wsize;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _wsize$[ebp], eax

; 91   :     whave = state->whave;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR _whave$[ebp], edx

; 92   :     wnext = state->wnext;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR _wnext$[ebp], ecx

; 93   :     window = state->window;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	DWORD PTR _window$[ebp], eax

; 94   :     hold = state->hold;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR _hold$[ebp], edx

; 95   :     bits = state->bits;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR _bits$[ebp], ecx

; 96   :     lcode = state->lencode;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	DWORD PTR _lcode$[ebp], eax

; 97   :     dcode = state->distcode;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR _dcode$[ebp], edx

; 98   :     lmask = (1U << state->lenbits) - 1;

	mov	eax, DWORD PTR _state$[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [eax+88]
	shl	edx, cl
	sub	edx, 1
	mov	DWORD PTR _lmask$[ebp], edx

; 99   :     dmask = (1U << state->distbits) - 1;

	mov	eax, DWORD PTR _state$[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [eax+92]
	shl	edx, cl
	sub	edx, 1
	mov	DWORD PTR _dmask$[ebp], edx
$LN55@inflate_fa:

; 100  : 
; 101  :     /* decode literals and length/distances until end-of-block or not enough
; 102  :        input data or output space */
; 103  :     do {
; 104  :         if (bits < 15) {

	cmp	DWORD PTR _bits$[ebp], 15		; 0000000fH
	jae	SHORT $LN52@inflate_fa

; 105  :             hold += (unsigned long)(*in++) << bits;

	mov	eax, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [eax]
	mov	ecx, DWORD PTR _bits$[ebp]
	shl	edx, cl
	add	edx, DWORD PTR _hold$[ebp]
	mov	DWORD PTR _hold$[ebp], edx
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax

; 106  :             bits += 8;

	mov	ecx, DWORD PTR _bits$[ebp]
	add	ecx, 8
	mov	DWORD PTR _bits$[ebp], ecx

; 107  :             hold += (unsigned long)(*in++) << bits;

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _bits$[ebp]
	shl	eax, cl
	add	eax, DWORD PTR _hold$[ebp]
	mov	DWORD PTR _hold$[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx

; 108  :             bits += 8;

	mov	edx, DWORD PTR _bits$[ebp]
	add	edx, 8
	mov	DWORD PTR _bits$[ebp], edx
$LN52@inflate_fa:

; 109  :         }
; 110  :         here = lcode[hold & lmask];

	mov	eax, DWORD PTR _hold$[ebp]
	and	eax, DWORD PTR _lmask$[ebp]
	mov	ecx, DWORD PTR _lcode$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _here$[ebp], edx
$dolen$80354:

; 111  :       dolen:
; 112  :         op = (unsigned)(here.bits);

	movzx	eax, BYTE PTR _here$[ebp+1]
	mov	DWORD PTR _op$[ebp], eax

; 113  :         hold >>= op;

	mov	edx, DWORD PTR _hold$[ebp]
	mov	ecx, DWORD PTR _op$[ebp]
	shr	edx, cl
	mov	DWORD PTR _hold$[ebp], edx

; 114  :         bits -= op;

	mov	eax, DWORD PTR _bits$[ebp]
	sub	eax, DWORD PTR _op$[ebp]
	mov	DWORD PTR _bits$[ebp], eax

; 115  :         op = (unsigned)(here.op);

	movzx	ecx, BYTE PTR _here$[ebp]
	mov	DWORD PTR _op$[ebp], ecx

; 116  :         if (op == 0) {                          /* literal */

	cmp	DWORD PTR _op$[ebp], 0
	jne	SHORT $LN51@inflate_fa

; 117  :             Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 118  :                     "inflate:         literal '%c'\n" :
; 119  :                     "inflate:         literal 0x%02x\n", here.val));
; 120  :             *out++ = (unsigned char)(here.val);

	mov	edx, DWORD PTR _out$[ebp]
	mov	al, BYTE PTR _here$[ebp+2]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx
	jmp	$LN54@inflate_fa
$LN51@inflate_fa:

; 121  :         }
; 122  :         else if (op & 16) {                     /* length base */

	mov	edx, DWORD PTR _op$[ebp]
	and	edx, 16					; 00000010H
	je	$LN49@inflate_fa

; 123  :             len = (unsigned)(here.val);

	movzx	eax, WORD PTR _here$[ebp+2]
	mov	DWORD PTR _len$[ebp], eax

; 124  :             op &= 15;                           /* number of extra bits */

	mov	ecx, DWORD PTR _op$[ebp]
	and	ecx, 15					; 0000000fH
	mov	DWORD PTR _op$[ebp], ecx

; 125  :             if (op) {

	je	SHORT $LN48@inflate_fa

; 126  :                 if (bits < op) {

	mov	edx, DWORD PTR _bits$[ebp]
	cmp	edx, DWORD PTR _op$[ebp]
	jae	SHORT $LN47@inflate_fa

; 127  :                     hold += (unsigned long)(*in++) << bits;

	mov	eax, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [eax]
	mov	ecx, DWORD PTR _bits$[ebp]
	shl	edx, cl
	add	edx, DWORD PTR _hold$[ebp]
	mov	DWORD PTR _hold$[ebp], edx
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax

; 128  :                     bits += 8;

	mov	ecx, DWORD PTR _bits$[ebp]
	add	ecx, 8
	mov	DWORD PTR _bits$[ebp], ecx
$LN47@inflate_fa:

; 129  :                 }
; 130  :                 len += (unsigned)hold & ((1U << op) - 1);

	mov	edx, 1
	mov	ecx, DWORD PTR _op$[ebp]
	shl	edx, cl
	sub	edx, 1
	and	edx, DWORD PTR _hold$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	DWORD PTR _len$[ebp], edx

; 131  :                 hold >>= op;

	mov	eax, DWORD PTR _hold$[ebp]
	mov	ecx, DWORD PTR _op$[ebp]
	shr	eax, cl
	mov	DWORD PTR _hold$[ebp], eax

; 132  :                 bits -= op;

	mov	ecx, DWORD PTR _bits$[ebp]
	sub	ecx, DWORD PTR _op$[ebp]
	mov	DWORD PTR _bits$[ebp], ecx
$LN48@inflate_fa:

; 133  :             }
; 134  :             Tracevv((stderr, "inflate:         length %u\n", len));
; 135  :             if (bits < 15) {

	cmp	DWORD PTR _bits$[ebp], 15		; 0000000fH
	jae	SHORT $LN46@inflate_fa

; 136  :                 hold += (unsigned long)(*in++) << bits;

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _bits$[ebp]
	shl	eax, cl
	add	eax, DWORD PTR _hold$[ebp]
	mov	DWORD PTR _hold$[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx

; 137  :                 bits += 8;

	mov	edx, DWORD PTR _bits$[ebp]
	add	edx, 8
	mov	DWORD PTR _bits$[ebp], edx

; 138  :                 hold += (unsigned long)(*in++) << bits;

	mov	eax, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [eax]
	mov	ecx, DWORD PTR _bits$[ebp]
	shl	edx, cl
	add	edx, DWORD PTR _hold$[ebp]
	mov	DWORD PTR _hold$[ebp], edx
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax

; 139  :                 bits += 8;

	mov	ecx, DWORD PTR _bits$[ebp]
	add	ecx, 8
	mov	DWORD PTR _bits$[ebp], ecx
$LN46@inflate_fa:

; 140  :             }
; 141  :             here = dcode[hold & dmask];

	mov	edx, DWORD PTR _hold$[ebp]
	and	edx, DWORD PTR _dmask$[ebp]
	mov	eax, DWORD PTR _dcode$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _here$[ebp], ecx
$dodist$80369:

; 142  :           dodist:
; 143  :             op = (unsigned)(here.bits);

	movzx	edx, BYTE PTR _here$[ebp+1]
	mov	DWORD PTR _op$[ebp], edx

; 144  :             hold >>= op;

	mov	eax, DWORD PTR _hold$[ebp]
	mov	ecx, DWORD PTR _op$[ebp]
	shr	eax, cl
	mov	DWORD PTR _hold$[ebp], eax

; 145  :             bits -= op;

	mov	ecx, DWORD PTR _bits$[ebp]
	sub	ecx, DWORD PTR _op$[ebp]
	mov	DWORD PTR _bits$[ebp], ecx

; 146  :             op = (unsigned)(here.op);

	movzx	edx, BYTE PTR _here$[ebp]
	mov	DWORD PTR _op$[ebp], edx

; 147  :             if (op & 16) {                      /* distance base */

	mov	eax, DWORD PTR _op$[ebp]
	and	eax, 16					; 00000010H
	je	$LN45@inflate_fa

; 148  :                 dist = (unsigned)(here.val);

	movzx	ecx, WORD PTR _here$[ebp+2]
	mov	DWORD PTR _dist$[ebp], ecx

; 149  :                 op &= 15;                       /* number of extra bits */

	mov	edx, DWORD PTR _op$[ebp]
	and	edx, 15					; 0000000fH
	mov	DWORD PTR _op$[ebp], edx

; 150  :                 if (bits < op) {

	mov	eax, DWORD PTR _bits$[ebp]
	cmp	eax, DWORD PTR _op$[ebp]
	jae	SHORT $LN44@inflate_fa

; 151  :                     hold += (unsigned long)(*in++) << bits;

	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	ecx, DWORD PTR _bits$[ebp]
	shl	edx, cl
	add	edx, DWORD PTR _hold$[ebp]
	mov	DWORD PTR _hold$[ebp], edx
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax

; 152  :                     bits += 8;

	mov	ecx, DWORD PTR _bits$[ebp]
	add	ecx, 8
	mov	DWORD PTR _bits$[ebp], ecx

; 153  :                     if (bits < op) {

	mov	edx, DWORD PTR _bits$[ebp]
	cmp	edx, DWORD PTR _op$[ebp]
	jae	SHORT $LN44@inflate_fa

; 154  :                         hold += (unsigned long)(*in++) << bits;

	mov	eax, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [eax]
	mov	ecx, DWORD PTR _bits$[ebp]
	shl	edx, cl
	add	edx, DWORD PTR _hold$[ebp]
	mov	DWORD PTR _hold$[ebp], edx
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax

; 155  :                         bits += 8;

	mov	ecx, DWORD PTR _bits$[ebp]
	add	ecx, 8
	mov	DWORD PTR _bits$[ebp], ecx
$LN44@inflate_fa:

; 156  :                     }
; 157  :                 }
; 158  :                 dist += (unsigned)hold & ((1U << op) - 1);

	mov	edx, 1
	mov	ecx, DWORD PTR _op$[ebp]
	shl	edx, cl
	sub	edx, 1
	and	edx, DWORD PTR _hold$[ebp]
	add	edx, DWORD PTR _dist$[ebp]
	mov	DWORD PTR _dist$[ebp], edx

; 159  : #ifdef INFLATE_STRICT
; 160  :                 if (dist > dmax) {
; 161  :                     strm->msg = (char *)"invalid distance too far back";
; 162  :                     state->mode = BAD;
; 163  :                     break;
; 164  :                 }
; 165  : #endif
; 166  :                 hold >>= op;

	mov	eax, DWORD PTR _hold$[ebp]
	mov	ecx, DWORD PTR _op$[ebp]
	shr	eax, cl
	mov	DWORD PTR _hold$[ebp], eax

; 167  :                 bits -= op;

	mov	ecx, DWORD PTR _bits$[ebp]
	sub	ecx, DWORD PTR _op$[ebp]
	mov	DWORD PTR _bits$[ebp], ecx

; 168  :                 Tracevv((stderr, "inflate:         distance %u\n", dist));
; 169  :                 op = (unsigned)(out - beg);     /* max distance in output */

	mov	edx, DWORD PTR _out$[ebp]
	sub	edx, DWORD PTR _beg$[ebp]
	mov	DWORD PTR _op$[ebp], edx

; 170  :                 if (dist > op) {                /* see if copy from window */

	mov	eax, DWORD PTR _dist$[ebp]
	cmp	eax, DWORD PTR _op$[ebp]
	jbe	$LN42@inflate_fa

; 171  :                     op = dist - op;             /* distance back in window */

	mov	ecx, DWORD PTR _dist$[ebp]
	sub	ecx, DWORD PTR _op$[ebp]
	mov	DWORD PTR _op$[ebp], ecx

; 172  :                     if (op > whave) {

	mov	edx, DWORD PTR _op$[ebp]
	cmp	edx, DWORD PTR _whave$[ebp]
	jbe	SHORT $LN41@inflate_fa

; 173  :                         if (state->sane) {

	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+7108], 0
	je	SHORT $LN41@inflate_fa

; 174  :                             strm->msg =
; 175  :                                 (char *)"invalid distance too far back";

	mov	ecx, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [ecx+24], OFFSET $SG80384

; 176  :                             state->mode = BAD;

	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+4], 16209		; 00003f51H

; 177  :                             break;

	jmp	$LN53@inflate_fa
$LN41@inflate_fa:

; 178  :                         }
; 179  : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 180  :                         if (len <= op - whave) {
; 181  :                             do {
; 182  :                                 *out++ = 0;
; 183  :                             } while (--len);
; 184  :                             continue;
; 185  :                         }
; 186  :                         len -= op - whave;
; 187  :                         do {
; 188  :                             *out++ = 0;
; 189  :                         } while (--op > whave);
; 190  :                         if (op == 0) {
; 191  :                             from = out - dist;
; 192  :                             do {
; 193  :                                 *out++ = *from++;
; 194  :                             } while (--len);
; 195  :                             continue;
; 196  :                         }
; 197  : #endif
; 198  :                     }
; 199  :                     from = window;

	mov	eax, DWORD PTR _window$[ebp]
	mov	DWORD PTR _from$[ebp], eax

; 200  :                     if (wnext == 0) {           /* very common case */

	cmp	DWORD PTR _wnext$[ebp], 0
	jne	SHORT $LN39@inflate_fa

; 201  :                         from += wsize - op;

	mov	ecx, DWORD PTR _wsize$[ebp]
	sub	ecx, DWORD PTR _op$[ebp]
	add	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR _from$[ebp], ecx

; 202  :                         if (op < len) {         /* some from window */

	mov	edx, DWORD PTR _op$[ebp]
	cmp	edx, DWORD PTR _len$[ebp]
	jae	SHORT $LN38@inflate_fa

; 203  :                             len -= op;

	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, DWORD PTR _op$[ebp]
	mov	DWORD PTR _len$[ebp], eax
$LN37@inflate_fa:

; 204  :                             do {
; 205  :                                 *out++ = *from++;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _from$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx
	mov	edx, DWORD PTR _from$[ebp]
	add	edx, 1
	mov	DWORD PTR _from$[ebp], edx

; 206  :                             } while (--op);

	mov	eax, DWORD PTR _op$[ebp]
	sub	eax, 1
	mov	DWORD PTR _op$[ebp], eax
	jne	SHORT $LN37@inflate_fa

; 207  :                             from = out - dist;  /* rest from output */

	mov	ecx, DWORD PTR _out$[ebp]
	sub	ecx, DWORD PTR _dist$[ebp]
	mov	DWORD PTR _from$[ebp], ecx
$LN38@inflate_fa:

; 208  :                         }

	jmp	$LN19@inflate_fa
$LN39@inflate_fa:

; 209  :                     }
; 210  :                     else if (wnext < op) {      /* wrap around window */

	mov	edx, DWORD PTR _wnext$[ebp]
	cmp	edx, DWORD PTR _op$[ebp]
	jae	$LN33@inflate_fa

; 211  :                         from += wsize + wnext - op;

	mov	eax, DWORD PTR _wsize$[ebp]
	add	eax, DWORD PTR _wnext$[ebp]
	sub	eax, DWORD PTR _op$[ebp]
	add	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR _from$[ebp], eax

; 212  :                         op -= wnext;

	mov	ecx, DWORD PTR _op$[ebp]
	sub	ecx, DWORD PTR _wnext$[ebp]
	mov	DWORD PTR _op$[ebp], ecx

; 213  :                         if (op < len) {         /* some from end of window */

	mov	edx, DWORD PTR _op$[ebp]
	cmp	edx, DWORD PTR _len$[ebp]
	jae	SHORT $LN32@inflate_fa

; 214  :                             len -= op;

	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, DWORD PTR _op$[ebp]
	mov	DWORD PTR _len$[ebp], eax
$LN31@inflate_fa:

; 215  :                             do {
; 216  :                                 *out++ = *from++;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _from$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx
	mov	edx, DWORD PTR _from$[ebp]
	add	edx, 1
	mov	DWORD PTR _from$[ebp], edx

; 217  :                             } while (--op);

	mov	eax, DWORD PTR _op$[ebp]
	sub	eax, 1
	mov	DWORD PTR _op$[ebp], eax
	jne	SHORT $LN31@inflate_fa

; 218  :                             from = window;

	mov	ecx, DWORD PTR _window$[ebp]
	mov	DWORD PTR _from$[ebp], ecx

; 219  :                             if (wnext < len) {  /* some from start of window */

	mov	edx, DWORD PTR _wnext$[ebp]
	cmp	edx, DWORD PTR _len$[ebp]
	jae	SHORT $LN32@inflate_fa

; 220  :                                 op = wnext;

	mov	eax, DWORD PTR _wnext$[ebp]
	mov	DWORD PTR _op$[ebp], eax

; 221  :                                 len -= op;

	mov	ecx, DWORD PTR _len$[ebp]
	sub	ecx, DWORD PTR _op$[ebp]
	mov	DWORD PTR _len$[ebp], ecx
$LN27@inflate_fa:

; 222  :                                 do {
; 223  :                                     *out++ = *from++;

	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _from$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx
	mov	eax, DWORD PTR _from$[ebp]
	add	eax, 1
	mov	DWORD PTR _from$[ebp], eax

; 224  :                                 } while (--op);

	mov	ecx, DWORD PTR _op$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _op$[ebp], ecx
	jne	SHORT $LN27@inflate_fa

; 225  :                                 from = out - dist;      /* rest from output */

	mov	edx, DWORD PTR _out$[ebp]
	sub	edx, DWORD PTR _dist$[ebp]
	mov	DWORD PTR _from$[ebp], edx
$LN32@inflate_fa:

; 226  :                             }
; 227  :                         }
; 228  :                     }
; 229  :                     else {                      /* contiguous in window */

	jmp	SHORT $LN19@inflate_fa
$LN33@inflate_fa:

; 230  :                         from += wnext - op;

	mov	eax, DWORD PTR _wnext$[ebp]
	sub	eax, DWORD PTR _op$[ebp]
	add	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR _from$[ebp], eax

; 231  :                         if (op < len) {         /* some from window */

	mov	ecx, DWORD PTR _op$[ebp]
	cmp	ecx, DWORD PTR _len$[ebp]
	jae	SHORT $LN19@inflate_fa

; 232  :                             len -= op;

	mov	edx, DWORD PTR _len$[ebp]
	sub	edx, DWORD PTR _op$[ebp]
	mov	DWORD PTR _len$[ebp], edx
$LN22@inflate_fa:

; 233  :                             do {
; 234  :                                 *out++ = *from++;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _from$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	ecx, DWORD PTR _from$[ebp]
	add	ecx, 1
	mov	DWORD PTR _from$[ebp], ecx

; 235  :                             } while (--op);

	mov	edx, DWORD PTR _op$[ebp]
	sub	edx, 1
	mov	DWORD PTR _op$[ebp], edx
	jne	SHORT $LN22@inflate_fa

; 236  :                             from = out - dist;  /* rest from output */

	mov	eax, DWORD PTR _out$[ebp]
	sub	eax, DWORD PTR _dist$[ebp]
	mov	DWORD PTR _from$[ebp], eax
$LN19@inflate_fa:

; 237  :                         }
; 238  :                     }
; 239  :                     while (len > 2) {

	cmp	DWORD PTR _len$[ebp], 2
	jbe	SHORT $LN18@inflate_fa

; 240  :                         *out++ = *from++;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _from$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx
	mov	edx, DWORD PTR _from$[ebp]
	add	edx, 1
	mov	DWORD PTR _from$[ebp], edx

; 241  :                         *out++ = *from++;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _from$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	ecx, DWORD PTR _from$[ebp]
	add	ecx, 1
	mov	DWORD PTR _from$[ebp], ecx

; 242  :                         *out++ = *from++;

	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _from$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx
	mov	eax, DWORD PTR _from$[ebp]
	add	eax, 1
	mov	DWORD PTR _from$[ebp], eax

; 243  :                         len -= 3;

	mov	ecx, DWORD PTR _len$[ebp]
	sub	ecx, 3
	mov	DWORD PTR _len$[ebp], ecx

; 244  :                     }

	jmp	SHORT $LN19@inflate_fa
$LN18@inflate_fa:

; 245  :                     if (len) {

	cmp	DWORD PTR _len$[ebp], 0
	je	SHORT $LN17@inflate_fa

; 246  :                         *out++ = *from++;

	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _from$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx
	mov	eax, DWORD PTR _from$[ebp]
	add	eax, 1
	mov	DWORD PTR _from$[ebp], eax

; 247  :                         if (len > 1)

	cmp	DWORD PTR _len$[ebp], 1
	jbe	SHORT $LN17@inflate_fa

; 248  :                             *out++ = *from++;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _from$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx
	mov	edx, DWORD PTR _from$[ebp]
	add	edx, 1
	mov	DWORD PTR _from$[ebp], edx
$LN17@inflate_fa:

; 249  :                     }
; 250  :                 }
; 251  :                 else {

	jmp	$LN15@inflate_fa
$LN42@inflate_fa:

; 252  :                     from = out - dist;          /* copy direct from output */

	mov	eax, DWORD PTR _out$[ebp]
	sub	eax, DWORD PTR _dist$[ebp]
	mov	DWORD PTR _from$[ebp], eax
$LN14@inflate_fa:

; 253  :                     do {                        /* minimum length is three */
; 254  :                         *out++ = *from++;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _from$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx
	mov	edx, DWORD PTR _from$[ebp]
	add	edx, 1
	mov	DWORD PTR _from$[ebp], edx

; 255  :                         *out++ = *from++;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _from$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	ecx, DWORD PTR _from$[ebp]
	add	ecx, 1
	mov	DWORD PTR _from$[ebp], ecx

; 256  :                         *out++ = *from++;

	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _from$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx
	mov	eax, DWORD PTR _from$[ebp]
	add	eax, 1
	mov	DWORD PTR _from$[ebp], eax

; 257  :                         len -= 3;

	mov	ecx, DWORD PTR _len$[ebp]
	sub	ecx, 3
	mov	DWORD PTR _len$[ebp], ecx

; 258  :                     } while (len > 2);

	cmp	DWORD PTR _len$[ebp], 2
	ja	SHORT $LN14@inflate_fa

; 259  :                     if (len) {

	cmp	DWORD PTR _len$[ebp], 0
	je	SHORT $LN15@inflate_fa

; 260  :                         *out++ = *from++;

	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _from$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx
	mov	eax, DWORD PTR _from$[ebp]
	add	eax, 1
	mov	DWORD PTR _from$[ebp], eax

; 261  :                         if (len > 1)

	cmp	DWORD PTR _len$[ebp], 1
	jbe	SHORT $LN15@inflate_fa

; 262  :                             *out++ = *from++;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _from$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx
	mov	edx, DWORD PTR _from$[ebp]
	add	edx, 1
	mov	DWORD PTR _from$[ebp], edx
$LN15@inflate_fa:

; 263  :                     }
; 264  :                 }

	jmp	SHORT $LN9@inflate_fa
$LN45@inflate_fa:

; 265  :             }
; 266  :             else if ((op & 64) == 0) {          /* 2nd level distance code */

	mov	eax, DWORD PTR _op$[ebp]
	and	eax, 64					; 00000040H
	jne	SHORT $LN8@inflate_fa

; 267  :                 here = dcode[here.val + (hold & ((1U << op) - 1))];

	movzx	edx, WORD PTR _here$[ebp+2]
	mov	eax, 1
	mov	ecx, DWORD PTR _op$[ebp]
	shl	eax, cl
	sub	eax, 1
	and	eax, DWORD PTR _hold$[ebp]
	add	edx, eax
	mov	ecx, DWORD PTR _dcode$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _here$[ebp], edx

; 268  :                 goto dodist;

	jmp	$dodist$80369

; 269  :             }
; 270  :             else {

	jmp	SHORT $LN9@inflate_fa
$LN8@inflate_fa:

; 271  :                 strm->msg = (char *)"invalid distance code";

	mov	eax, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [eax+24], OFFSET $SG80420

; 272  :                 state->mode = BAD;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+4], 16209		; 00003f51H

; 273  :                 break;

	jmp	SHORT $LN53@inflate_fa
$LN9@inflate_fa:

; 274  :             }

	jmp	SHORT $LN54@inflate_fa
$LN49@inflate_fa:

; 275  :         }
; 276  :         else if ((op & 64) == 0) {              /* 2nd level length code */

	mov	edx, DWORD PTR _op$[ebp]
	and	edx, 64					; 00000040H
	jne	SHORT $LN5@inflate_fa

; 277  :             here = lcode[here.val + (hold & ((1U << op) - 1))];

	movzx	eax, WORD PTR _here$[ebp+2]
	mov	edx, 1
	mov	ecx, DWORD PTR _op$[ebp]
	shl	edx, cl
	sub	edx, 1
	and	edx, DWORD PTR _hold$[ebp]
	add	eax, edx
	mov	ecx, DWORD PTR _lcode$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _here$[ebp], edx

; 278  :             goto dolen;

	jmp	$dolen$80354
	jmp	SHORT $LN54@inflate_fa
$LN5@inflate_fa:

; 279  :         }
; 280  :         else if (op & 32) {                     /* end-of-block */

	mov	eax, DWORD PTR _op$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN3@inflate_fa

; 281  :             Tracevv((stderr, "inflate:         end of block\n"));
; 282  :             state->mode = TYPE;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+4], 16191		; 00003f3fH

; 283  :             break;

	jmp	SHORT $LN53@inflate_fa

; 284  :         }
; 285  :         else {

	jmp	SHORT $LN54@inflate_fa
$LN3@inflate_fa:

; 286  :             strm->msg = (char *)"invalid literal/length code";

	mov	edx, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [edx+24], OFFSET $SG80427

; 287  :             state->mode = BAD;

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+4], 16209		; 00003f51H

; 288  :             break;

	jmp	SHORT $LN53@inflate_fa
$LN54@inflate_fa:

; 289  :         }
; 290  :     } while (in < last && out < end);

	mov	ecx, DWORD PTR _in$[ebp]
	cmp	ecx, DWORD PTR _last$[ebp]
	jae	SHORT $LN53@inflate_fa
	mov	edx, DWORD PTR _out$[ebp]
	cmp	edx, DWORD PTR _end$[ebp]
	jb	$LN55@inflate_fa
$LN53@inflate_fa:

; 291  : 
; 292  :     /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
; 293  :     len = bits >> 3;

	mov	eax, DWORD PTR _bits$[ebp]
	shr	eax, 3
	mov	DWORD PTR _len$[ebp], eax

; 294  :     in -= len;

	mov	ecx, DWORD PTR _in$[ebp]
	sub	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR _in$[ebp], ecx

; 295  :     bits -= len << 3;

	mov	edx, DWORD PTR _len$[ebp]
	shl	edx, 3
	mov	eax, DWORD PTR _bits$[ebp]
	sub	eax, edx
	mov	DWORD PTR _bits$[ebp], eax

; 296  :     hold &= (1U << bits) - 1;

	mov	edx, 1
	mov	ecx, DWORD PTR _bits$[ebp]
	shl	edx, cl
	sub	edx, 1
	and	edx, DWORD PTR _hold$[ebp]
	mov	DWORD PTR _hold$[ebp], edx

; 297  : 
; 298  :     /* update state and return */
; 299  :     strm->next_in = in;

	mov	eax, DWORD PTR _strm$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	DWORD PTR [eax], ecx

; 300  :     strm->next_out = out;

	mov	edx, DWORD PTR _strm$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+12], eax

; 301  :     strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));

	mov	ecx, DWORD PTR _in$[ebp]
	cmp	ecx, DWORD PTR _last$[ebp]
	jae	SHORT $LN58@inflate_fa
	mov	edx, DWORD PTR _last$[ebp]
	sub	edx, DWORD PTR _in$[ebp]
	add	edx, 5
	mov	DWORD PTR tv317[ebp], edx
	jmp	SHORT $LN59@inflate_fa
$LN58@inflate_fa:
	mov	eax, DWORD PTR _in$[ebp]
	sub	eax, DWORD PTR _last$[ebp]
	mov	ecx, 5
	sub	ecx, eax
	mov	DWORD PTR tv317[ebp], ecx
$LN59@inflate_fa:
	mov	edx, DWORD PTR _strm$[ebp]
	mov	eax, DWORD PTR tv317[ebp]
	mov	DWORD PTR [edx+4], eax

; 302  :     strm->avail_out = (unsigned)(out < end ?
; 303  :                                  257 + (end - out) : 257 - (out - end));

	mov	ecx, DWORD PTR _out$[ebp]
	cmp	ecx, DWORD PTR _end$[ebp]
	jae	SHORT $LN60@inflate_fa
	mov	edx, DWORD PTR _end$[ebp]
	sub	edx, DWORD PTR _out$[ebp]
	add	edx, 257				; 00000101H
	mov	DWORD PTR tv324[ebp], edx
	jmp	SHORT $LN61@inflate_fa
$LN60@inflate_fa:
	mov	eax, DWORD PTR _out$[ebp]
	sub	eax, DWORD PTR _end$[ebp]
	mov	ecx, 257				; 00000101H
	sub	ecx, eax
	mov	DWORD PTR tv324[ebp], ecx
$LN61@inflate_fa:
	mov	edx, DWORD PTR _strm$[ebp]
	mov	eax, DWORD PTR tv324[ebp]
	mov	DWORD PTR [edx+16], eax

; 304  :     state->hold = hold;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR _hold$[ebp]
	mov	DWORD PTR [ecx+60], edx

; 305  :     state->bits = bits;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR _bits$[ebp]
	mov	DWORD PTR [eax+64], ecx

; 306  :     return;
; 307  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_inflate_fast ENDP
_TEXT	ENDS
END
